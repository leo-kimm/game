<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dodge - Legend Edition</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 450px;           /* ë„ˆë¹„ ê³ ì • */
            height: 700px;          /* ë†’ì´ ê³ ì • */
            overflow: hidden;       /* ì‚ì ¸ë‚˜ê°€ëŠ” ê²ƒ ìˆ¨ê¹€ */
            transform-origin: center center; /* ì¤‘ì•™ ê¸°ì¤€ í™•ëŒ€/ì¶•ì†Œ */
            
            /* í„°ì¹˜ ë°©ì§€ ì˜µì…˜ ìœ ì§€ */
            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            background: #111;
            border: 3px solid #0ff;
            display: block;
            box-shadow: 0 0 20px #0ff;

            /* [CDSO ìˆ˜ì •] í…Œë‘ë¦¬ í¬í•¨ í¬ê¸° ê³„ì‚° ë° ì»¨í…Œì´ë„ˆ ë§ì¶¤ */
            box-sizing: border-box; /* í…Œë‘ë¦¬ë¥¼ 450px ì•ˆì— í¬í•¨ì‹œí‚´ */
            width: 100%;            /* ì»¨í…Œì´ë„ˆ ë„ˆë¹„ì— ë”± ë§ì¶¤ */
            height: 100%;           /* ì»¨í…Œì´ë„ˆ ë†’ì´ì— ë”± ë§ì¶¤ */


            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* ëª¨ë°”ì¼ ë°˜ì‘í˜• (JSë¡œ ì œì–´í•˜ê¸° ìœ„í•´ ì£¼ì„ ì²˜ë¦¬í•¨) */
        /*
        @media (max-width: 500px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
                max-height: 100vh;
                border-width: 1px;
            }

            #game-container {
                width: 100vw;
            }
        }
        */



        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
        }

        .ui-panel {
            position: absolute;
            top: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            box-sizing: border-box;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            font-size: 0.9em;
        }

        #current-score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff;
            pointer-events: none;
            z-index: 10;
        }

        #leaderboard {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            font-size: 1em;
            width: 320px;
        }

        #leaderboard h3 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-shadow: 0 0 10px #0ff;
        }

        /* [ìˆ˜ì •] ë‚´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ì—ë„ ë™ì¼í•œ ìŠ¤íƒ€ì¼ ì ìš© */
        #leaderboard li,
        #my-rank-list li,
        #result-rank-list li {
            margin: 8px 0;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            list-style: none;
            /* ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì œê±° */
        }

        /* ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ë„ ë™ì¼í•˜ê²Œ ì ìš© */
        #my-rank-list, #result-rank-list {
            padding: 0;
            margin: 15px 0; /* ê°„ê²© í™•ë³´ */
            width: 320px;
        }




        /* [ì¶”ê°€] ë‚´ ìˆœìœ„ ì „ìš© - ë¶‰ì€ìƒ‰ í…Œë‘ë¦¬ ë° ìŠ¤íƒ€ì¼ */
        li.rank-me {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.2), rgba(100, 0, 0, 0.1)) !important;
            border: 2px solid #ff0000 !important;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            font-weight: bold;
            margin-top: 20px !important;
            /* ìœ„ìª½ TOP5ì™€ ê°„ê²© ë„ìš°ê¸° */
            animation: pulseRed 2s infinite;
        }

        /* [ì¶”ê°€] ë¶‰ì€ìƒ‰ ë°°ì§€ */
        .rank-me .rank-badge {
            background: linear-gradient(135deg, #ff0000, #990000);
            color: #fff;
            box-shadow: 0 0 10px #f00;
        }

        @keyframes pulseRed {
            0% {
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 0, 0, 0.7);
            }

            100% {
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
            }
        }

        /* [ì¶”ê°€] ë‚´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #my-rank-list {
            padding: 0;
            margin: 0;
            width: 320px;
        }



        #leaderboard li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* 1ë“± - ê³¨ë“œ ê°•ì¡° */
        #leaderboard li.rank-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 180, 0, 0.15));
            border: 2px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            font-size: 1.15em;
            font-weight: bold;
        }

        /* 2ë“± - ì‹¤ë²„ */
        #leaderboard li.rank-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(150, 150, 150, 0.1));
            border: 1px solid #c0c0c0;
        }

        /* 3ë“± - ë¸Œë¡ ì¦ˆ */
        #leaderboard li.rank-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(180, 100, 40, 0.1));
            border: 1px solid #cd7f32;
        }

        /* ì‹ ê·œ ìœ ì € í•˜ì´ë¼ì´íŠ¸ */
        #leaderboard li.new-user {
            animation: newUserPulse 1.5s ease infinite;
            border-color: #0ff !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        @keyframes newUserPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            }
        }

        .rank-badge {
            min-width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
        }

        .rank-1 .rank-badge {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .rank-2 .rank-badge {
            background: linear-gradient(135deg, #c0c0c0, #888);
            color: #000;
        }

        .rank-3 .rank-badge {
            background: linear-gradient(135deg, #cd7f32, #a05a20);
            color: #fff;
        }

        .rank-4 .rank-badge,
        .rank-5 .rank-badge {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .player-name {
            flex: 1;
            text-align: left;
            color: #fff;
        }

        .player-score {
            font-weight: bold;
            color: #0ff;
            margin-right: 10px;
        }

        .player-stage {
            color: #888;
            font-size: 0.85em;
        }

        /* ê²°ê³¼ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px 40px;
            border: 2px solid #f0f;
            box-shadow: 0 0 20px #f0f, inset 0 0 15px rgba(255, 0, 255, 0.1);
            background: rgba(20, 0, 30, 0.9);
            animation: slideDown 0.5s ease-out, glitch 0.1s infinite alternate;
        }

        .result-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
            margin-bottom: 20px;
            animation: textGlitch 2s infinite;
        }

        .result-stats {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(0, 255, 255, 0.05);
            border-left: 3px solid #0ff;
        }

        .stat-row .label {
            font-size: 0.9em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        #initial-input {
            background: transparent;
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 2em;
            text-align: center;
            width: 150px;
            outline: none;
            text-transform: uppercase;
            margin-top: 20px;
            animation: inputPulse 1.5s ease-in-out infinite;
        }

        button {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 25px;
            cursor: pointer;
            font-size: 1.2em;
            margin-top: 20px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 25px #0ff;
        }

        .active-skill {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #f0f;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes slideDown {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes glitch {
            0% {
                transform: translate(0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, -1px);
            }

            75% {
                transform: translate(-1px, -1px);
            }

            100% {
                transform: translate(1px, 1px);
            }
        }

        @keyframes textGlitch {

            0%,
            90%,
            100% {
                text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
                clip-path: none;
            }

            92% {
                text-shadow: -3px 0 #0ff, 3px 0 #f0f;
                clip-path: inset(20% 0 30% 0);
            }

            94% {
                text-shadow: 3px 0 #0ff, -3px 0 #f0f;
                clip-path: inset(50% 0 10% 0);
            }

            96% {
                text-shadow: -2px 0 #0ff, 2px 0 #f0f;
                clip-path: inset(10% 0 60% 0);
            }

            98% {
                text-shadow: 2px 0 #0ff, -2px 0 #f0f;
                clip-path: inset(40% 0 20% 0);
            }
        }

        @keyframes inputPulse {

            0%,
            100% {
                box-shadow: 0 0 5px #f0f;
                border-color: #f0f;
            }

            50% {
                box-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
                border-color: #fff;
            }
        }

        /* ê²°ê³¼ í™”ë©´ ìŠ¬ë¼ì´ë“œ ì¸ */
        #rank-input-screen.show {
            animation: screenGlitchIn 0.3s ease-out;
        }

        @keyframes screenGlitchIn {
            0% {
                opacity: 0;
            }

            10% {
                opacity: 1;
                transform: translateX(-5px);
            }

            20% {
                transform: translateX(5px);
            }

            30% {
                transform: translateX(-3px);
            }

            40% {
                transform: translateX(3px);
            }

            50% {
                transform: translateX(-1px);
            }

            60% {
                transform: translateX(1px);
            }

            100% {
                transform: translateX(0);
            }
        }

        /* [CDSO ì¶”ê°€] ì„¤ì • ë²„íŠ¼ ìŠ¤íƒ€ì¼ (PCì—ì„œëŠ” ìˆ¨ê¹€, ëª¨ë°”ì¼ì—ì„œëŠ” ë…¸ì¶œ) */
        #setting-btn {
            display: none;
            /* ê¸°ë³¸ê°’: PCì—ì„œëŠ” ì•ˆ ë³´ì„ */
            margin-top: 15px;
            font-size: 0.9em;
            background: transparent;
            border: 2px solid #888;
            color: #aaa;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px #000;
        }

        #setting-btn:hover {
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* ëª¨ë°”ì¼ í™”ë©´ì—ì„œë§Œ ë²„íŠ¼ ë³´ì´ê¸° */
        @media (max-width: 500px) {
            #setting-btn {
                display: block !important;
            }
        }

        /* [CDSO Patch: ì‹œì¦Œ 2 ë°°ì§€ ë””ìì¸] */
        .season-badge {
            display: inline-block;
            margin-top: -10px;      /* íƒ€ì´í‹€ê³¼ ê°„ê²© ì¢íˆê¸° */
            margin-bottom: 20px;    /* ë­í‚¹íŒê³¼ ê°„ê²© ë²Œë¦¬ê¸° */
            padding: 5px 15px;
            
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 3px;    /* ê¸€ì ê°„ê²© ë„“ê²Œ */
            color: #00fff2;         /* ì‚¬ì´ë²„í‘í¬ ì²­ë¡ìƒ‰ */
            
            border: 2px solid #00fff2;
            border-radius: 15px;    /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
            background: rgba(0, 255, 242, 0.15); /* ë°˜íˆ¬ëª… ë°°ê²½ */
            
            box-shadow: 0 0 15px rgba(0, 255, 242, 0.5); /* ë„¤ì˜¨ ê´‘ì› íš¨ê³¼ */
            text-shadow: 0 0 5px #00fff2;
            
            animation: badgePulse 2s infinite alternate; /* ìˆ¨ì‰¬ëŠ” íš¨ê³¼ */
        }

        /* ë°°ì§€ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes badgePulse {
            0% { transform: scale(1.0); opacity: 0.8; box-shadow: 0 0 10px #00fff2; }
            100% { transform: scale(1.05); opacity: 1.0; box-shadow: 0 0 20px #00fff2, inset 0 0 10px rgba(0,255,242,0.5); }
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        // [ì¤‘ìš” ìˆ˜ì •] ì•„ë˜ import ì¤„ ëë¶€ë¶„ì— where, getDocsê°€ ë°˜ë“œì‹œ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp, where, getDocs }
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBTLq7p5i6GZ89kkWyTFXUMN2TLRBfdL8w",
            authDomain: "neon-dodge-global.firebaseapp.com",
            projectId: "neon-dodge-global",
            storageBucket: "neon-dodge-global.firebasestorage.app",
            messagingSenderId: "104500725211",
            appId: "1:104500725211:web:aa5e89d87ec21808ec4fe"
        };

        window.firebaseApp = initializeApp(firebaseConfig);
        window.firebaseDB = getFirestore(window.firebaseApp);

        // 2. window.firebaseModules ëª©ë¡ì—ë„ where, getDocs ì¶”ê°€
        window.firebaseModules = { collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp, where, getDocs };
        window.dispatchEvent(new Event('firebase-ready'));
    </script>
</head>

<body>
    <div id="game-container">
        <div class="ui-panel">
            <div id="lives">LIVES: â™¥â™¥â™¥</div>
            <div id="current-score">0</div>
            <div id="stage-info">STAGE 1 | TIME: 30</div>
        </div>
        <div id="skill-display" class="active-skill"></div>
        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="overlay">
            <h1>NEON DODGE</h1>
            <span class="season-badge">SEASON 2</span>
            <ul id="leaderboard">
                <li>Loading...</li>
            </ul>
            <ul id="my-rank-list" style="display:none;"></ul>

            <button onclick="startGame()">GAME START</button>

            <button id="setting-btn" onclick="toggleControlMode()"
                style="margin-top:10px; font-size:0.8em; border-color:#888; color:#aaa;">

                âš™ï¸ CONTROL: TRACKING
            </button>


        </div>

        <div id="rank-input-screen" class="overlay" style="display:none;">
            <div class="result-container">
                <div class="result-title" id="res-title">MISSION FAILED</div>
                <div class="result-stats">
                    <div class="stat-row">
                        <span class="label">STAGE</span>
                        <span class="value" id="res-stage">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">SCORE</span>
                        <span class="value" id="res-score">0</span>
                    </div>
                    </div>
            </div>
            
            <input type="text" id="initial-input" maxlength="3" placeholder="AAA">
            
            <button id="btn-save" onclick="saveAndRestart()">SAVE RECORD</button>
            
            <ul id="result-rank-list" style="display:none;"></ul>

            <div id="action-buttons" style="display:none; gap:15px; margin-top:5px;">
                <button onclick="location.reload()" style="border-color:#0ff; color:#0ff; padding: 10px 20px;">
                    ğŸ”„ RESTART
                </button>
                <button onclick="shareScore()" style="border-color:#f0f; color:#f0f; padding: 10px 20px;">
                    ğŸ“¤ SHARE
                </button>
            </div>
        </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 450; canvas.height = 700;

        const levels = [
            { stage: 1, duration: 10, theme: '#0ff', speedMult: 1.0, spawnRate: 0.69, types: ['NORMAL'], isBoss: false },
            { stage: 2, duration: 11, theme: '#0f0', speedMult: 1.1, spawnRate: 0.62, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
            { stage: 3, duration: 12, theme: '#8ef', speedMult: 1.2, spawnRate: 0.54, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
            { stage: 4, duration: 13, theme: '#aaf', speedMult: 1.3, spawnRate: 0.46, types: ['NORMAL', 'ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 5, duration: 14, theme: '#88f', speedMult: 1.4, spawnRate: 0.42, types: ['ZIGZAG', 'HOMING'], isBoss: true, bossHP: 70, bossType: 'LUNAR' },
            { stage: 6, duration: 15, theme: '#f80', speedMult: 1.5, spawnRate: 0.31, types: ['ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 7, duration: 16, theme: '#f64', speedMult: 1.6, spawnRate: 0.27, types: ['ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 8, duration: 17, theme: '#f44', speedMult: 1.7, spawnRate: 0.25, types: ['NORMAL', 'ZIGZAG', 'HOMING', 'SHOOTER'], isBoss: false },
            { stage: 9, duration: 18, theme: '#f22', speedMult: 1.9, spawnRate: 0.22, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER'], isBoss: false },
            { stage: 10, duration: 19, theme: '#f80', speedMult: 2.0, spawnRate: 0.19, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER', 'LASER_ENEMY'], isBoss: true, bossHP: 200, bossType: 'SUN' }
        ];

        // â–¼â–¼â–¼ [CDSO ê¸´ê¸‰ íŒ¨ì¹˜] ì´ ì½”ë“œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”! â–¼â–¼â–¼
        if (typeof levels !== 'undefined') {
            levels.push({
                stage: 11,
                duration: 99999,      // ì‹œê°„ ë¬´ì œí•œ
                theme: '#050505',     // ì‹¬ì—°ì˜ ê²€ì€ìƒ‰ ë°°ê²½
                speedMult: 2.0,       // ì†ë„ ë°°ìœ¨
                spawnRate: 0.1,       // ìŠ¤í°ìœ¨
                types: [],            // ì  íƒ€ì… (spawnEntities í•¨ìˆ˜ê°€ ì²˜ë¦¬í•¨)
                isBoss: false         // ë³´ìŠ¤ ì•„ë‹˜
                });
            console.log("âœ… Stage 11 Dummy Data Injected");
        }


        let gameState = {
            isRunning: false, score: 0,
            player: { x: 215, y: 630, w: 20, h: 20, speed: 400 },
            enemies: [], items: [], bullets: [], keys: {},
            skillMode: 'NORMAL', skillTimer: 0,
            lives: 3, maxLives: 3, isInvincible: false, invincibilityTimer: 0,
            drones: [],
            isTransformed: false,
            isLaserMode: false, laserTimer: 0,
            spawnTimer: 0, itemSpawnTimer: 0,
            currentStage: 1, stageTimer: 30, boss: null,
            stageClearing: false, stageClearTimer: 0, survivalMode: false,
            bossPhase: 'MINION',
            bossTimer: 0,
            bossResurrected: false,
            downgradeFlash: 0,
            progressDisplay: 0,
            survivalStartCount: 0,
            spawnDelay: 0,
            isLunarMode: false,
            lunarAngle: 0,
            touchTarget: null,
            stageTimerEnded: false,
            survivalTimer: 0,
            pendingBoss: null,
            // ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤
            ultGauge: 0,           // í•„ì‚´ê¸° ê²Œì´ì§€ (0~1)
            autoFireTimer: 0,      // ìë™ ë°œì‚¬ íƒ€ì´ë¨¸
            isHomingMode: false,   // ìœ ë„íƒ„ ëª¨ë“œ
            homingTimer: 0,        // ìœ ë„íƒ„ ì§€ì† ì‹œê°„
            rainbowWave: null,     // ë¬´ì§€ê°œ íŒŒë™ ìƒíƒœ
            dangerWarning: 0,      // DANGER ê²½ê³  íƒ€ì´ë¨¸
            timeBonusDisplay: null // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ
        };


        // [CDSO ì „ëµ] ì»¨íŠ¸ë¡¤ ëª¨ë“œ ìƒíƒœ ê´€ë¦¬ ('TRACKING' vs 'BUTTONS')
        // localStorageë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ ì €ì˜ ì„ íƒì„ ê¸°ì–µí•©ë‹ˆë‹¤.
        let controlMode = localStorage.getItem('controlMode') || 'BUTTONS';

        function toggleControlMode() {
            // ëª¨ë“œ í† ê¸€ (TRACKING <-> BUTTONS)
            controlMode = controlMode === 'TRACKING' ? 'BUTTONS' : 'TRACKING';
            localStorage.setItem('controlMode', controlMode); // ì €ì¥
            updateSettingBtn(); // UI ì—…ë°ì´íŠ¸
        }

        function updateSettingBtn() {
            const btn = document.getElementById('setting-btn');
            if (btn) {
                if (controlMode === 'TRACKING') {
                    btn.innerHTML = 'âš™ï¸ CONTROL: ğŸ‘† TRACKING'; // ì¶”ì  ëª¨ë“œ
                    btn.style.color = '#0ff';
                    btn.style.borderColor = '#0ff';
                } else {
                    btn.innerHTML = 'âš™ï¸ CONTROL: â¬…ï¸â¡ï¸ BUTTONS'; // ë²„íŠ¼ ëª¨ë“œ
                    btn.style.color = '#f0f';
                    btn.style.borderColor = '#f0f';
                }
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
        window.addEventListener('load', updateSettingBtn);




        let firebaseReady = false;
        let lastSavedName = '';  // ì‹ ê·œ ë“±ë¡ ìœ ì € í•˜ì´ë¼ì´íŠ¸ìš©

        window.isVeteranServer = false  // ê¸°ë³¸ê°’: ì•„ì§ ê³ ì¸ë¬¼ ì„œë²„ ì•„ë‹˜


        // [CDSO ì „ëµ ìˆ˜ì •] ë¹„ìš© ìµœì í™”: ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆ(onSnapshot) ì œê±° -> ë‹¨ë°œì„± ì¡°íšŒ(getDocs)ë¡œ ë³€ê²½
        async function initFirebaseRanking() {
            // DB ì—°ê²° ê°ì²´ì™€ í•¨ìˆ˜ ëª¨ë“ˆì´ ëª¨ë‘ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°
            if (!window.firebaseDB || !window.firebaseModules) { 
                console.log("Waiting for Firebase Modules...");
                setTimeout(initFirebaseRanking, 100); 
                return;
            }

            firebaseReady = true;

            const { collection, query, orderBy, limit, getDocs } = window.firebaseModules;
            const list = document.getElementById('leaderboard');

            try {
                // 1. ì¿¼ë¦¬ ìƒì„± (ê¸°ì¡´ê³¼ ë™ì¼)
                const q = query(
                    // [ìˆ˜ì • ì „] collection(window.firebaseDB, 'rankings'),
                    // [ìˆ˜ì • í›„] ì‹œì¦Œ2ìš© ìƒˆ ì»¬ë ‰ì…˜ ì´ë¦„ìœ¼ë¡œ ë³€ê²½
                    collection(window.firebaseDB, 'rankings'),
                    orderBy('score', 'desc'),
                    limit(10)
                );

                // 2. [ë³€ê²½] getDocsë¥¼ ì‚¬ìš©í•˜ì—¬ 1íšŒë§Œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë¹„ìš© ì ˆê° í•µì‹¬)
                const snapshot = await getDocs(q);

                // ì¡°ê±´: ë­í‚¹ì— 10ëª… ì´ìƒ ìˆê³  && 10ë“±(ì¸ë±ìŠ¤ 9)ì˜ ì ìˆ˜ê°€ 5000ì  ì´ìƒì¸ê°€?
                if (snapshot.docs.length >= 10) {
                    const tenthRankScore = snapshot.docs[9].data().score;
                    if (tenthRankScore >= 5000) {
                        window.isVeteranServer = true;
                        console.log("âš”ï¸ Server Status: VETERAN (Cutline established)");
                    } else {
                        window.isVeteranServer = false;
                    }
                } else {
                    window.isVeteranServer = false; // ì‚¬ëŒì´ 10ëª…ë„ ì•ˆ ë˜ë©´ ì•„ì§ ë£¨í‚¤ ëª¨ë“œ ì—†ìŒ
                }


                list.innerHTML = '<h3>ğŸŒ GLOBAL TOP 5</h3>';

                // [CDSO í•µì‹¬ ì¶”ê°€] 3ë“± ì ìˆ˜ ì¶”ì¶œ (ì—†ìœ¼ë©´ 0ì )
                // ë°°ì—´ ì¸ë±ìŠ¤ 2ê°€ 3ë“±ì…ë‹ˆë‹¤ (0=1ë“±, 1=2ë“±, 2=3ë“±)
                if (snapshot.docs.length >= 3) {
                    // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ 3ë“±ì˜ ì ìˆ˜ë¥¼ ê°€ì ¸ì™€ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
                    gameState.rank3Score = snapshot.docs[2].data().score;
                    console.log("ğŸ¯ Target Score (Top 3 Cutline):", gameState.rank3Score);
                } else {
                    // ë­í‚¹ì— ì‚¬ëŒì´ 3ëª…ë„ ì—†ìœ¼ë©´? ë¬´ì¡°ê±´ 1ë“± ì§„ì… ê°€ëŠ¥í•˜ë¯€ë¡œ ì»¤íŠ¸ë¼ì¸ 0
                    gameState.rank3Score = 0;
                }



                if (snapshot.empty) {
                    list.innerHTML += '<li class="rank-1">No Records Yet</li>';
                } else {
                    snapshot.docs.forEach((doc, i) => {
                        const r = doc.data();
                        const rank = i + 1;
                        const isNewUser = lastSavedName && r.name === lastSavedName;
                        const rankClass = `rank-${rank}${isNewUser ? ' new-user' : ''}`;
                        const rankEmoji = rank === 1 ? 'ğŸ¥‡' : (rank === 2 ? 'ğŸ¥ˆ' : (rank === 3 ? 'ğŸ¥‰' : rank));

                        // [CDSO í•µì‹¬ ìˆ˜ì •] 6ë“±ë¶€í„°(index 5 ì´ìƒ)ëŠ” í™”ë©´ì—ì„œ ìˆ¨ê¹ë‹ˆë‹¤.
                        // í•˜ì§€ë§Œ HTMLì—ëŠ” ì¡´ì¬í•˜ë¯€ë¡œ shareScore í•¨ìˆ˜ê°€ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                        const hideStyle = i >= 5 ? 'style="display:none;"' : '';


                        list.innerHTML += `
                            <li class="${rankClass}" ${hideStyle}>
                                <span class="rank-badge">${rankEmoji}</span>
                                <span class="player-name">${r.name}</span>
                                <span class="player-score">${r.score.toLocaleString()}</span>
                                <span class="player-stage">ST.${r.stage}</span>
                            </li>`;
                    });
                }
            } catch (e) {
                console.error("Ranking Load Error:", e);
                // ì—ëŸ¬ê°€ ë‚˜ë„ ë¡œë”© í…ìŠ¤íŠ¸ë¥¼ ì—†ì• ê³  ê¸°ë³¸ ìƒíƒœë¡œ ì „í™˜
                list.innerHTML = '<h3>ğŸŒ GLOBAL TOP 5</h3><li class="rank-1">Network/Data Error</li>';
                // ì—ëŸ¬ ì‹œ ì•ˆì „í•˜ê²Œ ì»¤íŠ¸ë¼ì¸ì„ 0ìœ¼ë¡œ ì„¤ì •
                gameState.rank3Score = 0;

            }

            // ë‚´ ìµœê³  ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
            const savedData = localStorage.getItem('myBestRecord');
            if (savedData) {
                try {
                    const r = JSON.parse(savedData);
                    if (r.score > 0) updateMyRank(r.name, r.score, r.stage);
                } catch (e) { console.error('Data parsing error', e); }
            }
        }


        // [CDSO Finalized] í†µí•© ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ê¸° (All-in-One)
        function getSystemInfo() {
            const ua = navigator.userAgent;
            let os = 'UNKNOWN';
            let osVer = '';
            let browser = 'UNKNOWN';
            let model = 'PC/Generic';
            let engine = 'Unknown Engine';

            // 1. OS & Version ì •ë°€ ë¶„ì„
            if (/Windows/i.test(ua)) {
                os = 'Windows';
                const match = ua.match(/Windows NT ([\d.]+)/);
                if (match) osVer = match[1];
            } else if (/Android/i.test(ua)) {
                os = 'Android';
                const match = ua.match(/Android\s([0-9.]+)/);
                if (match) osVer = match[1];
                
                // ì•ˆë“œë¡œì´ë“œ ëª¨ë¸ëª… ì¶”ì¶œ
                const modelMatch = ua.match(/;\s([^;]+)\sBuild/);
                if (modelMatch) model = modelMatch[1].trim();
            } else if (/iPhone|iPad|iPod/i.test(ua)) {
                os = 'iOS';
                const match = ua.match(/OS\s([\d_]+)/);
                if (match) osVer = match[1].replace(/_/g, '.');
                model = 'iPhone/iPad';
            } else if (/Mac/i.test(ua)) {
                os = 'Mac';
            }

            // 2. Browser ì •ë°€ ë¶„ì„
            if (/KAKAOTALK/i.test(ua)) browser = 'KakaoTalk InApp';
            else if (/NAVER/i.test(ua)) browser = 'Naver InApp';
            else if (/Instagram/i.test(ua)) browser = 'Instagram InApp';
            else if (/Chrome/i.test(ua)) browser = 'Chrome';
            else if (/Safari/i.test(ua)) browser = 'Safari';
            else if (/Firefox/i.test(ua)) browser = 'Firefox';

            // 3. ì—”ì§„ ë²„ì „ ì¶”ì¶œ
            const engineMatch = ua.match(/(AppleWebKit\/[\d.]+)/);
            if (engineMatch) {
                engine = engineMatch[1]; 
            } else if (/Gecko\//.test(ua)) {
                engine = 'Gecko (Mozilla)';
            }

            // 4. í™”ë©´ ë° í”Œë«í¼ ì •ë³´ (êµ¬ë²„ì „ ê¸°ëŠ¥ í†µí•©)
            const isMobile = /Mobi|Android/i.test(ua) || window.innerWidth <= 500;
            const resolution = `${window.innerWidth}x${window.innerHeight}`;
            const controlType = localStorage.getItem('controlMode') || 'BUTTONS';

            // 5. í†µí•© ê°ì²´ ë°˜í™˜
            return {
                // [Parsed Data]
                os,
                osVer,
                browser,
                model,
                engine,
                
                // [Environment Data]
                platform: isMobile ? 'MOBILE' : 'PC',
                resolution: resolution,
                control: controlType,
                
                // [Raw Data]
                raw_ua: ua
            };
        }



        async function saveToFirebase(name, score, stage) {
            if (!firebaseReady) return;

            // ë¡œì»¬ ì €ì¥
            const myRecord = { name, score, stage };
            localStorage.setItem('myBestRecord', JSON.stringify(myRecord));

            // [CDSO] í†µí•©ëœ ì‹œìŠ¤í…œ ì •ë³´ í˜¸ì¶œ (ë³€ìˆ˜ëª… 'sys'ë¡œ í†µì¼)
            const sys = getSystemInfo(); 

            // í”Œë ˆì´ ì‹œê°„ ê³„ì‚°
            const playTimeSec = Math.floor((Date.now() - gameState.startTime) / 1000);

            // ì•„ì´í…œ íšë“ë¥  ê³„ì‚°
            const collectionRate = gameState.totalItemsSpawned > 0
                ? Math.round((gameState.itemsCollected / gameState.totalItemsSpawned) * 100)
                : 0;

            // íƒìš• ì‚¬ë§ íŒì •
            let isGreedyDeath = false;
            const px = gameState.player.x, py = gameState.player.y;
            for (let item of gameState.items) {
                const dist = Math.sqrt(Math.pow(item.x - px, 2) + Math.pow(item.y - py, 2));
                if (dist < 100) { isGreedyDeath = true; break; }
            }

            const { collection, addDoc, serverTimestamp } = window.firebaseModules;
            try {
                // [ìˆ˜ì • ì „] await addDoc(collection(window.firebaseDB, 'rankings'), {
                // [ìˆ˜ì • í›„] ì €ì¥í•  ë•Œë„ ê°™ì€ ê³³ì„ ë°”ë¼ë´ì•¼ í•©ë‹ˆë‹¤.
                await addDoc(collection(window.firebaseDB, 'rankings'), {
                    // [Basic Info]
                    name,
                    score,
                    stage,
                    timestamp: serverTimestamp(),

                    // [Detailed System Info] - sys ê°ì²´ì—ì„œ ëª¨ë‘ í•´ê²°
                    os: sys.os,                 // OS ì¢…ë¥˜ (Android, Windows...)
                    osVer: sys.osVer,           // OS ë²„ì „ (15, 10...)
                    browser: sys.browser,       // ë¸Œë¼ìš°ì € (Chrome, KakaoTalk...)
                    model: sys.model,           // ê¸°ê¸° ëª¨ë¸ëª… (SM-G991N...)
                    engine: sys.engine,         // ì—”ì§„ ì •ë³´ (AppleWebKit/537.36...)
                    
                    // [Environment Info]
                    platform: sys.platform,     // MOBILE vs PC
                    screen: sys.resolution,     // í™”ë©´ í•´ìƒë„ (450x700...)
                    control: sys.control,       // ì¡°ì‘ ë°©ì‹ (TRACKING...)
                    
                    // [Raw Data Archiving] - ì›ë³¸ ë³´ì¡´
                    ua_full: sys.raw_ua,        // User-Agent ì›ë³¸ ë¬¸ìì—´

                    // [Game Analytics]
                    playTimeSec: playTimeSec,           
                    deathReason: gameState.lastHitBy,   
                    itemCollectionRate: collectionRate, 
                    isGreedyDeath: isGreedyDeath        
                });

                lastSavedName = name;
                const rank = await updateMyRank(name, score, stage);
                return rank;

            }
            catch (e) { console.error(e); return null; }
        }



        async function updateMyRank(name, score, stage) {
            // ì¸ìê°€ ë¶€ì¡±í•˜ë©´ ì‹¤í–‰ ì¤‘ë‹¨
            if (!firebaseReady || !score) return;

            const { collection, query, where, getDocs } = window.firebaseModules;
            try {
                // ë‚´ ì ìˆ˜ë³´ë‹¤ ë†’ì€ ì‚¬ëŒ ìˆ˜ ê³„ì‚° (ë“±ìˆ˜ ì‚°ì •)
                const higherQuery = query(
                    // [ìˆ˜ì • ì „] collection(window.firebaseDB, 'rankings'),
                    // [ìˆ˜ì • í›„]
                    collection(window.firebaseDB, 'rankings'),
                    where('score', '>', score)
                );
                const higherSnapshot = await getDocs(higherQuery);
                const myRank = higherSnapshot.size + 1;

                // [ìˆ˜ì •] ê¸°ì¡´ í…ìŠ¤íŠ¸ div ëŒ€ì‹ , ë¦¬ìŠ¤íŠ¸(ul) ì•ˆì— ìƒˆë¡œìš´ li ë°•ìŠ¤ë¥¼ ìƒì„±í•´ ë„£ìŒ
                const rankList = document.getElementById('my-rank-list');

                // HTML êµ¬ì¡° ìƒì„± (CSSì˜ .rank-me ìŠ¤íƒ€ì¼ì´ ì ìš©ë¨)
                rankList.innerHTML = `
                    <li class="rank-me">
                        <span class="rank-badge">${myRank}</span>
                        <span class="player-name">${name}</span>
                        <span class="player-score">${score.toLocaleString()}</span>
                        <span class="player-stage">ST.${stage}</span>
                    </li>
                `;
                rankList.style.display = 'block';

                // [í•µì‹¬] ê°’ì„ ë¦¬í„´í•©ë‹ˆë‹¤
                return myRank;


            } catch (e) {
                console.error('Failed to calculate rank:', e);
                return null; // ì—ëŸ¬ ì‹œ null ë°˜í™˜
            }
        }

        // ì‹¤ì œ ì  ê¸°ì²´ë§Œ ì¹´ìš´íŠ¸ (íƒ„í™˜ + í­ë°œ/ë°œì‚¬ ì™„ë£Œ ì  ì œì™¸)
        function getActiveEnemyCount() {
            return gameState.enemies.filter(en =>
                en.type !== 'BULLET' &&
                en.type !== 'ENEMY_BULLET' &&
                en.type !== 'SHOCKWAVE' &&
                en.type !== 'METEOR' &&
                !(en.type === 'BOMBER' && en.exploded) &&
                !(en.type === 'LASER_ENEMY' && en.fired)
            ).length;
        }

        // ì  íƒ€ì…ë³„ ì°¨ë“± ì ìˆ˜ (ì†Œìˆ˜ì  ë‹¨ìœ„)
        function getEnemyScore(type) {
            const scoreTable = {
                'NORMAL': 1.0,
                'ZIGZAG': 1.2,
                'HOMING': 1.5,
                'SHOOTER': 1.8,
                'BOMBER': 2.0,
                'LASER_ENEMY': 2.2,
                'MINION': 0.5,
                // [Patch A] ë¬´ì˜ë¯¸í•œ ê°ì²´ ì ìˆ˜ 0 ì²˜ë¦¬ (Data Sanitization)
                'BULLET': 0,
                'ENEMY_BULLET': 0,
                'OBSTACLE': 0 // ì¶”í›„ ì¥ì• ë¬¼ ì¶”ê°€ ëŒ€ë¹„
            };
            return (scoreTable[type] !== undefined) ? scoreTable[type] : 1.0;
        }

        // Phase 6: Safety Margin ì¶©ëŒ íŒì • (2px ì—¬ìœ )
        function checkCollisionWithMargin(a, b, margin = 2) {
            return !(
                a.x + a.w + margin < b.x ||
                a.x - margin > b.x + b.w ||
                a.y + a.h + margin < b.y ||
                a.y - margin > b.y + b.h
            );
        }

        function takeDamage() {
            // [CDSO ì¶”ê°€] 1000ì  ë¯¸ë§Œ ì ˆëŒ€ ë¬´ì  (Tutorial Guard)
            // ë£¨í‚¤ ëª¨ë“œì´ê³  + ì ìˆ˜ê°€ 1000ì  ë¯¸ë§Œì´ë¼ë©´?
            if (gameState.isRookieMode && gameState.score < 1000) {
                // 1. ë°ë¯¸ì§€ ë¬´ì‹œ (ë¦¬í„´)
                // 2. ëŒ€ì‹  "ë§ì•˜ë‹¤"ëŠ” ì‹œê°ì  í”¼ë“œë°±ë§Œ ì¤Œ (ê¹œë¹¡ê±°ë¦¼)
                gameState.downgradeFlash = 0.3; 
                
                // (ì„ íƒì‚¬í•­) ì§„ë™ì€ ì¤˜ì„œ 'ìœ„í—˜í•˜ë‹¤'ëŠ” ì‹ í˜¸ëŠ” ë³´ëƒ„
                triggerHaptic(100); 
                
                return; // â˜… í•¨ìˆ˜ ê°•ì œ ì¢…ë£Œ (ìƒëª…ë ¥ ê°ì†Œ ì½”ë“œ ì‹¤í–‰ ì•ˆ ë¨)
            }


            // [CDSO ìˆ˜ì •] ë¬´ì ì´ë‚˜ ì‰´ë“œ ìƒíƒœë©´ ì§„ë™ ì•ˆ í•¨
            if (gameState.isInvincible || gameState.skillMode === 'SHIELD') return;

            // [CDSO í•µì‹¬ ì¶”ê°€] í”¼ê²© ì‹œ 300ms(0.3ì´ˆ) ë™ì•ˆ ê°•í•œ ì§„ë™ ë°œìƒ!
            triggerHaptic(300);


            if (gameState.isInvincible || gameState.skillMode === 'SHIELD') return;

            if (gameState.isTransformed) {
                gameState.isTransformed = false;
                gameState.isLaserMode = false;
                gameState.laserTimer = 0;
                gameState.isLunarMode = false;  // í™©ê¸ˆ ë³€ì‹  í•´ì œ ì‹œ ë£¨ë‚˜ëª¨ë“œë„ í•¨ê»˜ í•´ì œ
                gameState.drones = [{ offsetX: -35, shootTimer: 0 }];
                gameState.isInvincible = true;
                gameState.invincibilityTimer = 1.5;
                gameState.downgradeFlash = 0.5;
                return;
            }

            if (gameState.drones.length > 0) {
                gameState.drones.pop();
                return;
            }

            // [CDSO ìˆ˜ì •] ë³¸ì²´ í”¼ê²© ì‹œ ì²˜ë¦¬
            gameState.lives--;
            gameState.isLunarMode = false; // â˜… í•µì‹¬: ë³¸ì²´ê°€ ë§ìœ¼ë©´ ë£¨ë‚˜ ê°€ë””ì–¸ íŒŒê´´ë¨

            updateLivesUI();
            if (gameState.lives <= 0) gameOver();
            else { gameState.isInvincible = true; gameState.invincibilityTimer = 2.0; }
        }

        function updateLivesUI() {
            // ë¹ˆ í•˜íŠ¸ ê°œìˆ˜ê°€ ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡ 0ê³¼ ë¹„êµí•˜ì—¬ í° ê°’ì„ ì·¨í•¨
            const emptyHearts = Math.max(0, gameState.maxLives - gameState.lives);

            document.getElementById('lives').textContent = `LIVES: ${'â™¥'.repeat(gameState.lives)}${'â™¡'.repeat(gameState.maxLives - gameState.lives)}`;
        }

        function updateDrones(dt) {
            if (gameState.isTransformed) return;
            gameState.drones.forEach(drone => {
                drone.shootTimer += dt;
                if (drone.shootTimer > 0.5) {
                    gameState.bullets.push({ x: gameState.player.x + 10 + drone.offsetX - 4, y: gameState.player.y, w: 8, h: 15, speed: 650 });
                    drone.shootTimer = 0;
                }
            });
        }

        window.addEventListener('keydown', e => {
            gameState.keys[e.key] = true;
            // Space í‚¤ë¡œ í•„ì‚´ê¸° ë°œë™
            if (e.code === 'Space' && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                activateRainbowWave();
            }
        });
        window.addEventListener('keyup', e => gameState.keys[e.key] = false);

        // ëª¨ë°”ì¼ í„°ì¹˜ ì¢Œí‘œ ë³€í™˜
        // [CDSO ìˆ˜ì • Step 2] ê¸°ê¸° ê¸°ë°˜ ì—„ê²©í•œ ë°°ìœ¨ ê³ ì • ì‹œìŠ¤í…œ
        let gameScale = 1;

        // ëª¨ë°”ì¼ ê¸°ê¸° ê°ì§€ (ì •ê·œì‹ í™œìš©)
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function resizeGame() {
            const container = document.getElementById('game-container');
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const baseW = 450;
            const baseH = 700;
            
            // 1. ê¸°ê¸° íƒ€ì… íŒë³„
            const isMobile = isMobileDevice();

            if (!isMobile) {
                // [PC ì „ëµ] ì°½ í¬ê¸°ì™€ ìƒê´€ì—†ì´ ì›ë³¸ í¬ê¸°(1.0) ì ˆëŒ€ ì‚¬ìˆ˜
                // ì°½ì„ ì¤„ì´ë©´ ê²Œì„ í™”ë©´ì´ ì˜ë¦¬(Clipping)ë”ë¼ë„ í¬ê¸°ëŠ” ìœ ì§€ë¨
                gameScale = 1.0; 
            } else {
                // [ëª¨ë°”ì¼ ì „ëµ] í™”ë©´ì— ê½‰ ì°¨ê²Œ ì¤„ì´ë˜, ìµœì†Œ ì•ˆì „ ë°°ìœ¨(0.5) ì„¤ì •
                const ratio = Math.min(winW / baseW, winH / baseH);
                gameScale = Math.max(ratio, 0.5); // 0.5ë°° ë¯¸ë§Œìœ¼ë¡œ ì‘ì•„ì§€ì§€ ì•ŠìŒ (ê°€ë…ì„± ë³´í˜¸)
            }
            
            // 2. ì»¨í…Œì´ë„ˆ ì¤‘ì•™ ì •ë ¬ ë° ìŠ¤ì¼€ì¼ ì ìš©
            container.style.position = 'absolute';
            container.style.left = '50%';
            container.style.top = '50%';
            container.style.transform = `translate(-50%, -50%) scale(${gameScale})`;
        }

        window.addEventListener('resize', resizeGame);
        window.addEventListener('load', resizeGame);
        
        // (getTouchPos í•¨ìˆ˜ëŠ” ìˆ˜ì •í•  í•„ìš” ì—†ì´ ê·¸ëŒ€ë¡œ ë‘ì‹œë©´ ë©ë‹ˆë‹¤.)

        // ìˆ˜ì •ëœ í„°ì¹˜ ì¢Œí‘œ ë³€í™˜ (ìŠ¤ì¼€ì¼ë§ ë°˜ì˜)
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            
            // ì—­ë³´ì • ê³µì‹
            return {
                x: (touch.clientX - rect.left) * (450 / rect.width),
                y: (touch.clientY - rect.top) * (700 / rect.height)
            };
        }



        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ (ì œìŠ¤ì²˜ ì°¨ë‹¨ + ë¶€ë“œëŸ¬ìš´ ì¶”ì )
        let isTouching = false;
        // [CDSO ì „ëµ ìˆ˜ì •] í•˜ì´ë¸Œë¦¬ë“œ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì‹œìŠ¤í…œ
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // [CDSO ìµœì¢… ìˆ˜ì •] í„°ì¹˜ í•¸ë“¤ëŸ¬: í•˜ë‹¨ 10% í•„ì‚´ê¸° / ìƒë‹¨ 90% ì´ë™
        function handleTouch(e) {
            e.preventDefault();

            if (controlMode === 'TRACKING') {
                // [ëª¨ë“œ A] ì¶”ì  ëª¨ë“œ
                const pos = getTouchPos(e);
                gameState.touchTarget = pos.x - gameState.player.w / 2;

                // ì¶”ì  ëª¨ë“œì—ì„œë„ í•˜ë‹¨ 10%ë¥¼ ëˆ„ë¥´ë©´ í•„ì‚´ê¸° ë°œë™ (í†µì¼ì„± ìœ ì§€)
                if (pos.y > canvas.height * 0.90 && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                    activateRainbowWave();
                }

            } else {
                // [ëª¨ë“œ B] ë²„íŠ¼ ëª¨ë“œ
                gameState.keys['ArrowLeft'] = false;
                gameState.keys['ArrowRight'] = false;
                gameState.touchTarget = null;

                const halfWidth = window.innerWidth / 2;
                // í•˜ë‹¨ 15% ë†’ì´ ê³„ì‚° (0.1 ~ 0.15 ì¶”ì²œ)
                const ultZoneY = window.innerHeight * 0.9;

                // ë©€í‹°í„°ì¹˜ ë£¨í”„
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];

                    // 1. í•„ì‚´ê¸° ì˜ì—­ ì²´í¬ (í™”ë©´ í•˜ë‹¨ 15%)
                    // ê²Œì´ì§€ê°€ ìˆëŠ” ì•„ë˜ìª½ì„ ëˆ„ë¥´ë©´ ë°œë™
                    if (t.clientY > ultZoneY) {
                        if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                            activateRainbowWave();
                        }
                        continue; // í•„ì‚´ê¸° ëˆ„ë¥¸ ì†ê°€ë½ì€ ì´ë™ì— ì˜í–¥ ì£¼ì§€ ì•ŠìŒ
                    }

                    // 2. ì´ë™ ì˜ì—­ ì²´í¬ (í™”ë©´ ìƒë‹¨ 85%)
                    // ë‚˜ë¨¸ì§€ ë„“ì€ í™”ë©´ì„ ì¢Œìš° ë²„íŠ¼ìœ¼ë¡œ ì‚¬ìš©
                    if (t.clientX < halfWidth) {
                        gameState.keys['ArrowLeft'] = true;
                    } else {
                        gameState.keys['ArrowRight'] = true;
                    }
                }
            }
        }


        // [CDSO ì¶”ê°€] í–…í‹± í”¼ë“œë°± ì‹œìŠ¤í…œ (ì§„ë™ íš¨ê³¼)
        function triggerHaptic(duration) {
            // 1. ì§„ë™ API ì§€ì› ì—¬ë¶€ í™•ì¸
            // 2. ëª¨ë°”ì¼ ê¸°ê¸°ì¸ì§€ í™•ì¸
            // 3. ì§„ë™ì´ ì¼œì ¸ ìˆëŠ”ì§€ í™•ì¸ (ë³´í†µ ë¸Œë¼ìš°ì € ì„¤ì • ë”°ë¦„)
            if (navigator.vibrate && isMobileDevice()) {
                try {
                    navigator.vibrate(duration);
                } catch (e) {
                    console.log("Vibration blocked by system");
                }
            }
        }





        // í„°ì¹˜ ì¢…ë£Œ ì²˜ë¦¬
        function handleTouchEnd(e) {
            e.preventDefault();

            if (controlMode === 'TRACKING') {
                // ì¶”ì  ëª¨ë“œëŠ” ì†ì„ ë–¼ë©´ ë©ˆì¶¤ (ë§ˆì§€ë§‰ ìœ„ì¹˜ ìœ ì§€)
                // gameState.touchTarget = null; // ì›í•˜ë©´ ì´ ì£¼ì„ í•´ì œí•˜ì—¬ ë©ˆì¶”ê²Œ ê°€ëŠ¥
            } else {
                // ë²„íŠ¼ ëª¨ë“œëŠ” ì†ì„ ë–¼ë©´ í‚¤ ì…ë ¥ í•´ì œ (ë‚¨ì€ í„°ì¹˜ ë‹¤ì‹œ ê³„ì‚°)
                if (e.touches.length === 0) {
                    gameState.keys['ArrowLeft'] = false;
                    gameState.keys['ArrowRight'] = false;
                } else {
                    handleTouch(e); // ì•„ì§ ë‹¤ë¥¸ ì†ê°€ë½ì´ ë¶™ì–´ìˆìœ¼ë©´ ì¬ê³„ì‚°
                }
            }
        }





        // ìë™ ì¼ì‹œì •ì§€ (ì „í™”/í™ˆ í™”ë©´ ì „í™˜ ì‹œ)
        document.addEventListener('visibilitychange', function () {
            if (document.hidden && gameState.isRunning) {
                gameState.isRunning = false;
                document.getElementById('start-screen').style.display = 'flex';
                document.querySelector('#start-screen h1').textContent = 'PAUSED';
                document.querySelector('#start-screen button').textContent = 'RESUME';
            }
        });

        function startGame() {
            // [ì¶”ê°€] ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ì´ì „ ë­í‚¹ í‘œì‹œìš© ë°ì´í„° ì •ë¦¬
            // [ìˆ˜ì •] í‚¤ê°’ ë³€ê²½ ë° ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸°
            localStorage.removeItem('myBestRecord');
            const myRankList = document.getElementById('my-rank-list');
            if (myRankList) myRankList.style.display = 'none';

            document.getElementById('start-screen').style.display = 'none';
            resetState();
            gameState.isRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function resetState() {
            // 1. [CDSO ì¶”ê°€] ê³¼ê±° ê¸°ë¡ ì¡°íšŒ ë° ë£¨í‚¤ íŒë³„
            const savedRecord = localStorage.getItem('myBestRecord');
            let bestScore = 0;
            if (savedRecord) {
                try { bestScore = JSON.parse(savedRecord).score; } 
                catch (e) { bestScore = 0; }
            }

            // [CDSO ì¶”ê°€] ê´€ë¦¬ì ëª¨ë“œ í”Œë˜ê·¸ (ê¸°ë³¸ê°’ false)
            gameState.isAdminMode = false;
            
            // â–¼â–¼â–¼ [CDSO Patch: ì‹œì¦Œ 2 í•˜ë“œì½”ì–´ ì •ì±… ì ìš©] â–¼â–¼â–¼
            // ê¸°ì¡´: const isRookie = (!savedRecord || bestScore < 5000);
            
            // ë³€ê²½: ê¸°ë¡ì´ 'ë°˜ë“œì‹œ ì¡´ì¬í•˜ê³ ' ê·¸ ì ìˆ˜ê°€ 5000ì  ë¯¸ë§Œì¼ ë•Œë§Œ ë£¨í‚¤ ì¸ì •
            // ì¦‰, ì²˜ìŒ ì ‘ì†í•˜ëŠ” ì‚¬ëŒ(savedRecordê°€ null)ì€ falseê°€ ë˜ì–´ 'ì¼ë°˜ ëª¨ë“œ'ë¡œ ì‹œì‘í•¨
            const isRookie = (savedRecord && bestScore < 5000 && window.isVeteranServer);

            Object.assign(gameState, {
                score: 0, enemies: [], items: [], bullets: [],
                skillMode: 'NORMAL', skillTimer: 0, spawnTimer: 0, itemSpawnTimer: 0,
                lives: 3, isInvincible: false, invincibilityTimer: 0, drones: [],
                isTransformed: false, isLaserMode: false, laserTimer: 0, isLunarMode: false,
                currentStage: 1, stageTimer: 30, boss: null,
                stageClearing: false, stageClearTimer: 0, survivalMode: false,
                bossPhase: 'MINION', bossTimer: 0, bossResurrected: false,
                downgradeFlash: 0, progressDisplay: 0, survivalStartCount: 0,
                spawnDelay: 1.0,
                stageTimerEnded: false, survivalTimer: 0, pendingBoss: null,
                // ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤ ì´ˆê¸°í™”
                ultGauge: 0, autoFireTimer: 0,
                isHomingMode: false, homingTimer: 0,
                rainbowWave: null, dangerWarning: 0, timeBonusDisplay: null,

                // â–¼â–¼â–¼ [CDSO Patch: ì—¬ê¸°ì— ì¶”ê°€í•˜ì„¸ìš”] â–¼â–¼â–¼
                currentStageScore: 0,  // ìŠ¤í…Œì´ì§€ë³„ ì ìˆ˜ ì¹´ìš´í„° ì´ˆê¸°í™”


                // [CDSO ì¶”ê°€] ë°ì´í„° ë¶„ì„ìš© ë³€ìˆ˜ ì´ˆê¸°í™”
                startTime: Date.now(),      // ê²Œì„ ì‹œì‘ ì‹œê°„
                totalItemsSpawned: 0,       // ìƒì„±ëœ ì´ ì•„ì´í…œ ìˆ˜
                itemsCollected: 0,          // íšë“í•œ ì•„ì´í…œ ìˆ˜
                lastHitBy: 'UNKNOWN',       // ë§ˆì§€ë§‰ í”¼ê²© ì›ì¸ (ì‚¬ë§ ì›ì¸)
                deathCoords: { x: 0, y: 0 }, // ì‚¬ë§ ì¢Œí‘œ

                isRookieMode: isRookie, 
                boostActive: false // í˜„ì¬ ë¶€ìŠ¤íŠ¸ê°€ ì ìš© ì¤‘ì¸ì§€ UI í‘œì‹œìš©

            });
            gameState.player.x = 215;
            updateLivesUI();
            // [ìˆ˜ì •] my-rankê°€ ì•„ë‹ˆë¼ my-rank-listë¥¼ ìˆ¨ê²¨ì•¼ ì—ëŸ¬ê°€ ì•ˆ ë‚©ë‹ˆë‹¤!
            const myRankList = document.getElementById('my-rank-list');
            if (myRankList) myRankList.style.display = 'none';
        }


        // [CDSO ì „ëµ ìˆ˜ì •] ì ìˆ˜ íšë“ ë¡œì§ (Rookie Boost vs Infinite Penalty)
        function addScore(amount) {
            let finalAmount = amount;
            
            // [CDSO ì „ëµ ìˆ˜ì •] ìš°ì„ ìˆœìœ„ ë³€ê²½: ì§€ì˜¥ í˜ë„í‹° > ë£¨í‚¤ ë¶€ìŠ¤íŠ¸
            
            // 1. [Absolute Rule] Stage 11(íˆë“  ë£¨íŠ¸) ì§„ì… ì‹œ -> ë¬´ì¡°ê±´ 20%ë§Œ ë°˜ì˜
            if (gameState.currentStage >= 11) {
                // ë£¨í‚¤ ëª¨ë“œì—¬ë„ ìƒê´€ì—†ìŒ. ì§€ì˜¥ì€ ì§€ì˜¥ì„.
                finalAmount = Math.floor(amount * 0.2);
                gameState.boostActive = false; 
            }
            // 2. [Conditional Rule] ë£¨í‚¤ ëª¨ë“œì´ê³  5000ì  ë¯¸ë§Œì¼ ë•Œ -> 3ë°° ì ìš©
            else if (gameState.isRookieMode && gameState.score < 5000) {
                finalAmount = amount * 3;
                gameState.boostActive = true;
            } 
            else {
                gameState.boostActive = false;
            }

            // [CDSO Strategy] ìŠ¤í…Œì´ì§€ë³„ ì°¨ë“± ì œí•œ (Dynamic Cap)
            // Stage 1~9: ê¸°ë³¸ 3,000ì  + ìŠ¤í…Œì´ì§€ë‹¹ 1,000ì  ì¦ê°€ (ì˜ˆ: 1íƒ„ 4000, 9íƒ„ 12000)
            // Stage 10(ë³´ìŠ¤): 20,000ì  (ëŒ€í­ í—ˆìš©)
            // Stage 11(ë¬´í•œ): ì œí•œ ì—†ìŒ (Infinity)

            let stageMaxScore;
            if (gameState.currentStage >= 11) {
                stageMaxScore = Infinity; // ë¬´í•œ ëª¨ë“œëŠ” ì œí•œ í•´ì œ
            } else if (gameState.currentStage === 10) {
                stageMaxScore = 20000;    // ìµœì¢… ë³´ìŠ¤ì „ì€ ë„‰ë„‰í•˜ê²Œ
            } else {
                // ì¼ë°˜ ìŠ¤í…Œì´ì§€ëŠ” ë³´ìˆ˜ì ìœ¼ë¡œ ì¡ìŒ
                stageMaxScore = 3000 + (gameState.currentStage * 1000); 
            }
            
            // í˜„ì¬ ìŠ¤í…Œì´ì§€ì—ì„œ íšë“í•œ ëˆ„ì  ì ìˆ˜ ì¶”ì  í•„ìš” (gameStateì— currentStageScore ë³€ìˆ˜ ì¶”ê°€ ì „ì œ)
            if (gameState.currentStageScore > stageMaxScore) {
                finalAmount = Math.floor(amount * 0.1); // 10%ë§Œ ë°˜ì˜
                
                // UI í”¼ë“œë°± (ì„ íƒì‚¬í•­): ì ìˆ˜ ìƒ‰ìƒì„ íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ 'íš¨ìœ¨ ê°ì†Œ' ì•Œë¦¼
                const scoreEl = document.getElementById('current-score');
                if(scoreEl) scoreEl.style.color = '#888';
            }



            // ì ìˆ˜ ë°˜ì˜
            if (finalAmount > 0) {
                gameState.score += finalAmount;
            }

            // [UI í”¼ë“œë°±] ì ìˆ˜íŒ ìƒ‰ìƒ ìƒíƒœ í‘œì‹œ
            const scoreEl = document.getElementById('current-score');
            if (scoreEl) {
                if (gameState.currentStage >= 11) {
                    scoreEl.style.color = '#f88'; // Hell Color
                    scoreEl.style.textShadow = '0 0 5px #f00';
                } else if (gameState.boostActive) {
                    scoreEl.style.color = '#0f0'; // Boost Color
                    scoreEl.style.textShadow = '0 0 15px #0f0';
                } else {
                    scoreEl.style.color = '#fff'; // Normal
                    scoreEl.style.textShadow = '0 0 10px #fff';
                }
            }

        }




        function spawnEntities(dt) {
            if (gameState.spawnDelay > 0) {
                gameState.spawnDelay -= dt;
                return;
            }

            // [CDSO ì „ëµ] Stage 11 ì´ìƒ: ë¬´í•œ ì„œë°”ì´ë²Œ ë¡œì§
            if (gameState.currentStage >= 11) {
                // 1. ë‚œì´ë„ ì‹¤ì‹œê°„ ìƒìŠ¹ (10ì´ˆë§ˆë‹¤ 10%ì”© ë¹¨ë¼ì§)
                gameState.infiniteDifficulty += dt * 0.01; 
                
                gameState.spawnTimer += dt;
                
                // ìŠ¤í° ì£¼ê¸°: ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ì§§ì•„ì§ (ìµœì†Œ 0.1ì´ˆ)
                const currentSpawnRate = Math.max(0.1, 0.5 / gameState.infiniteDifficulty);

                if (gameState.spawnTimer > currentSpawnRate) {
                    // ëª¨ë“  íƒ€ì… ëœë¤ ë“±ì¥
                    const types = ['NORMAL', 'ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER', 'LASER_ENEMY'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    // ì†ë„: ê¸°ë³¸ ì†ë„ * ë‚œì´ë„ ë°°ìœ¨
                    const speedMult = gameState.infiniteDifficulty * 1.5;

                    gameState.enemies.push({
                        x: Math.random() * (canvas.width - 24), 
                        y: -32, 
                        w: 24, h: 24,
                        speed: (200 + Math.random() * 100) * speedMult, 
                        type: type,
                        amplitude: Math.random() * 2 + 1, 
                        turnRate: 120 * speedMult, // ìœ ë„íƒ„ íšŒì „ë ¥ë„ ì¦ê°€
                        time: 0,
                        // íŠ¹ìˆ˜ ì  ì´ˆê¸°í™” ê°’ë“¤
                        exploded: false, locked: false, fired: false, chargeTimer: 0,
                        phase: 'ENTER', strafeDir: Math.random() < 0.5 ? 1 : -1
                    });
                    gameState.spawnTimer = 0;
                }

                // ì•„ì´í…œ ìŠ¤í° (ê°€ë” ë‚˜ì™€ì•¼ ìƒì¡´ ê°€ëŠ¥)
                gameState.itemSpawnTimer += dt;
                if (gameState.itemSpawnTimer > 10) {
                    const rand = Math.random();
                    // í›„ë°˜ì—” í•˜íŠ¸ê°€ ì ˆì‹¤í•˜ë¯€ë¡œ í•˜íŠ¸ í™•ë¥  ì¡°ê¸ˆ ë†’ì„
                    let itemType = rand < 0.3 ? 'LIFE' : (rand < 0.6 ? 'SHIELD' : 'BLASTER');
                    gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type: itemType });
                    gameState.itemSpawnTimer = 0;
                }
                return; // â˜… ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ (ì•„ë˜ ê¸°ì¡´ ë¡œì§ ì‹¤í–‰ ì•ˆ í•¨)
            }


            const lvl = levels[gameState.currentStage - 1];

            // [CDSO ì „ëµ] ë³´ìŠ¤ì „ ì „ìš© ë¡œì§
            if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) {
                gameState.spawnTimer += dt;

                // ë³´ìŠ¤ ì¢…ë¥˜ë³„ ì«„ëª¹ ì†Œí™˜
                let spawnInterval = 2.5;
                let eliteTypes = [];

                if (gameState.boss.type === 'LUNAR') {
                    spawnInterval = 2.2; eliteTypes = ['HOMING', 'ZIGZAG'];
                } else if (gameState.boss.type === 'SUN') {
                    spawnInterval = 3.0; eliteTypes = ['SHOOTER', 'BOMBER', 'LASER_ENEMY'];
                }

                if (gameState.bossResurrected) spawnInterval *= 0.7;

                if (gameState.spawnTimer > spawnInterval) {
                    const type = eliteTypes[Math.floor(Math.random() * eliteTypes.length)];
                    gameState.enemies.push({
                        x: Math.random() * (canvas.width - 30), y: -35,
                        w: 25, h: 25, speed: 200 + Math.random() * 50, type: type,
                        amplitude: 1, turnRate: 100, time: 0,
                        exploded: false, locked: false, fired: false, chargeTimer: 0,
                        phase: 'ENTER', strafeDir: Math.random() < 0.5 ? 1 : -1
                    });
                    gameState.spawnTimer = 0;
                }

                // ë³´ìŠ¤ì „ ì•„ì´í…œ (í•˜íŠ¸ í¬ì†Œì„± ìœ ì§€: 10%)
                gameState.itemSpawnTimer += dt;
                if (gameState.itemSpawnTimer > 6) {
                    const rand = Math.random();
                    let itemType = rand < 0.5 ? 'BLASTER' : (rand < 0.9 ? 'SHIELD' : 'LIFE');
                    gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type: itemType });

                    gameState.totalItemsSpawned++; // [ì¶”ê°€] ìƒì„± ì¹´ìš´íŠ¸ ì¦ê°€
                    gameState.itemSpawnTimer = 0;
                }
                return;
            }

            if (gameState.stageClearing || gameState.survivalMode) return;

            // ì¼ë°˜ ìŠ¤í…Œì´ì§€ ì  ì†Œí™˜
            gameState.spawnTimer += dt;
            if (gameState.spawnTimer > lvl.spawnRate && lvl.types.length > 0) {
                const type = lvl.types[Math.floor(Math.random() * lvl.types.length)];
                gameState.enemies.push({
                    x: Math.random() * (canvas.width - 24), y: -32, w: 24, h: 24,
                    speed: (200 + Math.random() * 100) * lvl.speedMult, type,
                    amplitude: Math.random() * 2 + 1, turnRate: 120 + Math.random() * 60, time: 0
                });
                gameState.spawnTimer = 0;
            }

            // ì¼ë°˜ ìŠ¤í…Œì´ì§€ ì•„ì´í…œ ì†Œí™˜ (í•˜íŠ¸ í™•ë¥  30% ì ìš©)
            gameState.itemSpawnTimer += dt;
            if (gameState.itemSpawnTimer > 8) {
                const rand = Math.random();
                let type = rand < 0.25 ? 'DRONE' : (rand < 0.5 ? 'SHIELD' : 'BLASTER');

                // ìŠ¤í…Œì´ì§€ 6, 9ì—ì„œ í•˜íŠ¸ ë“±ì¥ í™•ë¥  30%
                if (gameState.currentStage === 6 || gameState.currentStage === 9) {
                    if (Math.random() < 0.3) type = 'LIFE';
                }

                gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type });
                gameState.totalItemsSpawned++; // [ì¶”ê°€] ìƒì„± ì¹´ìš´íŠ¸ ì¦ê°€
                gameState.itemSpawnTimer = 0;
            }
        }



        function spawnBoss(hp, type) {
            const isLunar = type === 'LUNAR';
            const w = isLunar ? 115 : 100;  // ë£¨ë‚˜ 15% í¬ê¸° ì¦ê°€
            const h = isLunar ? 92 : 80;
            gameState.boss = {
                x: canvas.width / 2 - w / 2, y: 50, w, h,
                hp, maxHp: hp, moveDir: 1, shootTimer: 0, type: type || 'LUNAR',
                isSupernova: false, shockwaveTimer: 0
            };
            // gameState.enemies = [];
            gameState.bossTimer = 0;
            gameState.spawnTimer = 0;
        }

        function triggerBigBang() {
            const boss = gameState.boss;
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            for (let i = 0; i < 24; i++) {
                const rad = (i * 15) * Math.PI / 180;
                const speed = 200 + Math.random() * 100;
                gameState.enemies.push({
                    x: cx - 6, y: cy,
                    w: 12, h: 12, speed: 0, type: 'BULLET',
                    vx: Math.cos(rad) * speed, vy: Math.sin(rad) * speed,
                    amplitude: 0, turnRate: 0, time: 0
                });
            }
        }

        function updateBoss(dt) {
            const boss = gameState.boss;
            if (!boss) return;

            gameState.bossTimer += dt;

            // [Patch B] 90ì´ˆ(1ë¶„ 30ì´ˆ) ì´ˆê³¼ ì‹œ ê´‘í­í™” ëª¨ë“œ ë°œë™ (Hard Cap)
            if (gameState.bossTimer > 90) {
                // ê²½ê³  ë©”ì‹œì§€ 1íšŒ ì¶œë ¥ (UX ê³ ë ¤)
                if (!boss.enraged) {
                    boss.enraged = true;
                    document.getElementById('res-title').textContent = "âš  SYSTEM CRITICAL: ENRAGE âš ";
                    // ê´‘í­í™” íš¨ê³¼: ê³µê²© ì†ë„ 5ë°°, ì´ë™ ì†ë„ 3ë°°
                    boss.shootTimer = 100; // ì¦‰ì‹œ ë°œì‚¬ ìœ ë„
                }
                
                // ê°•ì œ ë°ë¯¸ì§€ ë¡œì§ (í”Œë ˆì´ì–´ë¥¼ ì¦‰ì‚¬ì‹œí‚¤ê±°ë‚˜ ë³´ìŠ¤ê°€ ìí­í•˜ê±°ë‚˜)
                // ì—¬ê¸°ì„œëŠ” ë‚œì´ë„ë¥¼ ê·¹ë„ë¡œ ë†’ì—¬ 'ìì—°ìŠ¤ëŸ¬ìš´ ì£½ìŒ' ìœ ë„
                dt *= 5.0; // ì‹œê°„ ê°€ì†
            }



            boss.x += boss.moveDir * 120 * dt;
            if (boss.x <= 0 || boss.x >= canvas.width - boss.w) boss.moveDir *= -1;
            boss.shootTimer += dt;

            if (boss.type === 'LUNAR') {
                // ìœ ì„± ê³µê²© (METEOR)
                if (boss.shootTimer > 1.8) {
                    for (let angle = -30; angle <= 30; angle += 30) {
                        const rad = (90 + angle) * Math.PI / 180;
                        gameState.enemies.push({
                            x: boss.x + boss.w / 2 - 14, y: boss.y + boss.h,
                            w: 28, h: 28, speed: 0, type: 'METEOR',
                            vx: Math.cos(rad) * 180, vy: Math.sin(rad) * 180,
                            amplitude: 0, turnRate: 0, time: 0
                        });
                    }
                    boss.shootTimer = 0;
                }
                // ì›”ê´‘ ì¶©ê²©íŒŒ (3ì´ˆë§ˆë‹¤) + DANGER ê²½ê³ 
                boss.shockwaveTimer += dt;

                // ì¶©ê²©íŒŒ ë°œì‚¬ 0.5ì´ˆ ì „ DANGER ê²½ê³  ì‹œì‘
                if (boss.shockwaveTimer > 2.5 && boss.shockwaveTimer <= 3) {
                    gameState.dangerWarning = 0.5 - (3 - boss.shockwaveTimer);
                }

                if (boss.shockwaveTimer > 3) {
                    const px = gameState.player.x + gameState.player.w / 2;
                    const bx = boss.x + boss.w / 2, by = boss.y + boss.h;
                    const dx = px - bx, dy = gameState.player.y - by;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    gameState.enemies.push({
                        x: bx - 10, y: by,
                        w: 20, h: 20, speed: 0, type: 'SHOCKWAVE',
                        vx: (dx / dist) * 350, vy: (dy / dist) * 350,
                        amplitude: 0, turnRate: 0, time: 0
                    });
                    boss.shockwaveTimer = 0;
                    gameState.dangerWarning = 0;  // ê²½ê³  ì¢…ë£Œ
                }
            } else if (boss.type === 'SUN') {
                // [CDSO ì „ëµ ìˆ˜ì •] ë‚œì´ë„ ëŒ€í­ ìƒí–¥: Spinning Inferno íŒ¨í„´
                // 1. ë°œì‚¬ ì†ë„: 2í˜ì´ì¦ˆ(Supernova)ì—ì„œëŠ” 0.7ì´ˆë§ˆë‹¤ ë‚œì‚¬ (ê¸°ì¡´ 1.5ì´ˆ)
                const fireRate = boss.isSupernova ? 0.7 : 1.6;

                // 2. íƒ„ë§‰ ë°€ë„: 2í˜ì´ì¦ˆì—ì„œëŠ” 24ë°œ (ê¸°ì¡´ 16ë°œ)
                const bulletCount = boss.isSupernova ? 24 : 14;

                if (boss.shootTimer > fireRate) {
                    // 3. íšŒì „ ë¡œì§: ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë°œì‚¬ ê°ë„ê°€ ëŒì•„ê° (ë‚˜ì„ í˜• íŒ¨í„´)
                    // Supernova ìƒíƒœì¼ ë•ŒëŠ” íšŒì „ ì†ë„ 3ë°° ì¦ê°€
                    const spinSpeed = boss.isSupernova ? 150 : 40;
                    const baseAngle = (Date.now() / 1000) * spinSpeed;

                    for (let i = 0; i < bulletCount; i++) {
                        // ê¸°ë³¸ ê°ë„ + íšŒì „ ê°ë„ ì ìš©
                        const angle = baseAngle + (i * (360 / bulletCount));
                        const rad = angle * Math.PI / 180;

                        // 4. ë³€ì¹™ ì†ë„ (Variable Velocity): 
                        // 2í˜ì´ì¦ˆì—ì„œëŠ” ì§ìˆ˜/í™€ìˆ˜ ë²ˆì§¸ íƒ„í™˜ì˜ ì†ë„ë¥¼ ë‹¤ë¥´ê²Œ í•˜ì—¬ 'íƒ„ë§‰ ë²½'ì„ í˜•ì„±
                        let bSpeed = boss.isSupernova ? 240 : 190;
                        if (boss.isSupernova && i % 2 === 0) {
                            bSpeed += 120; // ì§ìˆ˜ íƒ„í™˜ì€ í›¨ì”¬ ë¹ ë¥´ê²Œ ë°œì‚¬ (360) -> ì—‡ë°•ì ìœ ë°œ
                        }

                        gameState.enemies.push({
                            x: boss.x + boss.w / 2 - 6, y: boss.y + boss.h / 2,
                            w: 12, h: 12, speed: 0, type: 'BULLET',
                            vx: Math.cos(rad) * bSpeed,
                            vy: Math.sin(rad) * bSpeed,
                            amplitude: 0, turnRate: 0, time: 0
                        });
                    }
                    boss.shootTimer = 0;
                }
            }

            if (gameState.isLaserMode) {
                const laserL = gameState.player.x + gameState.player.w / 2 - 20;
                const laserR = gameState.player.x + gameState.player.w / 2 + 20;
                if (boss.x + boss.w > laserL && boss.x < laserR) {
                    boss.hp -= dt * 8;
                    addScore(Math.floor(dt * 10));
                }
            }

            for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                if (checkRectCollision(gameState.bullets[bi], boss)) {
                    boss.hp--; gameState.bullets.splice(bi, 1); addScore(5);
                }
            }

            if (boss.hp <= 0) {
                if (boss.type === 'SUN' && !gameState.bossResurrected) {
                    triggerBigBang();
                    boss.hp = boss.maxHp * 0.5;
                    boss.isSupernova = true;
                    gameState.bossResurrected = true;
                } else {
                    // [CDSO ì „ëµ ìˆ˜ì •] ë³´ìŠ¤ ë“±ê¸‰ë³„ ì°¨ë“± ë³´ìƒ ì‹œìŠ¤í…œ (Tiered Scoring)

                    let baseClearScore = 0;
                    let timeBonus = 0;
                    let perfectBonus = 0;
                    let timeLimitS = 0; // Së“±ê¸‰ ê¸°ì¤€ ì‹œê°„
                    let timeLimitA = 0; // Aë“±ê¸‰ ê¸°ì¤€ ì‹œê°„

                    // 1. ë³´ìŠ¤ íƒ€ì…ë³„ ê¸°ì¤€ ì„¤ì • (Configuration)
                    if (boss.type === 'LUNAR') {
                        // [Stage 5] ì¤‘ê°„ ë³´ìŠ¤: íƒ€ì´íŠ¸í•œ ì‹œê°„ ì œí•œ, ì ë‹¹í•œ ë³´ìƒ
                        baseClearScore = 300;
                        timeLimitS = 15; // 25ì´ˆ ì»· (Speed)
                        timeLimitA = 25;

                        if (gameState.bossTimer <= timeLimitS) timeBonus = 300;
                        else if (gameState.bossTimer <= timeLimitA) timeBonus = 200;
                        else timeBonus = 100;

                    } else {
                        // [Stage 10] ìµœì¢… ë³´ìŠ¤: ë„‰ë„‰í•œ ì‹œê°„ ì œí•œ, ì••ë„ì ì¸ ë³´ìƒ
                        baseClearScore = 1000; // ì—”ë”© ë³´ìƒ ìƒí–¥
                        timeLimitS = 30; // 50ì´ˆ ì»· (Endurance)
                        timeLimitA = 50;

                        if (gameState.bossTimer <= timeLimitS) timeBonus = 700; // Legendary
                        else if (gameState.bossTimer <= timeLimitA) timeBonus = 400;
                        else timeBonus = 200;
                    }

                    // 2. ë…¸ë¯¸ìŠ¤ ë³´ë„ˆìŠ¤ (ê³µí†µ ë¡œì§)
                    // ìµœì¢… ë³´ìŠ¤ëŠ” ì–´ë µê¸° ë•Œë¬¸ì— ë…¸ë¯¸ìŠ¤ ê°€ì‚°ì ì„ ë” ë†’ê²Œ ì±…ì •
                    if (gameState.lives >= gameState.maxLives) { // ë§Œí”¼ì¼ ë•Œ
                        perfectBonus = (boss.type === 'SUN') ? 1000 : 500;
                    }

                    // 3. ìµœì¢… í•©ì‚°
                    const totalBonus = baseClearScore + timeBonus + perfectBonus;
                    addScore(totalBonus);

                    // 4. ê²°ê³¼ í‘œì‹œ (UI Feedback)
                    // ë“±ê¸‰ í‘œì‹œ (S, A, B)
                    let rankText = gameState.bossTimer <= timeLimitS ? "RANK S" : (gameState.bossTimer <= timeLimitA ? "RANK A" : "RANK B");

                    // ë³´ë„ˆìŠ¤ ì •ë³´ë¥¼ í™”ë©´ì— ë³´ì—¬ì£¼ê¸° ìœ„í•´ ê°ì²´ì— ì €ì¥
                    gameState.timeBonusDisplay = {
                        amount: totalBonus,
                        text: `${rankText} BONUS`, // í™”ë©´ì— S, A, B ë“±ê¸‰ë„ ê°™ì´ í‘œì‹œ
                        timer: 3.0
                    };

                    // ë£¨ë‚˜ ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ ë£¨ë‚˜ ëª¨ë“œ í™œì„±í™” (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                    if (boss.type === 'LUNAR') {
                        gameState.isLunarMode = true;
                    }
                    triggerStageClear();
                }


                return;
            }

            if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, boss)) {
                gameState.lastHitBy = boss.type + '_BODY'; // [ì¶”ê°€] ë³´ìŠ¤ ëª¸í†µ ì¶©ëŒ ê¸°ë¡
                takeDamage();
            }
        }

        function triggerStageClear() {
            gameState.stageClearing = true;
            gameState.stageClearTimer = 1.0;  // ìŠ¤í…Œì´ì§€ ë¬¸êµ¬ 1ì´ˆ
            gameState.boss = null;
            gameState.survivalMode = false;
            gameState.bossPhase = 'MINION';
            gameState.bossResurrected = false;
            // Phase 3: pendingBoss ë¡œì§ ì œê±° - spawnBoss ì§ì ‘ í˜¸ì¶œ ë°©ì‹ ì‚¬ìš©
        }

        // Phase 5: ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ í†µí•© í•¨ìˆ˜
        function handleStageTransition(dt) {
            const lvl = levels[gameState.currentStage - 1];

            // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì²˜ë¦¬
            if (gameState.stageClearing) {
                gameState.stageClearTimer -= dt;
                if (gameState.stageClearTimer <= 0) {
                    gameState.enemies = [];
                    advanceStage();
                }
                return;
            }

            // ë³´ìŠ¤ ìŠ¤í…Œì´ì§€
            if (lvl.isBoss) {
                if (gameState.bossPhase === 'MINION') {
                    gameState.stageTimer -= dt;
                    if (gameState.stageTimer <= 0) {
                        gameState.bossPhase = 'BOSS';
                        gameState.stageTimerEnded = true;
                        spawnBoss(lvl.bossHP, lvl.bossType);
                    }
                } else if (gameState.bossPhase === 'BOSS') {
                    updateBoss(dt);
                }
                return;
            }

            // ì¼ë°˜ ìŠ¤í…Œì´ì§€
            if (!gameState.stageTimerEnded) {
                gameState.stageTimer -= dt;
                if (gameState.stageTimer <= 0) {
                    gameState.stageTimerEnded = true;
                }
            }

            if (gameState.stageTimerEnded && !gameState.survivalMode && getActiveEnemyCount() === 0) {
                gameState.survivalMode = true;
                gameState.survivalTimer = 0.7;
                gameState.enemies = [];
            }

            if (gameState.survivalMode) {
                gameState.survivalTimer -= dt;
                if (gameState.survivalTimer <= 0) {
                    triggerStageClear();
                }
            }
        }


        function advanceStage() {
            // [CDSO ìˆ˜ì •] ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ ì •ìƒí™”

            // 1. [End Game Check] 10ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì‹œ ë¶„ê¸° ì²˜ë¦¬
            if (gameState.currentStage >= 10) {
                // íŒë‹¨ ê¸°ì¤€ ë°ì´í„°
                const isTopRanker = gameState.score > (gameState.rank3Score || 0);
                const isPerfectCondition = gameState.lives >= 3; 

                // [Scenario A] ë­ì»¤ ë“±ê·¹ (Top 3) -> ëª…ì˜ˆë¡œìš´ ì¡¸ì—…
                if (isTopRanker) {
                    gameComplete(); 
                    return;
                }

                // [Scenario B] ë­í‚¹ ì‹¤íŒ¨ BUT ì™„ë²½í•œ ìƒíƒœ -> íˆë“  ë£¨íŠ¸ ê°œë°©
                if (isPerfectCondition) {
                    console.log("ğŸ”“ Hidden Stage Unlocked");
                    
                    gameState.currentStage = 11;

                    // â–¼â–¼â–¼ [CDSO Patch: ì—¬ê¸°ì—ë„ ë°˜ë“œì‹œ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤!] â–¼â–¼â–¼
                    gameState.currentStageScore = 0;

                    gameState.stageTimer = 99999; 
                    gameState.stageClearing = false;
                    gameState.survivalMode = false;
                    gameState.spawnTimer = 0;
                    gameState.infiniteDifficulty = 1.0; 
                    
                    // UX í”¼ë“œë°±
                    const stageInfo = document.getElementById('stage-info');
                    if(stageInfo) {
                        stageInfo.textContent = "âš  HIDDEN ROUTE: OVERDRIVE âš ";
                        stageInfo.style.color = "#f00";
                        stageInfo.animate([
                            { opacity: 0, transform: 'scale(1.5)' },
                            { opacity: 1, transform: 'scale(1.0)' }
                        ], { duration: 1000, easing: 'ease-out' });
                    }
                    return;
                }

                // [Scenario C] ì¼ë°˜ ì—”ë”©
                gameComplete();
                return;
            }

            // 2. [Normal Progression] 1~9 ìŠ¤í…Œì´ì§€ ì§„í–‰ (ì—¬ê¸°ê°€ else ë¸”ë¡ì´ ë˜ë©´ ì•ˆ ë¨!)
            gameState.currentStage++;

            // â–¼â–¼â–¼ [CDSO Patch: ìˆ˜í™• ì²´ê° ë²•ì¹™ì„ ìœ„í•œ ì´ˆê¸°í™”] â–¼â–¼â–¼
            gameState.currentStageScore = 0;
            


            // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ ì •ë³´ ë¡œë“œ
            const lvl = levels[gameState.currentStage - 1];
            gameState.stageTimer = lvl.duration;
            gameState.stageClearing = false;
            gameState.survivalMode = false;
            gameState.stageTimerEnded = false;
            gameState.survivalTimer = 0;
            gameState.spawnTimer = 0;
            gameState.itemSpawnTimer = 0;

            gameState.bossPhase = 'MINION';
            gameState.bossResurrected = false;
            gameState.progressDisplay = 0;
            gameState.enemies = [];
            gameState.items = [];
            gameState.spawnDelay = 0.8;
            
            console.log(`âœ… Advanced to Stage ${gameState.currentStage}`);
        }




        function showResultScreen(title) {
            const finalScore = Math.round(gameState.score);  // ì†Œìˆ˜ì  ë°˜ì˜¬ë¦¼
            document.getElementById('res-title').textContent = title;
            document.getElementById('res-stage').textContent = gameState.currentStage;
            document.getElementById('res-score').textContent = finalScore;

            const screen = document.getElementById('rank-input-screen');
            screen.style.display = 'flex';
            screen.classList.add('show');

            // ì…ë ¥ì°½ í¬ì»¤ìŠ¤
            setTimeout(() => document.getElementById('initial-input').focus(), 300);
        }

        function gameComplete() {
            gameState.isRunning = false;
            showResultScreen('ğŸ‰ MISSION COMPLETE');
        }

        // ë¬´ì§€ê°œ íŒŒë™ ë°œë™
        function activateRainbowWave() {
            gameState.rainbowWave = { active: true, y: canvas.height };
            gameState.ultGauge = 0;
        }

        // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ìœ ë„íƒ„ìš©)
        function findNearestEnemy() {
            const px = gameState.player.x + gameState.player.w / 2;
            const py = gameState.player.y;
            let nearest = null;
            let minDist = Infinity;

            // [ì¶”ê°€ëœ ë¡œì§] ë³´ìŠ¤ê°€ ì¡´ì¬í•˜ë©´ ì¼ë‹¨ ê°€ì¥ ê°€ê¹Œìš´ ì ìœ¼ë¡œ ì„¤ì •
            if (gameState.boss) {
                const bx = gameState.boss.x + gameState.boss.w / 2;
                const by = gameState.boss.y + gameState.boss.h / 2;
                // í”Œë ˆì´ì–´ì™€ ë³´ìŠ¤ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                const dist = Math.sqrt(Math.pow(px - bx, 2) + Math.pow(py - by, 2));
                minDist = dist;
                nearest = gameState.boss;
            }

            // ê¸°ì¡´ ì ë“¤ê³¼ ê±°ë¦¬ ë¹„êµ (ë³´ìŠ¤ë³´ë‹¤ ë” ê°€ê¹Œìš´ ì ì´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ë³€ê²½)
            for (const en of gameState.enemies) {
                if (en.y < py && en.type !== 'BULLET' && en.type !== 'ENEMY_BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'METEOR') {
                    const ex = en.x + en.w / 2;
                    const ey = en.y + en.h / 2;
                    const dist = Math.sqrt(Math.pow(px - ex, 2) + Math.pow(py - ey, 2));
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = en;
                    }
                }
            }
            return nearest;
        }

        function update(dt) {
            if (!gameState.isRunning) return;
            const lvl = levels[gameState.currentStage - 1];

            // í•„ì‚´ê¸° ê²Œì´ì§€ ì¶©ì „ (dt * 0.05, ì•½ 20ì´ˆì— ì™„ì¶©)
            if (gameState.ultGauge < 1 && !gameState.rainbowWave) {
                gameState.ultGauge = Math.min(1, gameState.ultGauge + dt * 0.05);
            }

            // ìƒì‹œ ìë™ ê³µê²© (0.4ì´ˆë§ˆë‹¤)
            gameState.autoFireTimer += dt;
            if (gameState.autoFireTimer >= 0.4) {
                const cx = gameState.player.x + gameState.player.w / 2;
                const cy = gameState.player.y;

                if (gameState.isHomingMode) {
                    // [CDSO ì „ëµ ìˆ˜ì •] 3ê°ˆë˜ ë©€í‹° ìœ ë„íƒ„ ë°œì‚¬
                    const target = findNearestEnemy(); // ë³´ìŠ¤ ìš°ì„  ì¸ì‹ ê¸°ëŠ¥ í¬í•¨ë¨

                    // ì¢Œ(-0.25), ìš°(+0.25) ë‘ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ (ì•½ 15ë„ ê°ë„)
                    [-0.25, 0.25].forEach(angle => {
                        let vx = 0, vy = -550;

                        // íƒ€ê²Ÿì´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ë°©í–¥ìœ¼ë¡œ ì´ˆê¸° ë²¡í„° ì„¤ì •
                        if (target) {
                            const tx = target.x + target.w / 2;
                            const ty = target.y + target.h / 2;
                            const dx = tx - cx;
                            const dy = ty - cy;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                            // ê¸°ë³¸ íƒ€ê²Ÿ ë°©í–¥ ë²¡í„°
                            let dirX = dx / dist;
                            let dirY = dy / dist;

                            // ë¶€ì±„ê¼´ë¡œ ë²Œë¦¬ê¸° (íšŒì „ ë³€í™˜ í–‰ë ¬ ì ìš©)
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            vx = (dirX * cos - dirY * sin) * 550;
                            vy = (dirX * sin + dirY * cos) * 550;
                        } else {
                            // íƒ€ê²Ÿ ì—†ì„ ë• ê·¸ëƒ¥ ë¶€ì±„ê¼´ë¡œ ë‚˜ê°
                            vx = Math.sin(angle) * 550;
                            vy = -Math.cos(angle) * 550;
                        }

                        gameState.bullets.push({
                            x: cx - 5, y: cy, w: 10, h: 15, speed: 550,
                            isHoming: true,
                            target: target, // [ì¤‘ìš”] íƒ€ê²Ÿ ê°ì²´ ìì²´ë¥¼ ì‹¬ìŒ (ì‹¤ì‹œê°„ ì¶”ì ìš©)
                            vx: vx, vy: vy,
                            turnRate: 8.0 // íšŒì „ ì†ë„ (ë†’ì„ìˆ˜ë¡ ë” ì˜ êº¾ìŒ)
                        });
                    });

                } else {
                    // ì¼ë°˜ ì§ì„  ë°œì‚¬
                    gameState.bullets.push({ x: cx - 5, y: cy, w: 10, h: 15, speed: 550 });
                }
                gameState.autoFireTimer = 0;
            }

            // ìœ ë„íƒ„ ëª¨ë“œ íƒ€ì´ë¨¸
            if (gameState.isHomingMode) {
                gameState.homingTimer -= dt;
                if (gameState.homingTimer <= 0) {
                    gameState.isHomingMode = false;
                }
            }

            // ë¬´ì§€ê°œ íŒŒë™ ì²˜ë¦¬
            if (gameState.rainbowWave) {
                gameState.rainbowWave.y -= 500 * dt;  // ì´ˆë‹¹ 500px ìƒìŠ¹

                // íŒŒë™ë³´ë‹¤ ì•„ë˜ ìˆëŠ” ëª¨ë“  ì  ì œê±°
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    if (en.y + en.h > gameState.rainbowWave.y) {
                        addScore(getEnemyScore(en.type) * 20);  // ë³´ë„ˆìŠ¤ ì ìˆ˜
                        gameState.enemies.splice(i, 1);
                    }
                }

                // íŒŒë™ì´ í™”ë©´ ìœ„ë¡œ ë‚˜ê°€ë©´ ì¢…ë£Œ
                if (gameState.rainbowWave.y < -50) {
                    gameState.rainbowWave = null;
                }
            }

            // í˜„ì¬ ì ìˆ˜ UI ì—…ë°ì´íŠ¸
            document.getElementById('current-score').textContent = Math.round(gameState.score);

            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= dt;
                if (gameState.invincibilityTimer <= 0) gameState.isInvincible = false;
            }

            if (gameState.downgradeFlash > 0) gameState.downgradeFlash -= dt;

            // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ íƒ€ì´ë¨¸
            if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                gameState.timeBonusDisplay.timer -= dt;
                if (gameState.timeBonusDisplay.timer <= 0) {
                    gameState.timeBonusDisplay = null;
                }
            }

            if (gameState.isLaserMode) {
                gameState.laserTimer -= dt;
                if (gameState.laserTimer <= 0) gameState.isLaserMode = false;
            }

            // Phase 5: ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ í†µí•©
            handleStageTransition(dt);

            // í”Œë ˆì´ì–´ ì´ë™ (í‚¤ë³´ë“œ ë° ë²„íŠ¼ ëª¨ë“œ)
            if ((gameState.keys['ArrowLeft'] || gameState.keys['a']) && gameState.player.x > 0)
                gameState.player.x -= gameState.player.speed * dt;
            if ((gameState.keys['ArrowRight'] || gameState.keys['d']) && gameState.player.x < canvas.width - gameState.player.w)
                gameState.player.x += gameState.player.speed * dt;

            // [ìˆ˜ì •] ëª¨ë°”ì¼ í„°ì¹˜ ë¶€ë“œëŸ¬ìš´ ì¶”ì  (TRACKING ëª¨ë“œì¼ ë•Œë§Œ ì‹¤í–‰)
            // [CDSO ìˆ˜ì •] ëª¨ë°”ì¼ í„°ì¹˜ ê³ ì† ì¶”ì  ì‹œìŠ¤í…œ
            if (controlMode === 'TRACKING' && gameState.touchTarget !== null) {
                const target = Math.max(0, Math.min(canvas.width - gameState.player.w, gameState.touchTarget));
                const diff = target - gameState.player.x;

                // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë–¨ë¦¼ ë°©ì§€
                if (Math.abs(diff) > 2) {
                    // [í•µì‹¬ ë³€ê²½] ì¶”ì  ëª¨ë“œì¼ ë•Œë§Œ ì†ë„ë¥¼ 3.0ë°°(1200)ë¡œ ì¦í­ì‹œí‚´
                    // * ìˆ«ìê°€ í´ìˆ˜ë¡ ì†ê°€ë½ì— ë” "ì°©" ë‹¬ë¼ë¶™ìŠµë‹ˆë‹¤. (ì¶”ì²œ: 2.5 ~ 4.0)
                    const trackingSpeed = gameState.player.speed * 3.0; 
                    
                    gameState.player.x += Math.sign(diff) * trackingSpeed * dt;
                } else {
                    gameState.player.x = target;
                }
            }

            const cx = gameState.player.x + gameState.player.w / 2;
            const cy = gameState.player.y;

            // ìŠ¤í‚¬ ëª¨ë“œ ì²˜ë¦¬
            if (gameState.skillTimer > 0) {
                gameState.skillTimer -= dt;
                document.getElementById('skill-display').textContent = `${gameState.skillMode}: ${gameState.skillTimer.toFixed(1)}s`;
            } else {
                gameState.skillMode = 'NORMAL';
                // ìœ ë„íƒ„ ëª¨ë“œ, ë ˆì´ì € ëª¨ë“œ, ë£¨ë‚˜ ëª¨ë“œ í‘œì‹œ
                let displayText = '';
                if (gameState.isHomingMode) displayText = `HOMING: ${gameState.homingTimer.toFixed(1)}s`;
                else if (gameState.isLaserMode) displayText = `LASER: ${gameState.laserTimer.toFixed(1)}s`;
                else if (gameState.isLunarMode) displayText = 'LUNAR MODE';
                document.getElementById('skill-display').textContent = displayText;
            }

            // í™©ê¸ˆ ê¸°ì²´ 3ê°ˆë˜ ê³µê²©
            if (gameState.isTransformed && !gameState.isLaserMode && Math.random() < 0.06) {
                [-15, 0, 15].forEach(ox => gameState.bullets.push({ x: cx + ox - 4, y: cy - 10, w: 8, h: 18, speed: 620 }));
            }

            updateDrones(dt);

            // ë ˆì´ì € ëª¨ë“œ ì  ì²˜ë¦¬ (SHOCKWAVE, METEORëŠ” ìƒì‡„ ë¶ˆê°€)
            if (gameState.isLaserMode) {
                const laserL = cx - 20, laserR = cx + 20;
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    if (en.type !== 'BULLET' && en.type !== 'METEOR' && en.type !== 'SHOCKWAVE' && en.x + en.w > laserL && en.x < laserR && en.y < cy) {
                        gameState.enemies.splice(i, 1);
                        gameState.score += 3;
                    }
                }
            }

            // ì  ì²˜ë¦¬ ë£¨í”„
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const en = gameState.enemies[i];

                if (en.type === 'BULLET' || en.type === 'SHOCKWAVE' || en.type === 'METEOR' || en.type === 'ENEMY_BULLET') {
                    en.x += (en.vx || 0) * dt;
                    en.y += (en.vy || 0) * dt;
                } else if (en.type === 'MINION') {
                    en.y += en.speed * dt;
                    en.time += dt * 3;
                    en.x += Math.sin(en.time) * 1.5;
                } else if (en.type === 'SHOOTER') {
                    // SHOOTER: ìƒë‹¨ ì§„ì… â†’ ì¢Œìš° ì´ë™í•˜ë©° ì—°ì† ë°œì‚¬ â†’ í•˜ê°• í‡´ì¥
                    en.phase = en.phase || 'ENTER';      // ENTER â†’ STRAFE â†’ EXIT
                    en.strafeDir = en.strafeDir || 1;    // ì¢Œìš° ì´ë™ ë°©í–¥
                    en.shotsFired = en.shotsFired || 0;  // ë°œì‚¬í•œ ì´ì•Œ ìˆ˜
                    en.setsFired = en.setsFired || 0;    // ë°œì‚¬í•œ ì„¸íŠ¸ ìˆ˜
                    en.shootTimer = en.shootTimer || 0;

                    if (en.phase === 'ENTER') {
                        // ìƒë‹¨(y=80)ê¹Œì§€ ì§„ì…
                        en.y += en.speed * dt * 0.8;
                        if (en.y >= 80) {
                            en.phase = 'STRAFE';
                            en.y = 80;
                        }
                    } else if (en.phase === 'STRAFE') {
                        // ì¢Œìš° ì´ë™í•˜ë©° 0.1ì´ˆ ê°„ê²© 5ë°œ ì—°ì† ë°œì‚¬ (ë‚œì´ë„ í•˜í–¥)
                        en.x += en.strafeDir * 200 * dt;
                        if (en.x <= 20) en.strafeDir = 1;
                        if (en.x >= canvas.width - en.w - 20) en.strafeDir = -1;

                        en.shootTimer += dt;
                        if (en.shootTimer >= 0.1 && en.shotsFired < 5) {
                            gameState.enemies.push({
                                x: en.x + en.w / 2 - 5, y: en.y + en.h,
                                w: 10, h: 10, speed: 0, type: 'ENEMY_BULLET',
                                vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                            });
                            en.shotsFired++;
                            en.shootTimer = 0;
                        }

                        // 5ë°œ ë°œì‚¬ í›„ ì„¸íŠ¸ ì™„ë£Œ
                        if (en.shotsFired >= 5) {
                            en.setsFired++;
                            en.shotsFired = 0;
                            en.shootTimer = -0.5;  // 0.5ì´ˆ ì¿¨ë‹¤ìš´

                            // 3ì„¸íŠ¸ ì™„ë£Œ ì‹œ í‡´ì¥
                            if (en.setsFired >= 3) {
                                en.phase = 'EXIT';
                            }
                        }
                    } else if (en.phase === 'EXIT') {
                        // ë¹ ë¥´ê²Œ í•˜ê°•í•˜ë©° í‡´ì¥
                        en.y += en.speed * dt * 2.5;
                    }
                } else if (en.type === 'BOMBER') {
                    // BOMBER: í™”ë©´ ì¤‘ê°„ì—ì„œ í­ë°œí•˜ë©° 8ë°©í–¥ íƒ„í™˜
                    en.y += en.speed * dt * 0.6;
                    if (en.y > 200 && !en.exploded) {
                        en.exploded = true;
                        for (let a = 0; a < 8; a++) {
                            const rad = (a * 45) * Math.PI / 180;
                            gameState.enemies.push({
                                x: en.x + en.w / 2 - 6, y: en.y + en.h / 2 - 6,
                                w: 12, h: 12, speed: 0, type: 'ENEMY_BULLET',
                                vx: Math.cos(rad) * 200, vy: Math.sin(rad) * 200,
                                amplitude: 0, turnRate: 0, time: 0
                            });
                        }
                        gameState.enemies.splice(i, 1);
                        continue;
                    }
                } else if (en.type === 'LASER_ENEMY') {
                    // LASER_ENEMY: ì •ì§€ í›„ ìˆ˜ì§ ë ˆì´ì €
                    if (!en.locked) {
                        en.y += en.speed * dt * 0.5;
                        if (en.y > 80) {
                            en.locked = true;
                            en.chargeTimer = 0;
                        }
                    } else {
                        en.chargeTimer = (en.chargeTimer || 0) + dt;
                        if (en.chargeTimer > 1.0 && !en.fired) {
                            en.fired = true;
                            // ìˆ˜ì§ ë ˆì´ì € íƒ„í™˜ ë°œì‚¬
                            for (let ly = en.y + en.h; ly < canvas.height; ly += 30) {
                                gameState.enemies.push({
                                    x: en.x + en.w / 2 - 8, y: ly,
                                    w: 16, h: 25, speed: 0, type: 'ENEMY_BULLET',
                                    vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                                });
                            }
                        }
                        if (en.chargeTimer > 1.5) {
                            gameState.enemies.splice(i, 1);
                            continue;
                        }
                    }
                } else {
                    en.y += en.speed * dt;
                    if (en.type === 'ZIGZAG') { en.time += dt * 5; en.x += Math.sin(en.time) * en.amplitude; }
                    if (en.type === 'HOMING') { en.x += Math.sign(gameState.player.x + 10 - en.x - 15) * en.turnRate * dt; }
                }

                en.x = Math.max(-20, Math.min(canvas.width + 20, en.x));

                if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, en)) {
                    gameState.enemies.splice(i, 1);
                    if (gameState.isLunarMode) { gameState.isLunarMode = false; }
                    else {
                        gameState.lastHitBy = en.type; // [ì¶”ê°€] ì‚¬ë§ ì›ì¸ ê¸°ë¡ (ì˜ˆ: 'ZIGZAG','ENEMY_BULLET')
                        takeDamage();
                    }
                    continue;
                }
                // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•í™” - í™”ë©´ ë°– ì  ì¦‰ì‹œ ì œê±°
                if (en.y > canvas.height + 50 || en.y < -100 || en.x < -80 || en.x > canvas.width + 80) {
                    gameState.enemies.splice(i, 1);
                    if (en.type !== 'BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'ENEMY_BULLET' && en.type !== 'METEOR') {
                        addScore(getEnemyScore(en.type));
                    }
                }
            }

            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const it = gameState.items[i];
                it.y += it.speed * dt;
                if (checkRectCollision(gameState.player, it)) {
                    gameState.itemsCollected++; // [ì¶”ê°€] íšë“ ì¹´ìš´íŠ¸ ì¦ê°€

                    if (it.type === 'DRONE') {
                        if (!gameState.isTransformed) {
                            gameState.drones.push({ offsetX: (gameState.drones.length === 0 ? -1 : 1) * 35, shootTimer: 0 });
                            if (gameState.drones.length >= 3) {
                                gameState.isTransformed = true;
                                gameState.drones = [];
                            }
                        }


                    } else if (it.type === 'LIFE') {
                        // [CDSO ì¶”ê°€] í•˜íŠ¸ íšë“ ì‹œ ìƒëª…ë ¥ íšŒë³µ
                        if (gameState.lives < gameState.maxLives) {
                            gameState.lives++;
                            updateLivesUI(); // í•˜íŠ¸ UI ì¦‰ì‹œ ê°±ì‹ 
                            // íšë“ ë©”ì‹œì§€ (ì„ íƒ ì‚¬í•­)
                            gameState.skillMode = 'HEALED';
                            gameState.skillTimer = 2.0;
                        } else {
                            // ì´ë¯¸ í’€í”¼ë¼ë©´ ë³´ë„ˆìŠ¤ ì ìˆ˜
                            // gameState.score += 400;
                            addScore(400);
                        }



                    } else if (it.type === 'BLASTER') {
                        // BLASTER â†’ ìœ ë„íƒ„ ëª¨ë“œë¡œ ë³€ê²½ (7ì´ˆ)
                        if (gameState.isTransformed) {
                            gameState.isLaserMode = true;
                            gameState.laserTimer = 3.0;
                        } else {
                            gameState.isHomingMode = true;
                            gameState.homingTimer = 7.0;
                        }
                    } else if (it.type === 'LUNAR_ITEM') {
                        gameState.isLunarMode = true;
                    } else {
                        gameState.skillMode = it.type;
                        gameState.skillTimer = 5.0;
                    }
                    gameState.items.splice(i, 1);
                }
                if (it.y > canvas.height) gameState.items.splice(i, 1);
            }

            // ë£¨ë‚˜ ê°€ë””ì–¸ ê³µì „ ë° ì¶©ëŒ ì²˜ë¦¬
            if (gameState.isLunarMode) {
                gameState.lunarAngle += dt * 360;  // íšŒì „ ì†ë„
                const rad = gameState.lunarAngle * Math.PI / 180;
                const guardianX = cx + Math.cos(rad) * 40 - 10;
                const guardianY = cy - 15 + Math.sin(rad) * 40 - 10;
                const guardian = { x: guardianX, y: guardianY, w: 20, h: 20 };

                // ê°€ë””ì–¸ê³¼ ì  ì¶©ëŒ ì²˜ë¦¬
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    if (checkRectCollision(guardian, gameState.enemies[i])) {
                        // [CDSO ìˆ˜ì •] ì ë§Œ ì œê±°í•˜ê³  ë£¨ë‚˜ ëª¨ë“œëŠ” ìœ ì§€ (ê³µê²©í˜• ë¹„íŠ¸)
                        gameState.enemies.splice(i, 1);
                        // gameState.score += 3;
                        addScore(30); // 30ì ìœ¼ë¡œ ìƒí–¥

                        // ì‹œê°ì  íƒ€ê²©ê° ì¶”ê°€ (ì„ íƒ ì‚¬í•­)
                        // createExplosion(guardianX, guardianY); 

                        break;
                    }
                }
            }

            for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                const b = gameState.bullets[bi];

                if (b.isLunar) {
                    b.x += (b.vx || 0) * dt;
                    b.y += (b.vy || 0) * dt;
                } else if (b.isHoming) {
                    // â˜… ì§€ëŠ¥í˜• ì¶”ì  ë¡œì§ ì‹œì‘ â˜…

                    // íƒ€ê²Ÿì´ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸
                    const targetAlive = b.target && (gameState.enemies.includes(b.target) || b.target === gameState.boss) && (b.target.hp === undefined || b.target.hp > 0);

                    if (b.target && targetAlive) {
                        // 1. í˜„ì¬ ë‚´ ìœ„ì¹˜ì™€ íƒ€ê²Ÿ ìœ„ì¹˜ íŒŒì•…
                        const tx = b.target.x + b.target.w / 2;
                        const ty = b.target.y + b.target.h / 2;
                        const bx = b.x + b.w / 2;
                        const by = b.y + b.h / 2;

                        // 2. ëª©í‘œ ë°©í–¥ ê³„ì‚°
                        const dx = tx - bx;
                        const dy = ty - by;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const targetDirX = dx / dist;
                        const targetDirY = dy / dist;

                        // 3. í˜„ì¬ ì´ë™ ë°©í–¥ ê³„ì‚°
                        const currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                        const currentDirX = b.vx / currentSpeed;
                        const currentDirY = b.vy / currentSpeed;

                        // 4. ë°©í–¥ êº¾ê¸° (turnRateë§Œí¼ ë¶€ë“œëŸ½ê²Œ íšŒì „)
                        const turn = (b.turnRate || 5.0) * dt;
                        let newDirX = currentDirX + (targetDirX - currentDirX) * turn;
                        let newDirY = currentDirY + (targetDirY - currentDirY) * turn;

                        // 5. ì†ë„ ì ìš©
                        const newLen = Math.sqrt(newDirX * newDirX + newDirY * newDirY);
                        b.vx = (newDirX / newLen) * b.speed;
                        b.vy = (newDirY / newLen) * b.speed;
                    }

                    // ê³„ì‚°ëœ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;

                } else {
                    b.y -= b.speed * dt;
                }


                if (b.y < -20 || b.y > canvas.height + 20 || b.x < -20 || b.x > canvas.width + 20) {
                    gameState.bullets.splice(bi, 1); continue;
                }
                for (let ei = gameState.enemies.length - 1; ei >= 0; ei--) {
                    const en = gameState.enemies[ei];
                    // SHOCKWAVE, METEORëŠ” ìƒì‡„ ë¶ˆê°€
                    if (en.type === 'SHOCKWAVE' || en.type === 'METEOR') continue;
                    if (checkRectCollision(b, en)) {
                        gameState.enemies.splice(ei, 1); 
                        gameState.bullets.splice(bi, 1);

                        // [Patch A-2] ì ìˆ˜ê°€ 0ë³´ë‹¤ í´ ë•Œë§Œ addScore í˜¸ì¶œ (ë¶ˆí•„ìš”í•œ ì—°ì‚° ë°©ì§€)
                        const unitScore = getEnemyScore(en.type);
                        if (unitScore > 0) {
                            addScore(unitScore * 10);
                        }


                        break;
                    }
                }
            }

            let targetProgress = 0;
            if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) {
                targetProgress = 1 - (gameState.boss.hp / gameState.boss.maxHp);
            } else if (gameState.survivalMode) {
                targetProgress = 1 - (gameState.enemies.length / gameState.survivalStartCount);
            } else {
                targetProgress = (30 - gameState.stageTimer) / 30;
            }
            gameState.progressDisplay += (targetProgress - gameState.progressDisplay) * dt * 5;



            // ... (ê¸°ì¡´ ì½”ë“œ)

            // [CDSO ìˆ˜ì •] UI í‘œì‹œ
            let stageText = '';
            if (gameState.currentStage >= 11) {
                stageText = `STAGE âˆ | OVERDRIVE x${gameState.infiniteDifficulty.toFixed(2)}`;
            } else {
                // ê¸°ì¡´ ë¡œì§
                let stageDisplay = lvl.isBoss
                    ? (gameState.bossPhase === 'BOSS' ? 'BOSS!' : (gameState.bossPhase === 'SURVIVAL' ? 'SURVIVE!' : ''))
                    : (gameState.survivalMode ? 'SURVIVE!' : '');
                stageText = `STAGE ${gameState.currentStage}${stageDisplay ? ' | ' + stageDisplay : ''}`;
            }
            
            document.getElementById('stage-info').textContent = stageText;
        
        }

        function checkRectCollision(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
        }

        function drawProgressBar() {
            const lvl = levels[gameState.currentStage - 1];
            const barWidth = canvas.width * 0.8;
            const barHeight = 8;  // ë” ë‘ê»ê²Œ
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 16;

            // ë°°ê²½
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // í•„ì‚´ê¸° ê²Œì´ì§€ í‘œì‹œ
            const ultProgress = Math.min(gameState.ultGauge, 1);

            if (ultProgress >= 1) {
                // ì™„ì¶© ì‹œ ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜ + ê¹œë¹¡ì„
                const grad = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                const offset = (Date.now() / 20) % 360;
                for (let i = 0; i <= 6; i++) {
                    const hue = (offset + i * 60) % 360;
                    grad.addColorStop(i / 6, `hsl(${hue}, 100%, 60%)`);
                }
                const pulse = 0.7 + Math.sin(Date.now() / 100) * 0.3;
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = grad;
            } else {
                // ì¶©ì „ ì¤‘: ë³´ë¼ìƒ‰ ê²Œì´ì§€
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#a0f';
                ctx.fillStyle = '#c4f';
            }

            ctx.fillRect(barX, barY, barWidth * ultProgress, barHeight);

            // ULT í…ìŠ¤íŠ¸ í‘œì‹œ
            ctx.shadowBlur = 0;
            ctx.fillStyle = ultProgress >= 1 ? '#fff' : '#aaa';
            ctx.font = 'bold 10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(ultProgress >= 1 ? 'ğŸŒˆ PRESS SPACE ğŸŒˆ' : `ULT: ${Math.floor(ultProgress * 100)}%`, canvas.width / 2, barY - 4);

            ctx.shadowBlur = 0;
        }

        function drawGiftBox(it) {
            const x = it.x, y = it.y, w = it.w, h = it.h;

            // [CDSO ìˆ˜ì •] LIFE ì•„ì´í…œ: í•˜íŠ¸ ë Œë”ë§
            if (it.type === 'LIFE') {
                const cx = x + w / 2;
                const cy = y + h / 2;
                const pulse = 1 + Math.sin(Date.now() / 150) * 0.15;

                ctx.save();
                ctx.translate(cx, cy);
                // [CDSO ìˆ˜ì •] í•˜íŠ¸ í¬ê¸° 2.3ë°° í™•ëŒ€ (pulse * 2.5)
                ctx.scale(pulse * 2.3, pulse * 2.3);

                ctx.shadowBlur = 25; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.bezierCurveTo(5, -12, 12, -5, 0, 8);
                ctx.bezierCurveTo(-12, -5, -5, -12, 0, -5);
                ctx.fill();

                ctx.shadowBlur = 0; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-3, -3, 2, 0, Math.PI * 2); ctx.fill();

                ctx.restore();
                return;
            }

            // [ë³µêµ¬ë¨] LUNAR_ITEM ì²´í¬ ì¡°ê±´ë¬¸ì´ ë¹ ì ¸ìˆì—ˆìŒ!
            if (it.type === 'LUNAR_ITEM') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath();
                ctx.arc(x + w / 2, y + h / 2, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(x + w / 2 + 6, y + h / 2 - 4, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // ì¼ë°˜ ì•„ì´í…œ ë°•ìŠ¤
            const boxColor = it.type === 'DRONE' ? '#0ff' : (it.type === 'SHIELD' ? '#0f0' : '#f0f');
            ctx.shadowBlur = 12; ctx.shadowColor = boxColor;
            ctx.fillStyle = boxColor; ctx.fillRect(x + 2, y + 6, w - 4, h - 6);
            ctx.fillStyle = '#fff'; ctx.fillRect(x + w / 2 - 2, y + 6, 4, h - 6); ctx.fillRect(x + 2, y + h / 2 + 2, w - 4, 4);
            ctx.fillStyle = boxColor; ctx.fillRect(x, y + 4, w, 6);
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(x + w / 2 - 5, y + 4, 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + w / 2 + 5, y + 4, 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + w / 2, y + 2, 3, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }



        function drawAlien(en, stage) {
            const cx = en.x + en.w / 2, cy = en.y + en.h / 2;
            const isCold = stage <= 5;

            // ENEMY_BULLET ë Œë”ë§
            if (en.type === 'ENEMY_BULLET') {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f44';
                ctx.fillStyle = '#f66';
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // SHOOTER ë Œë”ë§ (ë¶‰ì€ ì‚¼ê°í˜•)
            if (en.type === 'SHOOTER') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f44';
                ctx.fillStyle = '#f66';
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy + 15);
                ctx.lineTo(cx - 12, cy - 10);
                ctx.lineTo(cx + 12, cy - 10);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
                // í¬ì‹  í‘œì‹œ
                ctx.fillRect(cx - 3, cy + 12, 6, 8);
                ctx.shadowBlur = 0;
                return;
            }

            // BOMBER ë Œë”ë§ (ì£¼í™© ì›)
            if (en.type === 'BOMBER') {
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.15;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#f80';
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(cx, cy, 14 * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // LASER_ENEMY ë Œë”ë§ (ê¸°ì¡´: ë³´ë¼ìƒ‰ ì‚¬ê°í˜• -> ë³€ê²½: ì˜¤ì§•ì–´)
            if (en.type === 'LASER_ENEMY') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#a0f';
                ctx.fillStyle = '#c4f';
                
                // ì˜¤ì§•ì–´ ê·¸ë¦¬ê¸° ë¡œì§ (Squid Rendering)
                const squidHeadR = en.w / 2;     // ë¨¸ë¦¬ ë°˜ì§€ë¦„
                const legLen = en.h * 0.5;       // ë‹¤ë¦¬ ê¸¸ì´
                
                // 1. ë¨¸ë¦¬ (ë°˜ì› + ì§ì‚¬ê°í˜•)
                ctx.beginPath();
                ctx.arc(cx, en.y + squidHeadR, squidHeadR, Math.PI, 0); // ë‘¥ê·¼ ë¨¸ë¦¬ ìœ„ìª½
                ctx.lineTo(en.x + en.w, en.y + en.h - legLen);          // ì˜¤ë¥¸ìª½ ëª¸í†µ
                ctx.lineTo(en.x, en.y + en.h - legLen);                 // ì™¼ìª½ ëª¸í†µ
                ctx.closePath();
                ctx.fill();

                // 2. ë‹¤ë¦¬ (ê¾¸ë¶ˆê¾¸ë¶ˆí•œ ì´‰ìˆ˜ 4ê°œ)
                ctx.strokeStyle = '#c4f';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                // ë‹¤ë¦¬ê°€ ì›€ì§ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ (Squid Wiggle)
                const wiggle = Math.sin(Date.now() / 100) * 3; 

                for(let i=0; i<4; i++) {
                    const legX = en.x + (en.w / 4) * i + (en.w/8);
                    const legStartY = en.y + en.h - legLen;
                    
                    ctx.beginPath();
                    ctx.moveTo(legX, legStartY);
                    // ë² ì§€ì–´ ê³¡ì„ ìœ¼ë¡œ ë‹¤ë¦¬ í‘œí˜„
                    ctx.bezierCurveTo(
                        legX + wiggle, legStartY + legLen/2, 
                        legX - wiggle, legStartY + legLen, 
                        legX, legStartY + legLen
                    );
                    ctx.stroke();
                }

                // 3. ëˆˆ (êµ¬ë¶„ì„ ìœ„í•´ í°ìƒ‰ ì¶”ê°€)
                ctx.fillStyle = '#fff';
                const eyeY = en.y + squidHeadR + 2;
                ctx.beginPath(); ctx.arc(cx - 5, eyeY, 3, 0, Math.PI*2); ctx.fill(); // ì™¼ìª½ ëˆˆ
                ctx.beginPath(); ctx.arc(cx + 5, eyeY, 3, 0, Math.PI*2); ctx.fill(); // ì˜¤ë¥¸ìª½ ëˆˆ


                // (ê¸°ì¡´ ì°¨ì§• ë¡œì§ ìœ ì§€)
                if (en.locked && !en.fired) {
                    const chargeProgress = Math.min((en.chargeTimer || 0) / 1.0, 1);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(en.x, en.y + en.h, en.w, 3);
                    ctx.fillStyle = '#f0f';
                    ctx.fillRect(en.x, en.y + en.h, en.w * chargeProgress, 3);
                    
                    // ì°¨ì§• ì¤‘ì´ë©´ ëˆˆì´ ë¹¨ê°œì§ (Angry Mode)
                    ctx.fillStyle = '#f00';
                    ctx.beginPath(); ctx.arc(cx - 5, eyeY, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx + 5, eyeY, 2, 0, Math.PI*2); ctx.fill();
                }
                ctx.shadowBlur = 0;
                return; // ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ
            }




            ctx.shadowBlur = 12;
            ctx.shadowColor = isCold ? '#8ef' : '#f80';
            ctx.fillStyle = isCold ? '#aef' : '#f64';
            ctx.strokeStyle = isCold ? '#0ff' : '#f40';
            ctx.lineWidth = 2;

            ctx.beginPath();
            if (en.type === 'MINION') {
                ctx.shadowColor = '#f0f';
                ctx.fillStyle = '#f0f';
                ctx.fillRect(en.x + 4, en.y + 4, en.w - 8, en.h - 8);
                return;
            } else if (isCold) {
                if (en.type === 'HOMING') {
                    const rot = Date.now() / 200;
                    for (let i = 0; i < 6; i++) {
                        const a = rot + i * Math.PI / 3;
                        const px = cx + Math.cos(a) * 14;
                        const py = cy + Math.sin(a) * 14;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else if (en.type === 'ZIGZAG') {
                    for (let i = 0; i < 8; i++) {
                        const r = i % 2 === 0 ? 15 : 7;
                        const a = i * Math.PI / 4;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else {
                    ctx.moveTo(cx, cy - 14);
                    ctx.lineTo(cx + 11, cy);
                    ctx.lineTo(cx, cy + 14);
                    ctx.lineTo(cx - 11, cy);
                }
            } else {
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.12;
                if (en.type === 'HOMING') {
                    const rot = Date.now() / 150;
                    for (let i = 0; i < 10; i++) {
                        const r = i % 2 === 0 ? 16 * pulse : 8;
                        const a = rot + i * Math.PI / 5;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else if (en.type === 'ZIGZAG') {
                    for (let i = 0; i < 6; i++) {
                        const r = i % 2 === 0 ? 15 * pulse : 6;
                        const a = i * Math.PI / 3 - Math.PI / 2;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else {
                    ctx.moveTo(cx, cy + 14 * pulse);
                    ctx.lineTo(cx - 13, cy - 9);
                    ctx.lineTo(cx, cy - 4);
                    ctx.lineTo(cx + 13, cy - 9);
                }
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }

        function drawLunarBoss(boss) {
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            ctx.shadowBlur = 40; ctx.shadowColor = '#88f';
            ctx.fillStyle = '#aaf';
            ctx.beginPath(); ctx.arc(cx, cy, 45, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#669';
            [[20, -12, 9], [35, 15, 7], [-15, 8, 8], [-25, -5, 5]].forEach(([ox, oy, r]) => {
                ctx.beginPath(); ctx.arc(cx + ox, cy + oy, r, 0, Math.PI * 2); ctx.fill();
            });
            ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
            ctx.fillStyle = '#4af'; ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText('LUNAR', cx, boss.y - 7);
        }

        function drawSunBoss(boss) {
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            ctx.shadowBlur = boss.isSupernova ? 80 : 60;
            ctx.shadowColor = boss.isSupernova ? '#f0f' : '#f80';
            const grad = ctx.createRadialGradient(cx, cy, 15, cx, cy, 50);
            if (boss.isSupernova) {
                grad.addColorStop(0, '#fff'); grad.addColorStop(0.5, '#f0f'); grad.addColorStop(1, '#80f');
            } else {
                grad.addColorStop(0, '#ff0'); grad.addColorStop(0.6, '#f80'); grad.addColorStop(1, '#f00');
            }
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, 48, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = boss.isSupernova ? '#f8f' : '#fa0'; ctx.lineWidth = 4;
            for (let i = 0; i < 12; i++) {
                const a = (i * 30 + Date.now() / 25) * Math.PI / 180;
                ctx.beginPath(); ctx.moveTo(cx + Math.cos(a) * 48, cy + Math.sin(a) * 48);
                ctx.lineTo(cx + Math.cos(a) * 72, cy + Math.sin(a) * 72); ctx.stroke();
            }
            ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
            ctx.fillStyle = boss.isSupernova ? '#f0f' : '#f40';
            ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText(boss.isSupernova ? 'SUPERNOVA' : 'SUN', cx, boss.y - 7);
        }

        function drawLaser() {
            if (!gameState.isLaserMode) return;
            const cx = gameState.player.x + gameState.player.w / 2;
            const laserWidth = 40;

            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0';
            const grad = ctx.createLinearGradient(cx - laserWidth / 2, 0, cx + laserWidth / 2, 0);
            grad.addColorStop(0, 'rgba(255,255,0,0.3)');
            grad.addColorStop(0.5, 'rgba(255,255,0,0.9)');
            grad.addColorStop(1, 'rgba(255,255,0,0.3)');
            ctx.fillStyle = grad;
            ctx.fillRect(cx - laserWidth / 2, 0, laserWidth, gameState.player.y);

            ctx.fillStyle = '#fff';
            ctx.fillRect(cx - 5, 0, 10, gameState.player.y);
            ctx.shadowBlur = 0;
        }

        function draw() {
            const lvl = levels[gameState.currentStage - 1];
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // stageClearing ì¤‘ì—ë„ ì•„ë˜ ë Œë”ë§ ê³„ì† ì‹¤í–‰ (ì•„ì´í…œ íšë“ ìœ„í•´)
            if (gameState.stageClearing) {
                const nextStage = gameState.currentStage + 1;
                ctx.fillStyle = lvl.theme; ctx.font = 'bold 36px Orbitron'; ctx.textAlign = 'center';
                ctx.shadowBlur = 20; ctx.shadowColor = lvl.theme;
                ctx.fillText(nextStage <= 10 ? `NEXT: STAGE ${nextStage}` : 'ğŸ‰ VICTORY!', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
                // return ì œê±° - ì•„ë˜ ë Œë”ë§ ê³„ì†
            }

            // SURVIVE ë¬¸êµ¬ í‘œì‹œ (ì¼ë°˜ ìŠ¤í…Œì´ì§€ë§Œ)
            if (gameState.survivalMode && !lvl.isBoss) {
                ctx.fillStyle = '#f55'; ctx.font = 'bold 28px Orbitron'; ctx.textAlign = 'center';
                ctx.shadowBlur = 15; ctx.shadowColor = '#f55';
                ctx.fillText('SURVIVE!', canvas.width / 2, 80); ctx.shadowBlur = 0;
            }


            drawLaser();
            drawDrones(); drawPlayer();

            // ë£¨ë‚˜ ê°€ë””ì–¸ ë Œë”ë§
            if (gameState.isLunarMode) {
                const px = gameState.player.x + gameState.player.w / 2;
                const py = gameState.player.y;
                const rad = gameState.lunarAngle * Math.PI / 180;
                const gx = px + Math.cos(rad) * 40;
                const gy = py - 15 + Math.sin(rad) * 40;

                ctx.shadowBlur = 20;
                ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath();
                ctx.arc(gx, gy, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(gx + 5, gy - 3, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            if (gameState.boss) {
                if (gameState.boss.type === 'LUNAR') drawLunarBoss(gameState.boss);
                else if (gameState.boss.type === 'SUN') drawSunBoss(gameState.boss);

                // DANGER ê²½ê³  í‘œì‹œ (LUNAR ë³´ìŠ¤)
                if (gameState.dangerWarning > 0 && gameState.boss.type === 'LUNAR') {
                    const blink = Math.floor(Date.now() / 100) % 2 === 0;
                    if (blink) {
                        ctx.fillStyle = '#f00';
                        ctx.font = 'bold 16px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#f00';
                        ctx.fillText('âš  DANGER âš ', gameState.boss.x + gameState.boss.w / 2, gameState.boss.y - 35);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            gameState.enemies.forEach(en => {
                if (en.type === 'BULLET') {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = gameState.currentStage <= 5 ? '#8af' : '#f84';
                    ctx.fillStyle = ctx.shadowColor;
                    ctx.beginPath(); ctx.arc(en.x + en.w / 2, en.y + en.h / 2, en.w / 2, 0, Math.PI * 2); ctx.fill();
                } else if (en.type === 'SHOCKWAVE') {
                    // ì›”ê´‘ ì¶©ê²©íŒŒ ë Œë”ë§ + ë°˜ì§ì„ íš¨ê³¼ (ìƒì‡„ ë¶ˆê°€ í‘œì‹œ)
                    const shimmer = 1 + Math.sin(Date.now() / 50) * 0.3;
                    ctx.shadowBlur = 15 * shimmer;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(en.x + en.w / 2, en.y + en.h / 2, (en.w / 2 + 2) * shimmer, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(en.x + en.w / 2 + 5, en.y + en.h / 2 - 3, en.w / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    // ë°˜ì§ì„ í‘œì‹œ
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('âœ¨', en.x + en.w - 5, en.y + 5);
                } else if (en.type === 'METEOR') {
                    // ìœ ì„± ë Œë”ë§ - ë¶ˆíƒ€ëŠ” ê¼¬ë¦¬ íš¨ê³¼ + ë°˜ì§ì„ (ìƒì‡„ ë¶ˆê°€)
                    const mx = en.x + en.w / 2, my = en.y + en.h / 2;
                    const shimmer = 1 + Math.sin(Date.now() / 50) * 0.2;
                    // ê¼¬ë¦¬
                    ctx.shadowBlur = 20 * shimmer;
                    ctx.shadowColor = '#f80';
                    const grad = ctx.createLinearGradient(mx, my - 15, mx, my + 25);
                    grad.addColorStop(0, 'rgba(255,100,50,0.8)');
                    grad.addColorStop(1, 'rgba(255,200,100,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(mx - 10, my);
                    ctx.lineTo(mx, my - 20);
                    ctx.lineTo(mx + 10, my);
                    ctx.fill();
                    // ë³¸ì²´
                    ctx.fillStyle = '#88f';
                    ctx.beginPath();
                    ctx.arc(mx, my, 14 * shimmer, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(mx - 3, my - 3, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // ë°˜ì§ì„ í‘œì‹œ
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('âœ¨', mx + 10, my - 10);
                    ctx.shadowBlur = 0;
                } else {
                    drawAlien(en, gameState.currentStage);
                }
            });

            gameState.items.forEach(it => drawGiftBox(it));

            ctx.shadowBlur = 5; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
            gameState.bullets.forEach(b => {
                if (b.isLunar) {
                    // í¬ë ˆì„¼íŠ¸ ë°˜ë‹¬ íƒ„í™˜
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(b.x + 6, b.y + 6, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(b.x + 9, b.y + 4, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (b.isHoming) {
                    // ìœ ë„íƒ„ - ë³´ë¼ìƒ‰ ì‚¼ê°í˜•
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#c4f';
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w / 2, b.y);
                    ctx.lineTo(b.x, b.y + b.h);
                    ctx.lineTo(b.x + b.w, b.y + b.h);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                }
            });
            ctx.shadowBlur = 0;

            // ë¬´ì§€ê°œ íŒŒë™ ë Œë”ë§
            if (gameState.rainbowWave) {
                const waveY = gameState.rainbowWave.y;
                const waveHeight = 30;

                // ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜
                const grad = ctx.createLinearGradient(0, waveY - waveHeight / 2, 0, waveY + waveHeight / 2);
                const offset = (Date.now() / 10) % 360;
                for (let i = 0; i <= 6; i++) {
                    const hue = (offset + i * 60) % 360;
                    grad.addColorStop(i / 6, `hsla(${hue}, 100%, 60%, 0.9)`);
                }

                ctx.shadowBlur = 40;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = grad;
                ctx.fillRect(0, waveY - waveHeight / 2, canvas.width, waveHeight);

                // ì¤‘ì•™ ë°ì€ ë¼ì¸
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillRect(0, waveY - 2, canvas.width, 4);
                ctx.shadowBlur = 0;
            }

            // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ
            if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                const alpha = Math.min(1, gameState.timeBonusDisplay.timer);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 24px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0';
                ctx.fillText(`TIME BONUS: +${gameState.timeBonusDisplay.amount}`, canvas.width / 2, 130);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            drawProgressBar();
        }

        function drawPlayer() {
            const p = gameState.player, cx = p.x + p.w / 2, cy = p.y + p.h / 2;

            if (gameState.isInvincible && Math.floor(gameState.invincibilityTimer * 10) % 2 === 0) ctx.globalAlpha = 0.3;
            if (gameState.downgradeFlash > 0) ctx.globalAlpha = 0.5 + Math.sin(gameState.downgradeFlash * 20) * 0.5;

            // í•„ì‚´ê¸° ê²Œì´ì§€ 100% ì‹œ ë¬´ì§€ê°œ ë°˜ì§ì„
            let playerColor;
            if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                const hue = (Date.now() / 5) % 360;  // ë¹ ë¥´ê²Œ ë¬´ì§€ê°œìƒ‰ ìˆœí™˜
                playerColor = `hsl(${hue}, 100%, 60%)`;
                ctx.shadowBlur = 40 + Math.sin(Date.now() / 100) * 10;
            } else {
                const baseColor = gameState.isTransformed ? '#FFD700' : '#C0C0C0';
                ctx.shadowBlur = gameState.isTransformed ? 30 : 20;
                playerColor = gameState.isLaserMode ? '#ff0' : (gameState.skillMode === 'SHIELD' ? '#0f0' : (gameState.isHomingMode ? '#c4f' : baseColor));
            }
            ctx.shadowColor = playerColor;
            ctx.fillStyle = playerColor; ctx.strokeStyle = playerColor; ctx.lineWidth = 2;

            ctx.beginPath();
            if (gameState.isTransformed) {
                ctx.moveTo(cx, cy - 28);
                ctx.lineTo(cx - 22, cy + 18); ctx.lineTo(cx - 8, cy + 10);
                ctx.lineTo(cx, cy + 14);
                ctx.lineTo(cx + 8, cy + 10); ctx.lineTo(cx + 22, cy + 18);
            } else {
                ctx.moveTo(cx, cy - 25); ctx.lineTo(cx - 18, cy + 15); ctx.lineTo(cx - 5, cy + 8);
                ctx.lineTo(cx, cy + 12); ctx.lineTo(cx + 5, cy + 8); ctx.lineTo(cx + 18, cy + 15);
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = gameState.isTransformed ? '#ff0' : '#f80';
            ctx.beginPath();
            const flameH = gameState.isTransformed ? 25 : 20;
            ctx.moveTo(cx - 3, cy + 12); ctx.lineTo(cx, cy + flameH + Math.random() * 6); ctx.lineTo(cx + 3, cy + 12);
            ctx.closePath(); ctx.fill();

            if (gameState.isTransformed) {
                ctx.fillStyle = gameState.isLaserMode ? '#ff0' : '#FFD700';
                ctx.beginPath(); ctx.arc(cx - 20, cy + 5, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx + 20, cy + 5, 5, 0, Math.PI * 2); ctx.fill();
            }

            ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
        }

        function drawDrones() {
            if (gameState.isTransformed) return;
            gameState.drones.forEach(drone => {
                const dx = gameState.player.x + 10 + drone.offsetX, dy = gameState.player.y + 15;
                ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff';
                ctx.beginPath(); ctx.moveTo(dx, dy - 12); ctx.lineTo(dx - 10, dy + 6); ctx.lineTo(dx, dy + 2); ctx.lineTo(dx + 10, dy + 6);
                ctx.closePath(); ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function gameOver() {
            gameState.isRunning = false;
            showResultScreen('MISSION FAILED');

            // [CDSO ì¶”ê°€] ê²Œì„ ì¢…ë£Œ ì‹œ ë­í‚¹íŒ ìµœì‹ í™” (ì´ë•Œë§Œ ì½ê¸° ë¹„ìš© ë°œìƒ)
            initFirebaseRanking();

        }

        // [CDSO ìµœì¢… ìˆ˜ì •] ì…ë ¥ ê°•ì œ ìœ íš¨ì„± ê²€ì‚¬ + ê³µê°„ ìµœì í™” + ë­í‚¹ í†µí•©
        async function saveAndRestart() {
            // [CDSO ë³´ì•ˆ í”„ë¡œí† ì½œ] ê´€ë¦¬ì ëª¨ë“œ ë°ì´í„° ì €ì¥ ì°¨ë‹¨
            if (gameState.isAdminMode) {
                alert("ğŸš« [ADMIN MODE]\nê¸°ë¡ ì €ì¥ë¶ˆê°€\n(Sandbox Data Rejected)");
                
                // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ í”ì  ì§€ìš°ê¸°
                location.reload(); 
                return; 
            }

            const btnSave = document.getElementById('btn-save');
            const actionBtns = document.getElementById('action-buttons');
            const input = document.getElementById('initial-input');
            const resultList = document.getElementById('result-rank-list');
            
            const resultStats = document.querySelector('.result-stats');
            const resultTitle = document.getElementById('res-title');

            // [CDSO ì¶”ê°€ 1] ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬ (Validation Gate)
            // ê³µë°±ì„ ì œê±°í•œ ì‹¤ì œ ê¸€ììˆ˜ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
            const rawName = input.value.trim(); 

            if (rawName.length === 0) {
                // ì…ë ¥ì´ ì—†ìœ¼ë©´ ê²½ê³  íš¨ê³¼ ì—°ì¶œ (ë¹¨ê°„ìƒ‰ ì ë©¸ + í”ë“¤ë¦¼)
                input.style.borderColor = '#f00';
                input.style.boxShadow = '0 0 15px #f00';
                input.placeholder = 'NAME!'; // í”Œë ˆì´ìŠ¤í™€ë” ë³€ê²½
                input.focus();

                // í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜ (UX ê°•í™”)
                input.animate([
                    { transform: 'translateX(0)' },
                    { transform: 'translateX(-5px)' },
                    { transform: 'translateX(5px)' },
                    { transform: 'translateX(0)' }
                ], { duration: 300 });

                return; // â˜… ì—¬ê¸°ì„œ í•¨ìˆ˜ë¥¼ ê°•ì œ ì¢…ë£Œì‹œì¼œ ì €ì¥ì„ ë§‰ìŠµë‹ˆë‹¤.
            }

            // 1. ì €ì¥ ì¤‘ ìƒíƒœ í‘œì‹œ
            btnSave.textContent = "UPDATING RANK...";
            btnSave.disabled = true;
            input.disabled = true;

            // ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í†µê³¼í–ˆìœ¼ë¯€ë¡œ ì´ë¦„ í™•ì •
            const name = rawName.toUpperCase();
            const finalScore = Math.round(gameState.score);

            // 2. íŒŒì´ì–´ë² ì´ìŠ¤ ì €ì¥ ë° ë‚´ ìˆœìœ„ ë°˜í™˜
            const myRank = await saveToFirebase(name, finalScore, gameState.currentStage);
            
            // ì „ì²´ ë­í‚¹(Top 5) ë°ì´í„° ê°±ì‹ 
            await initFirebaseRanking();
            
            gameState.finalRank = myRank;

            // 3. UI ê³µê°„ ìµœì í™” (Space Optimization)
            btnSave.style.display = 'none';    
            input.style.display = 'none';      
            resultStats.style.display = 'none'; 
            
            resultTitle.style.marginBottom = '10px';
            resultTitle.style.fontSize = '1.5em'; 

            if (myRank) {
                // A. ìµœì‹  Top 5 ë¦¬ìŠ¤íŠ¸ ë³µì‚¬
                const top5Content = document.getElementById('leaderboard').innerHTML;

                // B. ë‚´ ìˆœìœ„ ë°•ìŠ¤ ìƒì„±
                const myRankHTML = `
                    <li class="rank-me" style="animation: pulseRed 2s infinite; margin-top: 15px; border-color: #f00;">
                        <span class="rank-badge" style="background: linear-gradient(135deg, #ff0000, #990000); color: #fff;">${myRank}</span>
                        <span class="player-name">${name}</span>
                        <span class="player-score">${finalScore.toLocaleString()}</span>
                        <span class="player-stage">ST.${gameState.currentStage}</span>
                    </li>
                `;

                // C. í†µí•© ë¦¬ìŠ¤íŠ¸ ì¶œë ¥
                resultList.innerHTML = top5Content + myRankHTML;
                resultList.style.display = 'block';
            }

            // 4. ë²„íŠ¼ ê·¸ë£¹ ë³´ì´ê¸°
            actionBtns.style.display = 'flex';
        }


        // [CDSO ìµœì¢… ìˆ˜ì •] TOP 5 ì´ë¯¸ì§€ í†µí•© + PC ê³µìœ  ì¶©ëŒ ë°©ì§€ ì‹œìŠ¤í…œ
        async function shareScore() {
            // 1. ë°ì´í„° ì¤€ë¹„
            const myRank = gameState.finalRank || '?';
            const myScore = Math.round(gameState.score);
            const myName = document.getElementById('initial-input').value.toUpperCase() || 'PLAYER';
            const gameUrl = window.location.href; 

            // 2. ë°”ì´ëŸ´ í…ìŠ¤íŠ¸ (ë³µì‚¬ ë° ê³µìœ ìš©)
            const shareTitle = 'Neon Dodge Record';
            const shareText = `[NEON DODGE]\nğŸ‘‘ RANK: ${myRank}\nğŸ‘¾ PLAYER: ${myName}\nğŸš€ SCORE: ${myScore.toLocaleString()}\n\në‚˜ë³´ë‹¤ ëª»í•˜ì¥¬?\nğŸ”— Play: ${gameUrl}`;

            // 3. ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° (ì´ë¯¸ì§€ í•©ì„±)
            ctx.save();
            
            // ë°°ê²½ & í…Œë‘ë¦¬
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 10; ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // A. íƒ€ì´í‹€ (ìƒë‹¨)
            ctx.shadowColor = '#0ff'; ctx.shadowBlur = 20;
            ctx.fillStyle = '#fff'; ctx.font = 'bold 36px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText('NEON DODGE', canvas.width/2, 60);

            // B. ë‚´ ìˆœìœ„ & ì ìˆ˜ (ì¤‘ë‹¨ ê°•ì¡°)
            ctx.shadowColor = '#f00'; ctx.shadowBlur = 30;
            ctx.fillStyle = '#f00'; ctx.font = 'bold 50px Orbitron';
            ctx.fillText(`RANK ${myRank}`, canvas.width/2, 130);

            ctx.shadowColor = '#fff'; ctx.shadowBlur = 10;
            ctx.fillStyle = '#fff'; ctx.font = '20px Orbitron';
            ctx.fillText(`PLAYER: ${myName}`, canvas.width/2, 170);
            
            ctx.shadowColor = '#f0f'; ctx.fillStyle = '#f0f'; ctx.font = 'bold 36px Orbitron';
            ctx.fillText(myScore.toLocaleString(), canvas.width/2, 215);

            // êµ¬ë¶„ì„ 
            ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(40, 240); ctx.lineTo(410, 240); ctx.stroke();

            // C. TOP 10 ë¦¬ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° (í•˜ë‹¨ í‘œ)
            ctx.shadowColor = '#ff0'; ctx.shadowBlur = 0;
            ctx.fillStyle = '#ff0'; ctx.font = 'bold 18px Orbitron';
            
            ctx.fillText('- LEGENDARY TOP 10 -', canvas.width/2, 255); // Yì¢Œí‘œ 255ë¡œ ì˜¬ë¦¼
            const listItems = document.querySelectorAll('#leaderboard li');
            
            // [ìˆ˜ì •] ì‹œì‘ ìœ„ì¹˜ë¥¼ 300ìœ¼ë¡œ ëŒ€í­ ì˜¬ë¦¼
            let startY = 300;
            // [ì¶”ê°€] ì´˜ì´˜í•œ ì¤„ ê°„ê²© ë³€ìˆ˜ ìƒì„±
            const lineHeight = 38;
            ctx.font = '14px Orbitron';
            
            listItems.forEach((li, index) => {
                if (index >= 10) return; // 10ë“±ê¹Œì§€ë§Œ

                // [CDSO ìˆ˜ì •] ìˆ¨ê²¨ì§„ ìš”ì†Œ(display:none)ì˜ ê°’ì„ ì½ê¸° ìœ„í•´ textContent ì‚¬ìš©
                const pName = li.querySelector('.player-name')?.textContent || '???';
                const pScore = li.querySelector('.player-score')?.textContent || '0';

                const rank = index + 1;

                // 1,2,3ë“± ìƒ‰ìƒ êµ¬ë¶„
                let color = '#aaa';
                if (rank === 1) color = '#ffd700';
                else if (rank === 2) color = '#c0c0c0';
                else if (rank === 3) color = '#cd7f32';
                else if (rank <= 10) color = '#ddd'; // [ì¶”ê°€] 4~10ë“±ì€ ë°ì€ íšŒìƒ‰

                // ì¢Œì¸¡ ì •ë ¬(ì´ë¦„) & ìš°ì¸¡ ì •ë ¬(ì ìˆ˜)
                ctx.textAlign = 'left'; ctx.fillStyle = color;
                ctx.fillText(`${rank}. ${pName}`, 50, startY);
                
                ctx.textAlign = 'right'; ctx.fillStyle = '#fff';
                ctx.fillText(pScore, 400, startY);

                startY += lineHeight; // [ìˆ˜ì •] 45 -> 38 (lineHeight ë³€ìˆ˜ ì‚¬ìš©)
            });

            // ë‚ ì§œ ë„ì¥
            ctx.textAlign = 'center';
            ctx.fillStyle = '#444'; ctx.font = '10px Orbitron';
            ctx.fillText(new Date().toLocaleString(), canvas.width/2, canvas.height - 20);
            ctx.restore();


            // 4. ê³µìœ  ë¡œì§ (PC ì¶©ëŒ ë°©ì§€)
            try {
                // ëª¨ë°”ì¼ ê¸°ê¸°ì¸ì§€ í™•ì¸ (ì´ë¯¸ ì„ ì–¸ëœ isMobileDevice í•¨ìˆ˜ í™œìš©)
                // ë§Œì•½ isMobileDevice í•¨ìˆ˜ê°€ ì—†ë‹¤ë©´ ì•„ë˜ ì •ê·œì‹ ì‚¬ìš©: /Android|iPhone|iPad/i.test(navigator.userAgent)
                const isMobile = isMobileDevice(); 

                if (isMobile && navigator.share) {
                    // [ëª¨ë°”ì¼] ì´ë¯¸ì§€ ê³µìœ  ì‹œë„
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    const file = new File([blob], "neon_dodge_ranking.png", { type: "image/png" });
                    
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            title: shareTitle,
                            text: shareText,
                            files: [file]
                        });
                        return; // ì„±ê³µ ì‹œ ì¢…ë£Œ
                    }
                }
                
                // [PC / ëª¨ë°”ì¼ ê³µìœ  ì‹¤íŒ¨ ì‹œ] í´ë¦½ë³´ë“œ ë³µì‚¬ë¡œ ê°•ì œ ì „í™˜
                throw new Error("FALLBACK_TO_CLIPBOARD");

            } catch (err) {
                // 5. í´ë¦½ë³´ë“œ ë³µì‚¬ (Fallback)
                try {
                    await navigator.clipboard.writeText(shareText);
                    alert("ğŸ“‹ ë­í‚¹ê³¼ ì ìˆ˜ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n(Ctrl+Vë¡œ ê³µìœ í•˜ì„¸ìš”)");
                } catch (clipboardErr) {
                    prompt("ì•„ë˜ í…ìŠ¤íŠ¸ë¥¼ ë³µì‚¬í•˜ì„¸ìš”:", shareText);
                }
            }
        }



        let lastTime = performance.now();
        function gameLoop(now) {
            const dt = (now - lastTime) / 1000; lastTime = now;
            spawnEntities(dt); update(dt); draw();
            if (gameState.isRunning) requestAnimationFrame(gameLoop);
        }

        window.addEventListener('firebase-ready', initFirebaseRanking);
        setTimeout(() => { if (!firebaseReady) initFirebaseRanking(); }, 1000);

        // [CDSO ì „ëµ] ê´€ë¦¬ì ì „ìš© ë°±ë„ì–´ (Project Wormhole)
        let cheatBuffer = [];
        const CHEAT_CODE = "ADMIN"; // ì›í•˜ëŠ” ë¹„ë°€ë²ˆí˜¸ë¡œ ë³€ê²½ ê°€ëŠ¥
        let logoTapCount = 0;
        let logoTapTimer = null;

        // 1. PC: í‚¤ë³´ë“œ ì…ë ¥ ê°ì§€
        window.addEventListener('keydown', e => {
            const startScreen = document.getElementById('start-screen');
            // ì‹œì‘ í™”ë©´ì´ ì•ˆ ë³´ì´ë©´ ì‘ë™ X
            if (startScreen.style.display === 'none') return; 

            cheatBuffer.push(e.key.toUpperCase());
            if (cheatBuffer.length > CHEAT_CODE.length) cheatBuffer.shift();

            if (cheatBuffer.join('') === CHEAT_CODE) {
                activateWormhole(); // ì›Œí”„ ë°œë™!
            }
        });

        // 2. Mobile: ë¡œê³  í„°ì¹˜ ê°ì§€ (DOM ë¡œë“œ í›„ ì´ë²¤íŠ¸ ì—°ê²°)
        window.addEventListener('load', () => {
            const titleLogo = document.querySelector('#start-screen h1');
            if (titleLogo) {
                titleLogo.addEventListener('click', () => {
                    logoTapCount++;
                    
                    // 2ì´ˆ ì•ˆì— 5ë²ˆ ëª» ëˆ„ë¥´ë©´ ì´ˆê¸°í™”
                    clearTimeout(logoTapTimer);
                    logoTapTimer = setTimeout(() => { logoTapCount = 0; }, 2000);

                    if (logoTapCount >= 5) {
                        activateWormhole(); // ì›Œí”„ ë°œë™!
                        logoTapCount = 0;
                    }
                });
            }
        });

        // 3. ì›Œí”„ ì‹¤í–‰ í•¨ìˆ˜ (Stage 11 ê°•ì œ ì§„ì…)
        function activateWormhole() {
            console.warn("âš  ADMIN ACCESS GRANTED: WARPING TO STAGE 11 âš ");
            
            // 1) ì •ìƒ ê²Œì„ ì‹œì‘
            startGame(); 

            // [CDSO í•µì‹¬] ê´€ë¦¬ì ëª¨ë“œ ë„ì¥ ì°ê¸°
            gameState.isAdminMode = true;


            // 2) ë°ì´í„° ê°•ì œ ë³€ì¡° (Data Injection)
            gameState.currentStage = 11;
            gameState.stageTimer = 99999; 
            gameState.spawnTimer = 0;
            gameState.spawnDelay = 0; // ë”œë ˆì´ ì—†ì´ ì¦‰ì‹œ ì‹œì‘
            
            // ë¬´í•œ ëª¨ë“œ ì „ìš© ë³€ìˆ˜ ì´ˆê¸°í™”
            gameState.infiniteDifficulty = 1.0;
            
            // [ê´€ë¦¬ì íŠ¹ì „] í…ŒìŠ¤íŠ¸ í¸ì˜ë¥¼ ìœ„í•´ ì‰´ë“œì™€ í’€íŒŒì›Œ ì œê³µ (ì„ íƒì‚¬í•­)
            gameState.lives = 7; 
            gameState.maxLives = 7; // <--- ì´ ì¤„ì„ ë°˜ë“œì‹œ ì¶”ê°€í•´ì•¼ í•¨
            updateLivesUI();        // <--- ë³€ê²½ëœ UI ì¦‰ì‹œ ë°˜ì˜
            gameState.skillMode = 'SHIELD';
            gameState.skillTimer = 10.0;
            
            // 3) UI ê°•ì œ ì—…ë°ì´íŠ¸
            const stageInfo = document.getElementById('stage-info');
            if(stageInfo) {
                stageInfo.textContent = "STAGE âˆ | TEST MODE";
                stageInfo.style.color = "#0f0"; // ê´€ë¦¬ì ëª¨ë“œì„ì„ ì•Œë¦¬ëŠ” ë…¹ìƒ‰
            }
            
            // ì‹œì‘ í™”ë©´ í…ìŠ¤íŠ¸ ë³€ê²½ íš¨ê³¼ (ê°„ì§€ìš©)
            const btn = document.querySelector('#start-screen button');
            if(btn) btn.textContent = "ACCESS GRANTED...";
        }


    </script>
</body>

</html>
