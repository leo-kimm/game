<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dodge - Legend Edition</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            background: #111;
            border: 3px solid #0ff;
            display: block;
            box-shadow: 0 0 20px #0ff;
            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* ëª¨ë°”ì¼ ë°˜ì‘í˜• */
        @media (max-width: 500px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
                max-height: 100vh;
                border-width: 1px;
            }

            #game-container {
                width: 100vw;
            }
        }



        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
        }

        .ui-panel {
            position: absolute;
            top: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            box-sizing: border-box;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            font-size: 0.9em;
        }

        #current-score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff;
            pointer-events: none;
            z-index: 10;
        }

        #leaderboard {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            font-size: 1em;
            width: 320px;
        }

        #leaderboard h3 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-shadow: 0 0 10px #0ff;
        }

        /* [ìˆ˜ì •] ë‚´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ì—ë„ ë™ì¼í•œ ìŠ¤íƒ€ì¼ ì ìš© */
        #leaderboard li, #my-rank-list li {
            margin: 8px 0;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            list-style: none; /* ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì œê±° */
        }

        /* [ì¶”ê°€] ë‚´ ìˆœìœ„ ì „ìš© - ë¶‰ì€ìƒ‰ í…Œë‘ë¦¬ ë° ìŠ¤íƒ€ì¼ */
        li.rank-me {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.2), rgba(100, 0, 0, 0.1)) !important;
            border: 2px solid #ff0000 !important;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            font-weight: bold;
            margin-top: 20px !important; /* ìœ„ìª½ TOP5ì™€ ê°„ê²© ë„ìš°ê¸° */
            animation: pulseRed 2s infinite;
        }

        /* [ì¶”ê°€] ë¶‰ì€ìƒ‰ ë°°ì§€ */
        .rank-me .rank-badge {
            background: linear-gradient(135deg, #ff0000, #990000);
            color: #fff;
            box-shadow: 0 0 10px #f00;
        }

        @keyframes pulseRed {
            0% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.4); }
            50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.7); }
            100% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.4); }
        }
        
        /* [ì¶”ê°€] ë‚´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #my-rank-list {
            padding: 0;
            margin: 0;
            width: 320px;
        }



        #leaderboard li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* 1ë“± - ê³¨ë“œ ê°•ì¡° */
        #leaderboard li.rank-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 180, 0, 0.15));
            border: 2px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            font-size: 1.15em;
            font-weight: bold;
        }

        /* 2ë“± - ì‹¤ë²„ */
        #leaderboard li.rank-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(150, 150, 150, 0.1));
            border: 1px solid #c0c0c0;
        }

        /* 3ë“± - ë¸Œë¡ ì¦ˆ */
        #leaderboard li.rank-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(180, 100, 40, 0.1));
            border: 1px solid #cd7f32;
        }

        /* ì‹ ê·œ ìœ ì € í•˜ì´ë¼ì´íŠ¸ */
        #leaderboard li.new-user {
            animation: newUserPulse 1.5s ease infinite;
            border-color: #0ff !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        @keyframes newUserPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            }
        }

        .rank-badge {
            min-width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
        }

        .rank-1 .rank-badge {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .rank-2 .rank-badge {
            background: linear-gradient(135deg, #c0c0c0, #888);
            color: #000;
        }

        .rank-3 .rank-badge {
            background: linear-gradient(135deg, #cd7f32, #a05a20);
            color: #fff;
        }

        .rank-4 .rank-badge,
        .rank-5 .rank-badge {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .player-name {
            flex: 1;
            text-align: left;
            color: #fff;
        }

        .player-score {
            font-weight: bold;
            color: #0ff;
            margin-right: 10px;
        }

        .player-stage {
            color: #888;
            font-size: 0.85em;
        }

        /* ê²°ê³¼ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px 40px;
            border: 2px solid #f0f;
            box-shadow: 0 0 20px #f0f, inset 0 0 15px rgba(255, 0, 255, 0.1);
            background: rgba(20, 0, 30, 0.9);
            animation: slideDown 0.5s ease-out, glitch 0.1s infinite alternate;
        }

        .result-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
            margin-bottom: 20px;
            animation: textGlitch 2s infinite;
        }

        .result-stats {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(0, 255, 255, 0.05);
            border-left: 3px solid #0ff;
        }

        .stat-row .label {
            font-size: 0.9em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        #initial-input {
            background: transparent;
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 2em;
            text-align: center;
            width: 150px;
            outline: none;
            text-transform: uppercase;
            margin-top: 20px;
            animation: inputPulse 1.5s ease-in-out infinite;
        }

        button {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 25px;
            cursor: pointer;
            font-size: 1.2em;
            margin-top: 20px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 25px #0ff;
        }

        .active-skill {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #f0f;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes slideDown {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes glitch {
            0% {
                transform: translate(0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, -1px);
            }

            75% {
                transform: translate(-1px, -1px);
            }

            100% {
                transform: translate(1px, 1px);
            }
        }

        @keyframes textGlitch {

            0%,
            90%,
            100% {
                text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
                clip-path: none;
            }

            92% {
                text-shadow: -3px 0 #0ff, 3px 0 #f0f;
                clip-path: inset(20% 0 30% 0);
            }

            94% {
                text-shadow: 3px 0 #0ff, -3px 0 #f0f;
                clip-path: inset(50% 0 10% 0);
            }

            96% {
                text-shadow: -2px 0 #0ff, 2px 0 #f0f;
                clip-path: inset(10% 0 60% 0);
            }

            98% {
                text-shadow: 2px 0 #0ff, -2px 0 #f0f;
                clip-path: inset(40% 0 20% 0);
            }
        }

        @keyframes inputPulse {

            0%,
            100% {
                box-shadow: 0 0 5px #f0f;
                border-color: #f0f;
            }

            50% {
                box-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
                border-color: #fff;
            }
        }

        /* ê²°ê³¼ í™”ë©´ ìŠ¬ë¼ì´ë“œ ì¸ */
        #rank-input-screen.show {
            animation: screenGlitchIn 0.3s ease-out;
        }

        @keyframes screenGlitchIn {
            0% {
                opacity: 0;
            }

            10% {
                opacity: 1;
                transform: translateX(-5px);
            }

            20% {
                transform: translateX(5px);
            }

            30% {
                transform: translateX(-3px);
            }

            40% {
                transform: translateX(3px);
            }

            50% {
                transform: translateX(-1px);
            }

            60% {
                transform: translateX(1px);
            }

            100% {
                transform: translateX(0);
            }
        }

        /* [CDSO ì¶”ê°€] ì„¤ì • ë²„íŠ¼ ìŠ¤íƒ€ì¼ (PCì—ì„œëŠ” ìˆ¨ê¹€, ëª¨ë°”ì¼ì—ì„œëŠ” ë…¸ì¶œ) */
        #setting-btn {
            display: none; /* ê¸°ë³¸ê°’: PCì—ì„œëŠ” ì•ˆ ë³´ì„ */
            margin-top: 15px;
            font-size: 0.9em;
            background: transparent;
            border: 2px solid #888;
            color: #aaa;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px #000;
        }
        #setting-btn:hover {
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* ëª¨ë°”ì¼ í™”ë©´ì—ì„œë§Œ ë²„íŠ¼ ë³´ì´ê¸° */
        @media (max-width: 500px) {
            #setting-btn {
                display: block !important;
            }
        }




    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        // [ì¤‘ìš” ìˆ˜ì •] ì•„ë˜ import ì¤„ ëë¶€ë¶„ì— where, getDocsê°€ ë°˜ë“œì‹œ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp, where, getDocs }
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBTLq7p5i6GZ89kkWyTFXUMN2TLRBfdL8w",
            authDomain: "neon-dodge-global.firebaseapp.com",
            projectId: "neon-dodge-global",
            storageBucket: "neon-dodge-global.firebasestorage.app",
            messagingSenderId: "104500725211",
            appId: "1:104500725211:web:aa5e89d87ec21808ec4fe"
        };

        window.firebaseApp = initializeApp(firebaseConfig);
        window.firebaseDB = getFirestore(window.firebaseApp);

        // 2. window.firebaseModules ëª©ë¡ì—ë„ where, getDocs ì¶”ê°€
        window.firebaseModules = { collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp, where, getDocs };
        window.dispatchEvent(new Event('firebase-ready'));
    </script>
</head>

<body>
    <div id="game-container">
        <div class="ui-panel">
            <div id="lives">LIVES: â™¥â™¥â™¥</div>
            <div id="current-score">0</div>
            <div id="stage-info">STAGE 1 | TIME: 30</div>
        </div>
        <div id="skill-display" class="active-skill"></div>
        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="overlay">
            <h1>NEON DODGE</h1>
            <ul id="leaderboard">
                <li>Loading...</li>
            </ul>
            <ul id="my-rank-list" style="display:none;"></ul>

            <button onclick="startGame()">GAME START</button>

            <button id="setting-btn" onclick="toggleControlMode()" style="margin-top:10px; font-size:0.8em; border-color:#888; color:#aaa;">

                âš™ï¸ CONTROL: TRACKING
            </button>


        </div>

        <div id="rank-input-screen" class="overlay" style="display:none;">
            <div class="result-container">
                <div class="result-title" id="res-title">MISSION FAILED</div>
                <div class="result-stats">
                    <div class="stat-row">
                        <span class="label">STAGE</span>
                        <span class="value" id="res-stage">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">SCORE</span>
                        <span class="value" id="res-score">0</span>
                    </div>
                </div>
            </div>
            <input type="text" id="initial-input" maxlength="3" placeholder="AAA">
            <button onclick="saveAndRestart()">SAVE RECORD</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 450; canvas.height = 700;

        const levels = [
            { stage: 1, duration: 10, theme: '#0ff', speedMult: 1.0, spawnRate: 0.69, types: ['NORMAL'], isBoss: false },
            { stage: 2, duration: 11, theme: '#0f0', speedMult: 1.1, spawnRate: 0.62, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
            { stage: 3, duration: 12, theme: '#8ef', speedMult: 1.2, spawnRate: 0.54, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
            { stage: 4, duration: 13, theme: '#aaf', speedMult: 1.3, spawnRate: 0.46, types: ['NORMAL', 'ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 5, duration: 14, theme: '#88f', speedMult: 1.4, spawnRate: 0.42, types: ['ZIGZAG', 'HOMING'], isBoss: true, bossHP: 70, bossType: 'LUNAR' },
            { stage: 6, duration: 15, theme: '#f80', speedMult: 1.5, spawnRate: 0.31, types: ['ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 7, duration: 16, theme: '#f64', speedMult: 1.6, spawnRate: 0.27, types: ['ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 8, duration: 17, theme: '#f44', speedMult: 1.7, spawnRate: 0.25, types: ['NORMAL', 'ZIGZAG', 'HOMING', 'SHOOTER'], isBoss: false },
            { stage: 9, duration: 18, theme: '#f22', speedMult: 1.9, spawnRate: 0.22, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER'], isBoss: false },
            { stage: 10, duration: 19, theme: '#f80', speedMult: 2.0, spawnRate: 0.19, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER', 'LASER_ENEMY'], isBoss: true, bossHP: 140, bossType: 'SUN' }
        ];

        let gameState = {
            isRunning: false, score: 0,
            player: { x: 215, y: 630, w: 20, h: 20, speed: 400 },
            enemies: [], items: [], bullets: [], keys: {},
            skillMode: 'NORMAL', skillTimer: 0,
            lives: 3, maxLives: 3, isInvincible: false, invincibilityTimer: 0,
            drones: [],
            isTransformed: false,
            isLaserMode: false, laserTimer: 0,
            spawnTimer: 0, itemSpawnTimer: 0,
            currentStage: 1, stageTimer: 30, boss: null,
            stageClearing: false, stageClearTimer: 0, survivalMode: false,
            bossPhase: 'MINION',
            bossTimer: 0,
            bossResurrected: false,
            downgradeFlash: 0,
            progressDisplay: 0,
            survivalStartCount: 0,
            spawnDelay: 0,
            isLunarMode: false,
            lunarAngle: 0,
            touchTarget: null,
            stageTimerEnded: false,
            survivalTimer: 0,
            pendingBoss: null,
            // ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤
            ultGauge: 0,           // í•„ì‚´ê¸° ê²Œì´ì§€ (0~1)
            autoFireTimer: 0,      // ìë™ ë°œì‚¬ íƒ€ì´ë¨¸
            isHomingMode: false,   // ìœ ë„íƒ„ ëª¨ë“œ
            homingTimer: 0,        // ìœ ë„íƒ„ ì§€ì† ì‹œê°„
            rainbowWave: null,     // ë¬´ì§€ê°œ íŒŒë™ ìƒíƒœ
            dangerWarning: 0,      // DANGER ê²½ê³  íƒ€ì´ë¨¸
            timeBonusDisplay: null // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ
        };


        // [CDSO ì „ëµ] ì»¨íŠ¸ë¡¤ ëª¨ë“œ ìƒíƒœ ê´€ë¦¬ ('TRACKING' vs 'BUTTONS')
        // localStorageë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ ì €ì˜ ì„ íƒì„ ê¸°ì–µí•©ë‹ˆë‹¤.
        let controlMode = localStorage.getItem('controlMode') || 'BUTTONS';

        function toggleControlMode() {
            // ëª¨ë“œ í† ê¸€ (TRACKING <-> BUTTONS)
            controlMode = controlMode === 'TRACKING' ? 'BUTTONS' : 'TRACKING';
            localStorage.setItem('controlMode', controlMode); // ì €ì¥
            updateSettingBtn(); // UI ì—…ë°ì´íŠ¸
        }

        function updateSettingBtn() {
            const btn = document.getElementById('setting-btn');
            if (btn) {
                if (controlMode === 'TRACKING') {
                    btn.innerHTML = 'âš™ï¸ CONTROL: ğŸ‘† TRACKING'; // ì¶”ì  ëª¨ë“œ
                    btn.style.color = '#0ff';
                    btn.style.borderColor = '#0ff';
                } else {
                    btn.innerHTML = 'âš™ï¸ CONTROL: â¬…ï¸â¡ï¸ BUTTONS'; // ë²„íŠ¼ ëª¨ë“œ
                    btn.style.color = '#f0f';
                    btn.style.borderColor = '#f0f';
                }
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
        window.addEventListener('load', updateSettingBtn);




        let firebaseReady = false;
        let lastSavedName = '';  // ì‹ ê·œ ë“±ë¡ ìœ ì € í•˜ì´ë¼ì´íŠ¸ìš©


        // [CDSO ì „ëµ ìˆ˜ì •] ë¹„ìš© ìµœì í™”: ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆ(onSnapshot) ì œê±° -> ë‹¨ë°œì„± ì¡°íšŒ(getDocs)ë¡œ ë³€ê²½
        async function initFirebaseRanking() {
            if (!window.firebaseDB) { setTimeout(initFirebaseRanking, 100); return; }
            firebaseReady = true;
            
            const { collection, query, orderBy, limit, getDocs } = window.firebaseModules;
            const list = document.getElementById('leaderboard');
            
            try {
                // 1. ì¿¼ë¦¬ ìƒì„± (ê¸°ì¡´ê³¼ ë™ì¼)
                const q = query(
                    collection(window.firebaseDB, 'rankings'), 
                    orderBy('score', 'desc'), 
                    limit(5)
                );

                // 2. [ë³€ê²½] getDocsë¥¼ ì‚¬ìš©í•˜ì—¬ 1íšŒë§Œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë¹„ìš© ì ˆê° í•µì‹¬)
                const snapshot = await getDocs(q);

                list.innerHTML = '<h3>ğŸŒ GLOBAL TOP 5</h3>';
                if (snapshot.empty) { 
                    list.innerHTML += '<li class="rank-1">No Records Yet</li>'; 
                } else {
                    snapshot.docs.forEach((doc, i) => {
                        const r = doc.data();
                        const rank = i + 1;
                        const isNewUser = lastSavedName && r.name === lastSavedName;
                        const rankClass = `rank-${rank}${isNewUser ? ' new-user' : ''}`;
                        const rankEmoji = rank === 1 ? 'ğŸ¥‡' : (rank === 2 ? 'ğŸ¥ˆ' : (rank === 3 ? 'ğŸ¥‰' : rank));
                        
                        list.innerHTML += `
                            <li class="${rankClass}">
                                <span class="rank-badge">${rankEmoji}</span>
                                <span class="player-name">${r.name}</span>
                                <span class="player-score">${r.score.toLocaleString()}</span>
                                <span class="player-stage">ST.${r.stage}</span>
                            </li>`;
                    });
                }
            } catch (e) { 
                console.error("Ranking Load Error:", e); 
            }

            // ë‚´ ìµœê³  ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
            const savedData = localStorage.getItem('myBestRecord');
            if (savedData) {
                try {
                    const r = JSON.parse(savedData);
                    if (r.score > 0) updateMyRank(r.name, r.score, r.stage);
                } catch (e) { console.error('Data parsing error', e); }
            }
        }


        // [CDSO ì¶”ê°€] ì‚¬ìš©ì í™˜ê²½ ì •ë³´ ìˆ˜ì§‘ í•¨ìˆ˜
        function getSystemInfo() {
            const ua = navigator.userAgent;
            const isMobile = /Mobi|Android/i.test(ua) || window.innerWidth <= 500;
            
            return {
                platform: isMobile ? 'MOBILE' : 'PC', // ëª¨ë°”ì¼/PC êµ¬ë¶„
                browserInfo: ua,                      // ê¸°ê¸° ë° ë¸Œë¼ìš°ì € ì›ë³¸ ì •ë³´
                resolution: `${window.innerWidth}x${window.innerHeight}`, // í™”ë©´ í•´ìƒë„
                controlType: localStorage.getItem('controlMode') || 'BUTTONS' // ì‚¬ìš©í•œ ì»¨íŠ¸ë¡¤ ë°©ì‹
            };
        }



        async function saveToFirebase(name, score, stage) {
            if (!firebaseReady) return;

            // ìƒì„¸ ì •ë³´ë¥¼ ë¡œì»¬ì— ì €ì¥
            const myRecord = { name, score, stage };
            localStorage.setItem('myBestRecord', JSON.stringify(myRecord));

            // [CDSO ì „ëµ] ê¸°ê¸° ì •ë³´ ë° ê²Œì„ í”Œë ˆì´ ë°ì´í„° ë¶„ì„
            const sysInfo = getSystemInfo();
            
            // 1. í”Œë ˆì´ ì‹œê°„ ê³„ì‚°
            const playTimeSec = Math.floor((Date.now() - gameState.startTime) / 1000);

            // 2. ì•„ì´í…œ íšë“ë¥  ê³„ì‚° (0% ~ 100%)
            const collectionRate = gameState.totalItemsSpawned > 0 
                ? Math.round((gameState.itemsCollected / gameState.totalItemsSpawned) * 100) 
                : 0;

            // 3. íƒìš• ì‚¬ë§ íŒì • (ì£½ì—ˆì„ ë•Œ ê·¼ì²˜ 100px ë‚´ì— ì•„ì´í…œì´ ìˆì—ˆëŠ”ê°€?)
            let isGreedyDeath = false;
            const px = gameState.player.x, py = gameState.player.y;
            for (let item of gameState.items) {
                const dist = Math.sqrt(Math.pow(item.x - px, 2) + Math.pow(item.y - py, 2));
                if (dist < 100) { isGreedyDeath = true; break; }
            }

            const { collection, addDoc, serverTimestamp } = window.firebaseModules;
            try {
                // í™•ì¥ëœ ë°ì´í„° í˜ì´ë¡œë“œ ì „ì†¡
                await addDoc(collection(window.firebaseDB, 'rankings'), { 
                    name, 
                    score, 
                    stage, 
                    timestamp: serverTimestamp(),
                    
                    // [System Info]
                    platform: sysInfo.platform,
                    device: sysInfo.browserInfo,
                    screen: sysInfo.resolution,
                    control: sysInfo.controlType,

                    // [Game Analytics]
                    playTimeSec: playTimeSec,           // í”Œë ˆì´ ì‹œê°„ (ì´ˆ)
                    deathReason: gameState.lastHitBy,   // ì‚¬ë§ ì›ì¸ (ì˜ˆ: ENEMY_BULLET)
                    itemCollectionRate: collectionRate, // ì•„ì´í…œ íšë“ë¥  (%)
                    isGreedyDeath: isGreedyDeath        // íƒìš• ì‚¬ë§ ì—¬ë¶€ (Boolean)
                });
                
                lastSavedName = name;
                await updateMyRank(name, score, stage);
            }
            catch (e) { console.error(e); }
        }



        async function updateMyRank(name, score, stage) {
            // ì¸ìê°€ ë¶€ì¡±í•˜ë©´ ì‹¤í–‰ ì¤‘ë‹¨
            if (!firebaseReady || !score) return;

            const { collection, query, where, getDocs } = window.firebaseModules;
            try {
                // ë‚´ ì ìˆ˜ë³´ë‹¤ ë†’ì€ ì‚¬ëŒ ìˆ˜ ê³„ì‚° (ë“±ìˆ˜ ì‚°ì •)
                const higherQuery = query(
                    collection(window.firebaseDB, 'rankings'),
                    where('score', '>', score)
                );
                const higherSnapshot = await getDocs(higherQuery);
                const myRank = higherSnapshot.size + 1;

                // [ìˆ˜ì •] ê¸°ì¡´ í…ìŠ¤íŠ¸ div ëŒ€ì‹ , ë¦¬ìŠ¤íŠ¸(ul) ì•ˆì— ìƒˆë¡œìš´ li ë°•ìŠ¤ë¥¼ ìƒì„±í•´ ë„£ìŒ
                const rankList = document.getElementById('my-rank-list');

                // HTML êµ¬ì¡° ìƒì„± (CSSì˜ .rank-me ìŠ¤íƒ€ì¼ì´ ì ìš©ë¨)
                rankList.innerHTML = `
                    <li class="rank-me">
                        <span class="rank-badge">${myRank}</span>
                        <span class="player-name">${name}</span>
                        <span class="player-score">${score.toLocaleString()}</span>
                        <span class="player-stage">ST.${stage}</span>
                    </li>
                `;
                rankList.style.display = 'block';

            } catch (e) {
                console.error('Failed to calculate rank:', e);
            }
        }

        // ì‹¤ì œ ì  ê¸°ì²´ë§Œ ì¹´ìš´íŠ¸ (íƒ„í™˜ + í­ë°œ/ë°œì‚¬ ì™„ë£Œ ì  ì œì™¸)
        function getActiveEnemyCount() {
            return gameState.enemies.filter(en =>
                en.type !== 'BULLET' &&
                en.type !== 'ENEMY_BULLET' &&
                en.type !== 'SHOCKWAVE' &&
                en.type !== 'METEOR' &&
                !(en.type === 'BOMBER' && en.exploded) &&
                !(en.type === 'LASER_ENEMY' && en.fired)
            ).length;
        }

        // ì  íƒ€ì…ë³„ ì°¨ë“± ì ìˆ˜ (ì†Œìˆ˜ì  ë‹¨ìœ„)
        function getEnemyScore(type) {
            const scoreTable = {
                'NORMAL': 1.0,
                'ZIGZAG': 1.2,
                'HOMING': 1.5,
                'SHOOTER': 1.8,
                'BOMBER': 2.0,
                'LASER_ENEMY': 2.2,
                'MINION': 0.5
            };
            return scoreTable[type] || 1.0;
        }

        // Phase 6: Safety Margin ì¶©ëŒ íŒì • (2px ì—¬ìœ )
        function checkCollisionWithMargin(a, b, margin = 2) {
            return !(
                a.x + a.w + margin < b.x ||
                a.x - margin > b.x + b.w ||
                a.y + a.h + margin < b.y ||
                a.y - margin > b.y + b.h
            );
        }

        function takeDamage() {
            if (gameState.isInvincible || gameState.skillMode === 'SHIELD') return;

            if (gameState.isTransformed) {
                gameState.isTransformed = false;
                gameState.isLaserMode = false;
                gameState.laserTimer = 0;
                gameState.isLunarMode = false;  // í™©ê¸ˆ ë³€ì‹  í•´ì œ ì‹œ ë£¨ë‚˜ëª¨ë“œë„ í•¨ê»˜ í•´ì œ
                gameState.drones = [{ offsetX: -35, shootTimer: 0 }];
                gameState.isInvincible = true;
                gameState.invincibilityTimer = 1.5;
                gameState.downgradeFlash = 0.5;
                return;
            }

            if (gameState.drones.length > 0) {
                gameState.drones.pop();
                return;
            }

            // [CDSO ìˆ˜ì •] ë³¸ì²´ í”¼ê²© ì‹œ ì²˜ë¦¬
            gameState.lives--;
            gameState.isLunarMode = false; // â˜… í•µì‹¬: ë³¸ì²´ê°€ ë§ìœ¼ë©´ ë£¨ë‚˜ ê°€ë””ì–¸ íŒŒê´´ë¨

            updateLivesUI();
            if (gameState.lives <= 0) gameOver();
            else { gameState.isInvincible = true; gameState.invincibilityTimer = 2.0; }
        }

        function updateLivesUI() {
            document.getElementById('lives').textContent = `LIVES: ${'â™¥'.repeat(gameState.lives)}${'â™¡'.repeat(gameState.maxLives - gameState.lives)}`;
        }

        function updateDrones(dt) {
            if (gameState.isTransformed) return;
            gameState.drones.forEach(drone => {
                drone.shootTimer += dt;
                if (drone.shootTimer > 0.5) {
                    gameState.bullets.push({ x: gameState.player.x + 10 + drone.offsetX - 4, y: gameState.player.y, w: 8, h: 15, speed: 650 });
                    drone.shootTimer = 0;
                }
            });
        }

        window.addEventListener('keydown', e => {
            gameState.keys[e.key] = true;
            // Space í‚¤ë¡œ í•„ì‚´ê¸° ë°œë™
            if (e.code === 'Space' && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                activateRainbowWave();
            }
        });
        window.addEventListener('keyup', e => gameState.keys[e.key] = false);

        // ëª¨ë°”ì¼ í„°ì¹˜ ì¢Œí‘œ ë³€í™˜
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = e.touches[0];
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ (ì œìŠ¤ì²˜ ì°¨ë‹¨ + ë¶€ë“œëŸ¬ìš´ ì¶”ì )
        let isTouching = false;
        // [CDSO ì „ëµ ìˆ˜ì •] í•˜ì´ë¸Œë¦¬ë“œ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì‹œìŠ¤í…œ
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        // [CDSO ìµœì¢… ìˆ˜ì •] í„°ì¹˜ í•¸ë“¤ëŸ¬: í•˜ë‹¨ 10% í•„ì‚´ê¸° / ìƒë‹¨ 90% ì´ë™
        function handleTouch(e) {
            e.preventDefault();
            
            if (controlMode === 'TRACKING') {
                // [ëª¨ë“œ A] ì¶”ì  ëª¨ë“œ
                const pos = getTouchPos(e);
                gameState.touchTarget = pos.x - gameState.player.w / 2;
                
                // ì¶”ì  ëª¨ë“œì—ì„œë„ í•˜ë‹¨ 10%ë¥¼ ëˆ„ë¥´ë©´ í•„ì‚´ê¸° ë°œë™ (í†µì¼ì„± ìœ ì§€)
                if (pos.y > canvas.height * 0.90 && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                    activateRainbowWave();
                }

            } else {
                // [ëª¨ë“œ B] ë²„íŠ¼ ëª¨ë“œ
                gameState.keys['ArrowLeft'] = false;
                gameState.keys['ArrowRight'] = false;
                gameState.touchTarget = null; 

                const halfWidth = window.innerWidth / 2;
                // í•˜ë‹¨ 15% ë†’ì´ ê³„ì‚° (0.1 ~ 0.15 ì¶”ì²œ)
                const ultZoneY = window.innerHeight * 0.9; 

                // ë©€í‹°í„°ì¹˜ ë£¨í”„
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];

                    // 1. í•„ì‚´ê¸° ì˜ì—­ ì²´í¬ (í™”ë©´ í•˜ë‹¨ 15%)
                    // ê²Œì´ì§€ê°€ ìˆëŠ” ì•„ë˜ìª½ì„ ëˆ„ë¥´ë©´ ë°œë™
                    if (t.clientY > ultZoneY) {
                        if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                            activateRainbowWave();
                        }
                        continue; // í•„ì‚´ê¸° ëˆ„ë¥¸ ì†ê°€ë½ì€ ì´ë™ì— ì˜í–¥ ì£¼ì§€ ì•ŠìŒ
                    }

                    // 2. ì´ë™ ì˜ì—­ ì²´í¬ (í™”ë©´ ìƒë‹¨ 85%)
                    // ë‚˜ë¨¸ì§€ ë„“ì€ í™”ë©´ì„ ì¢Œìš° ë²„íŠ¼ìœ¼ë¡œ ì‚¬ìš©
                    if (t.clientX < halfWidth) {
                        gameState.keys['ArrowLeft'] = true;
                    } else {
                        gameState.keys['ArrowRight'] = true;
                    }
                }
            }
        }





        // í„°ì¹˜ ì¢…ë£Œ ì²˜ë¦¬
        function handleTouchEnd(e) {
            e.preventDefault();
            
            if (controlMode === 'TRACKING') {
                // ì¶”ì  ëª¨ë“œëŠ” ì†ì„ ë–¼ë©´ ë©ˆì¶¤ (ë§ˆì§€ë§‰ ìœ„ì¹˜ ìœ ì§€)
                // gameState.touchTarget = null; // ì›í•˜ë©´ ì´ ì£¼ì„ í•´ì œí•˜ì—¬ ë©ˆì¶”ê²Œ ê°€ëŠ¥
            } else {
                // ë²„íŠ¼ ëª¨ë“œëŠ” ì†ì„ ë–¼ë©´ í‚¤ ì…ë ¥ í•´ì œ (ë‚¨ì€ í„°ì¹˜ ë‹¤ì‹œ ê³„ì‚°)
                if (e.touches.length === 0) {
                    gameState.keys['ArrowLeft'] = false;
                    gameState.keys['ArrowRight'] = false;
                } else {
                    handleTouch(e); // ì•„ì§ ë‹¤ë¥¸ ì†ê°€ë½ì´ ë¶™ì–´ìˆìœ¼ë©´ ì¬ê³„ì‚°
                }
            }
        }





        // ìë™ ì¼ì‹œì •ì§€ (ì „í™”/í™ˆ í™”ë©´ ì „í™˜ ì‹œ)
        document.addEventListener('visibilitychange', function () {
            if (document.hidden && gameState.isRunning) {
                gameState.isRunning = false;
                document.getElementById('start-screen').style.display = 'flex';
                document.querySelector('#start-screen h1').textContent = 'PAUSED';
                document.querySelector('#start-screen button').textContent = 'RESUME';
            }
        });

        function startGame() {
        // [ì¶”ê°€] ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ì´ì „ ë­í‚¹ í‘œì‹œìš© ë°ì´í„° ì •ë¦¬
        // [ìˆ˜ì •] í‚¤ê°’ ë³€ê²½ ë° ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸°
            localStorage.removeItem('myBestRecord');
            const myRankList = document.getElementById('my-rank-list');
            if(myRankList) myRankList.style.display = 'none';

            document.getElementById('start-screen').style.display = 'none';
            resetState();
            gameState.isRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function resetState() {
            Object.assign(gameState, {
                score: 0, enemies: [], items: [], bullets: [],
                skillMode: 'NORMAL', skillTimer: 0, spawnTimer: 0, itemSpawnTimer: 0,
                lives: 3, isInvincible: false, invincibilityTimer: 0, drones: [],
                isTransformed: false, isLaserMode: false, laserTimer: 0, isLunarMode: false,
                currentStage: 1, stageTimer: 30, boss: null,
                stageClearing: false, stageClearTimer: 0, survivalMode: false,
                bossPhase: 'MINION', bossTimer: 0, bossResurrected: false,
                downgradeFlash: 0, progressDisplay: 0, survivalStartCount: 0,
                spawnDelay: 1.0,
                stageTimerEnded: false, survivalTimer: 0, pendingBoss: null,
                // ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤ ì´ˆê¸°í™”
                ultGauge: 0, autoFireTimer: 0,
                isHomingMode: false, homingTimer: 0,
                rainbowWave: null, dangerWarning: 0, timeBonusDisplay: null,
                // [CDSO ì¶”ê°€] ë°ì´í„° ë¶„ì„ìš© ë³€ìˆ˜ ì´ˆê¸°í™”
                startTime: Date.now(),      // ê²Œì„ ì‹œì‘ ì‹œê°„
                totalItemsSpawned: 0,       // ìƒì„±ëœ ì´ ì•„ì´í…œ ìˆ˜
                itemsCollected: 0,          // íšë“í•œ ì•„ì´í…œ ìˆ˜
                lastHitBy: 'UNKNOWN',       // ë§ˆì§€ë§‰ í”¼ê²© ì›ì¸ (ì‚¬ë§ ì›ì¸)
                deathCoords: { x: 0, y: 0 } // ì‚¬ë§ ì¢Œí‘œ

            });
            gameState.player.x = 215;
            updateLivesUI();
            // [ìˆ˜ì •] my-rankê°€ ì•„ë‹ˆë¼ my-rank-listë¥¼ ìˆ¨ê²¨ì•¼ ì—ëŸ¬ê°€ ì•ˆ ë‚©ë‹ˆë‹¤!
            const myRankList = document.getElementById('my-rank-list');
            if (myRankList) myRankList.style.display = 'none';
        }




        function spawnEntities(dt) {
            if (gameState.spawnDelay > 0) {
                gameState.spawnDelay -= dt;
                return;
            }

            const lvl = levels[gameState.currentStage - 1];

            // [CDSO ì „ëµ] ë³´ìŠ¤ì „ ì „ìš© ë¡œì§
            if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) {
                gameState.spawnTimer += dt;
                
                // ë³´ìŠ¤ ì¢…ë¥˜ë³„ ì«„ëª¹ ì†Œí™˜
                let spawnInterval = 2.5; 
                let eliteTypes = [];

                if (gameState.boss.type === 'LUNAR') {
                    spawnInterval = 2.2; eliteTypes = ['HOMING', 'ZIGZAG'];
                } else if (gameState.boss.type === 'SUN') {
                    spawnInterval = 3.0; eliteTypes = ['SHOOTER', 'BOMBER', 'LASER_ENEMY'];
                }

                if (gameState.bossResurrected) spawnInterval *= 0.7;

                if (gameState.spawnTimer > spawnInterval) {
                    const type = eliteTypes[Math.floor(Math.random() * eliteTypes.length)];
                    gameState.enemies.push({
                        x: Math.random() * (canvas.width - 30), y: -35, 
                        w: 25, h: 25, speed: 200 + Math.random() * 50, type: type,
                        amplitude: 1, turnRate: 100, time: 0,
                        exploded: false, locked: false, fired: false, chargeTimer: 0,
                        phase: 'ENTER', strafeDir: Math.random() < 0.5 ? 1 : -1
                    });
                    gameState.spawnTimer = 0;
                }

                // ë³´ìŠ¤ì „ ì•„ì´í…œ (í•˜íŠ¸ í¬ì†Œì„± ìœ ì§€: 10%)
                gameState.itemSpawnTimer += dt;
                if (gameState.itemSpawnTimer > 6) { 
                    const rand = Math.random();
                    let itemType = rand < 0.5 ? 'BLASTER' : (rand < 0.9 ? 'SHIELD' : 'LIFE');
                    gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type: itemType });

                    gameState.totalItemsSpawned++; // [ì¶”ê°€] ìƒì„± ì¹´ìš´íŠ¸ ì¦ê°€
                    gameState.itemSpawnTimer = 0;
                }
                return;
            }

            if (gameState.stageClearing || gameState.survivalMode) return;

            // ì¼ë°˜ ìŠ¤í…Œì´ì§€ ì  ì†Œí™˜
            gameState.spawnTimer += dt;
            if (gameState.spawnTimer > lvl.spawnRate && lvl.types.length > 0) {
                const type = lvl.types[Math.floor(Math.random() * lvl.types.length)];
                gameState.enemies.push({
                    x: Math.random() * (canvas.width - 24), y: -32, w: 24, h: 24,
                    speed: (200 + Math.random() * 100) * lvl.speedMult, type,
                    amplitude: Math.random() * 2 + 1, turnRate: 120 + Math.random() * 60, time: 0
                });
                gameState.spawnTimer = 0;
            }

            // ì¼ë°˜ ìŠ¤í…Œì´ì§€ ì•„ì´í…œ ì†Œí™˜ (í•˜íŠ¸ í™•ë¥  30% ì ìš©)
            gameState.itemSpawnTimer += dt;
            if (gameState.itemSpawnTimer > 8) {
                const rand = Math.random();
                let type = rand < 0.25 ? 'DRONE' : (rand < 0.5 ? 'SHIELD' : 'BLASTER');
                
                // ìŠ¤í…Œì´ì§€ 6, 9ì—ì„œ í•˜íŠ¸ ë“±ì¥ í™•ë¥  30%
                if (gameState.currentStage === 6 || gameState.currentStage === 9) {
                    if (Math.random() < 0.3) type = 'LIFE';
                }

                gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type });
                gameState.totalItemsSpawned++; // [ì¶”ê°€] ìƒì„± ì¹´ìš´íŠ¸ ì¦ê°€
                gameState.itemSpawnTimer = 0;
            }
        }



        function spawnBoss(hp, type) {
            const isLunar = type === 'LUNAR';
            const w = isLunar ? 115 : 100;  // ë£¨ë‚˜ 15% í¬ê¸° ì¦ê°€
            const h = isLunar ? 92 : 80;
            gameState.boss = {
                x: canvas.width / 2 - w / 2, y: 50, w, h,
                hp, maxHp: hp, moveDir: 1, shootTimer: 0, type: type || 'LUNAR',
                isSupernova: false, shockwaveTimer: 0
            };
            // gameState.enemies = [];
            gameState.bossTimer = 0;
            gameState.spawnTimer = 0;
        }

        function triggerBigBang() {
            const boss = gameState.boss;
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            for (let i = 0; i < 24; i++) {
                const rad = (i * 15) * Math.PI / 180;
                const speed = 200 + Math.random() * 100;
                gameState.enemies.push({
                    x: cx - 6, y: cy,
                    w: 12, h: 12, speed: 0, type: 'BULLET',
                    vx: Math.cos(rad) * speed, vy: Math.sin(rad) * speed,
                    amplitude: 0, turnRate: 0, time: 0
                });
            }
        }

        function updateBoss(dt) {
            const boss = gameState.boss;
            if (!boss) return;

            gameState.bossTimer += dt;
            boss.x += boss.moveDir * 120 * dt;
            if (boss.x <= 0 || boss.x >= canvas.width - boss.w) boss.moveDir *= -1;
            boss.shootTimer += dt;

            if (boss.type === 'LUNAR') {
                // ìœ ì„± ê³µê²© (METEOR)
                if (boss.shootTimer > 1.8) {
                    for (let angle = -30; angle <= 30; angle += 30) {
                        const rad = (90 + angle) * Math.PI / 180;
                        gameState.enemies.push({
                            x: boss.x + boss.w / 2 - 14, y: boss.y + boss.h,
                            w: 28, h: 28, speed: 0, type: 'METEOR',
                            vx: Math.cos(rad) * 180, vy: Math.sin(rad) * 180,
                            amplitude: 0, turnRate: 0, time: 0
                        });
                    }
                    boss.shootTimer = 0;
                }
                // ì›”ê´‘ ì¶©ê²©íŒŒ (3ì´ˆë§ˆë‹¤) + DANGER ê²½ê³ 
                boss.shockwaveTimer += dt;

                // ì¶©ê²©íŒŒ ë°œì‚¬ 0.5ì´ˆ ì „ DANGER ê²½ê³  ì‹œì‘
                if (boss.shockwaveTimer > 2.5 && boss.shockwaveTimer <= 3) {
                    gameState.dangerWarning = 0.5 - (3 - boss.shockwaveTimer);
                }

                if (boss.shockwaveTimer > 3) {
                    const px = gameState.player.x + gameState.player.w / 2;
                    const bx = boss.x + boss.w / 2, by = boss.y + boss.h;
                    const dx = px - bx, dy = gameState.player.y - by;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    gameState.enemies.push({
                        x: bx - 10, y: by,
                        w: 20, h: 20, speed: 0, type: 'SHOCKWAVE',
                        vx: (dx / dist) * 350, vy: (dy / dist) * 350,
                        amplitude: 0, turnRate: 0, time: 0
                    });
                    boss.shockwaveTimer = 0;
                    gameState.dangerWarning = 0;  // ê²½ê³  ì¢…ë£Œ
                }
            } else if (boss.type === 'SUN') {
                // [CDSO ì „ëµ ìˆ˜ì •] ë‚œì´ë„ ëŒ€í­ ìƒí–¥: Spinning Inferno íŒ¨í„´
                // 1. ë°œì‚¬ ì†ë„: 2í˜ì´ì¦ˆ(Supernova)ì—ì„œëŠ” 0.7ì´ˆë§ˆë‹¤ ë‚œì‚¬ (ê¸°ì¡´ 1.5ì´ˆ)
                const fireRate = boss.isSupernova ? 0.7 : 1.6;
                
                // 2. íƒ„ë§‰ ë°€ë„: 2í˜ì´ì¦ˆì—ì„œëŠ” 24ë°œ (ê¸°ì¡´ 16ë°œ)
                const bulletCount = boss.isSupernova ? 24 : 14;

                if (boss.shootTimer > fireRate) {
                    // 3. íšŒì „ ë¡œì§: ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë°œì‚¬ ê°ë„ê°€ ëŒì•„ê° (ë‚˜ì„ í˜• íŒ¨í„´)
                    // Supernova ìƒíƒœì¼ ë•ŒëŠ” íšŒì „ ì†ë„ 3ë°° ì¦ê°€
                    const spinSpeed = boss.isSupernova ? 150 : 40;
                    const baseAngle = (Date.now() / 1000) * spinSpeed;

                    for (let i = 0; i < bulletCount; i++) {
                        // ê¸°ë³¸ ê°ë„ + íšŒì „ ê°ë„ ì ìš©
                        const angle = baseAngle + (i * (360 / bulletCount));
                        const rad = angle * Math.PI / 180;

                        // 4. ë³€ì¹™ ì†ë„ (Variable Velocity): 
                        // 2í˜ì´ì¦ˆì—ì„œëŠ” ì§ìˆ˜/í™€ìˆ˜ ë²ˆì§¸ íƒ„í™˜ì˜ ì†ë„ë¥¼ ë‹¤ë¥´ê²Œ í•˜ì—¬ 'íƒ„ë§‰ ë²½'ì„ í˜•ì„±
                        let bSpeed = boss.isSupernova ? 240 : 190;
                        if (boss.isSupernova && i % 2 === 0) {
                            bSpeed += 120; // ì§ìˆ˜ íƒ„í™˜ì€ í›¨ì”¬ ë¹ ë¥´ê²Œ ë°œì‚¬ (360) -> ì—‡ë°•ì ìœ ë°œ
                        }

                        gameState.enemies.push({
                            x: boss.x + boss.w / 2 - 6, y: boss.y + boss.h / 2,
                            w: 12, h: 12, speed: 0, type: 'BULLET',
                            vx: Math.cos(rad) * bSpeed,
                            vy: Math.sin(rad) * bSpeed,
                            amplitude: 0, turnRate: 0, time: 0
                        });
                    }
                    boss.shootTimer = 0;
                }
            }

            if (gameState.isLaserMode) {
                const laserL = gameState.player.x + gameState.player.w / 2 - 20;
                const laserR = gameState.player.x + gameState.player.w / 2 + 20;
                if (boss.x + boss.w > laserL && boss.x < laserR) {
                    boss.hp -= dt * 8;
                    gameState.score += Math.floor(dt * 10);
                }
            }

            for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                if (checkRectCollision(gameState.bullets[bi], boss)) {
                    boss.hp--; gameState.bullets.splice(bi, 1); gameState.score += 5;
                }
            }

            if (boss.hp <= 0) {
                if (boss.type === 'SUN' && !gameState.bossResurrected) {
                    triggerBigBang();
                    boss.hp = boss.maxHp * 0.5;
                    boss.isSupernova = true;
                    gameState.bossResurrected = true;
                } else {
                    // [CDSO ì „ëµ ìˆ˜ì •] ë³´ìŠ¤ ë“±ê¸‰ë³„ ì°¨ë“± ë³´ìƒ ì‹œìŠ¤í…œ (Tiered Scoring)
                    
                    let baseClearScore = 0;
                    let timeBonus = 0;
                    let perfectBonus = 0;
                    let timeLimitS = 0; // Së“±ê¸‰ ê¸°ì¤€ ì‹œê°„
                    let timeLimitA = 0; // Aë“±ê¸‰ ê¸°ì¤€ ì‹œê°„

                    // 1. ë³´ìŠ¤ íƒ€ì…ë³„ ê¸°ì¤€ ì„¤ì • (Configuration)
                    if (boss.type === 'LUNAR') {
                        // [Stage 5] ì¤‘ê°„ ë³´ìŠ¤: íƒ€ì´íŠ¸í•œ ì‹œê°„ ì œí•œ, ì ë‹¹í•œ ë³´ìƒ
                        baseClearScore = 300;
                        timeLimitS = 15; // 25ì´ˆ ì»· (Speed)
                        timeLimitA = 25; 
                        
                        if (gameState.bossTimer <= timeLimitS) timeBonus = 300;
                        else if (gameState.bossTimer <= timeLimitA) timeBonus = 200;
                        else timeBonus = 100;

                    } else {
                        // [Stage 10] ìµœì¢… ë³´ìŠ¤: ë„‰ë„‰í•œ ì‹œê°„ ì œí•œ, ì••ë„ì ì¸ ë³´ìƒ
                        baseClearScore = 1000; // ì—”ë”© ë³´ìƒ ìƒí–¥
                        timeLimitS = 30; // 50ì´ˆ ì»· (Endurance)
                        timeLimitA = 50;

                        if (gameState.bossTimer <= timeLimitS) timeBonus = 700; // Legendary
                        else if (gameState.bossTimer <= timeLimitA) timeBonus = 400;
                        else timeBonus = 200;
                    }

                    // 2. ë…¸ë¯¸ìŠ¤ ë³´ë„ˆìŠ¤ (ê³µí†µ ë¡œì§)
                    // ìµœì¢… ë³´ìŠ¤ëŠ” ì–´ë µê¸° ë•Œë¬¸ì— ë…¸ë¯¸ìŠ¤ ê°€ì‚°ì ì„ ë” ë†’ê²Œ ì±…ì •
                    if (gameState.lives >= gameState.maxLives) { // ë§Œí”¼ì¼ ë•Œ
                        perfectBonus = (boss.type === 'SUN') ? 1000 : 500;
                    }

                    // 3. ìµœì¢… í•©ì‚°
                    const totalBonus = baseClearScore + timeBonus + perfectBonus;
                    gameState.score += totalBonus;
                    
                    // 4. ê²°ê³¼ í‘œì‹œ (UI Feedback)
                    // ë“±ê¸‰ í‘œì‹œ (S, A, B)
                    let rankText = gameState.bossTimer <= timeLimitS ? "RANK S" : (gameState.bossTimer <= timeLimitA ? "RANK A" : "RANK B");
                    
                    // ë³´ë„ˆìŠ¤ ì •ë³´ë¥¼ í™”ë©´ì— ë³´ì—¬ì£¼ê¸° ìœ„í•´ ê°ì²´ì— ì €ì¥
                    gameState.timeBonusDisplay = { 
                        amount: totalBonus, 
                        text: `${rankText} BONUS`, // í™”ë©´ì— S, A, B ë“±ê¸‰ë„ ê°™ì´ í‘œì‹œ
                        timer: 3.0 
                    };

                    // ë£¨ë‚˜ ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ ë£¨ë‚˜ ëª¨ë“œ í™œì„±í™” (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                    if (boss.type === 'LUNAR') {
                        gameState.isLunarMode = true;
                    }
                    triggerStageClear();
                }


                return;
            }

            if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, boss)) {
                gameState.lastHitBy = boss.type + '_BODY'; // [ì¶”ê°€] ë³´ìŠ¤ ëª¸í†µ ì¶©ëŒ ê¸°ë¡
                takeDamage();
            }
        }

        function triggerStageClear() {
            gameState.stageClearing = true;
            gameState.stageClearTimer = 1.0;  // ìŠ¤í…Œì´ì§€ ë¬¸êµ¬ 1ì´ˆ
            gameState.boss = null;
            gameState.survivalMode = false;
            gameState.bossPhase = 'MINION';
            gameState.bossResurrected = false;
            // Phase 3: pendingBoss ë¡œì§ ì œê±° - spawnBoss ì§ì ‘ í˜¸ì¶œ ë°©ì‹ ì‚¬ìš©
        }

        // Phase 5: ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ í†µí•© í•¨ìˆ˜
        function handleStageTransition(dt) {
            const lvl = levels[gameState.currentStage - 1];

            // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì²˜ë¦¬
            if (gameState.stageClearing) {
                gameState.stageClearTimer -= dt;
                if (gameState.stageClearTimer <= 0) {
                    gameState.enemies = [];
                    advanceStage();
                }
                return;
            }

            // ë³´ìŠ¤ ìŠ¤í…Œì´ì§€
            if (lvl.isBoss) {
                if (gameState.bossPhase === 'MINION') {
                    gameState.stageTimer -= dt;
                    if (gameState.stageTimer <= 0) {
                        gameState.bossPhase = 'BOSS';
                        gameState.stageTimerEnded = true;
                        spawnBoss(lvl.bossHP, lvl.bossType);
                    }
                } else if (gameState.bossPhase === 'BOSS') {
                    updateBoss(dt);
                }
                return;
            }

            // ì¼ë°˜ ìŠ¤í…Œì´ì§€
            if (!gameState.stageTimerEnded) {
                gameState.stageTimer -= dt;
                if (gameState.stageTimer <= 0) {
                    gameState.stageTimerEnded = true;
                }
            }

            if (gameState.stageTimerEnded && !gameState.survivalMode && getActiveEnemyCount() === 0) {
                gameState.survivalMode = true;
                gameState.survivalTimer = 0.7;
                gameState.enemies = [];
            }

            if (gameState.survivalMode) {
                gameState.survivalTimer -= dt;
                if (gameState.survivalTimer <= 0) {
                    triggerStageClear();
                }
            }
        }

        function advanceStage() {
            if (gameState.currentStage >= 10) { gameComplete(); return; }
            gameState.currentStage++;
            const lvl = levels[gameState.currentStage - 1];
            gameState.stageTimer = lvl.duration;
            gameState.stageClearing = false;
            gameState.survivalMode = false;
            gameState.stageTimerEnded = false;  // â˜… ì¶”ê°€
            gameState.survivalTimer = 0;        // â˜… ì¶”ê°€
            gameState.spawnTimer = 0;

            // [CDSO ìˆ˜ì •] ìŠ¤í…Œì´ì§€ ì „í™˜ ì‹œ ì•„ì´í…œ íƒ€ì´ë¨¸ ì´ˆê¸°í™” (ì¤‘ë³µ ë“±ì¥ ë°©ì§€)
            gameState.itemSpawnTimer = 0;
            
            gameState.bossPhase = 'MINION';
            gameState.bossResurrected = false;
            gameState.progressDisplay = 0;
            gameState.enemies = [];
            gameState.items = [];
            gameState.spawnDelay = 0.8;
        }

        function showResultScreen(title) {
            const finalScore = Math.round(gameState.score);  // ì†Œìˆ˜ì  ë°˜ì˜¬ë¦¼
            document.getElementById('res-title').textContent = title;
            document.getElementById('res-stage').textContent = gameState.currentStage;
            document.getElementById('res-score').textContent = finalScore;

            const screen = document.getElementById('rank-input-screen');
            screen.style.display = 'flex';
            screen.classList.add('show');

            // ì…ë ¥ì°½ í¬ì»¤ìŠ¤
            setTimeout(() => document.getElementById('initial-input').focus(), 300);
        }

        function gameComplete() {
            gameState.isRunning = false;
            showResultScreen('ğŸ‰ MISSION COMPLETE');
        }

        // ë¬´ì§€ê°œ íŒŒë™ ë°œë™
        function activateRainbowWave() {
            gameState.rainbowWave = { active: true, y: canvas.height };
            gameState.ultGauge = 0;
        }

        // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ìœ ë„íƒ„ìš©)
        function findNearestEnemy() {
            const px = gameState.player.x + gameState.player.w / 2;
            const py = gameState.player.y;
            let nearest = null;
            let minDist = Infinity;

            // [ì¶”ê°€ëœ ë¡œì§] ë³´ìŠ¤ê°€ ì¡´ì¬í•˜ë©´ ì¼ë‹¨ ê°€ì¥ ê°€ê¹Œìš´ ì ìœ¼ë¡œ ì„¤ì •
            if (gameState.boss) {
                const bx = gameState.boss.x + gameState.boss.w / 2;
                const by = gameState.boss.y + gameState.boss.h / 2;
                // í”Œë ˆì´ì–´ì™€ ë³´ìŠ¤ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                const dist = Math.sqrt(Math.pow(px - bx, 2) + Math.pow(py - by, 2));
                minDist = dist;
                nearest = gameState.boss;
            }

            // ê¸°ì¡´ ì ë“¤ê³¼ ê±°ë¦¬ ë¹„êµ (ë³´ìŠ¤ë³´ë‹¤ ë” ê°€ê¹Œìš´ ì ì´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ë³€ê²½)
            for (const en of gameState.enemies) {
            if (en.y < py && en.type !== 'BULLET' && en.type !== 'ENEMY_BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'METEOR') {
                const ex = en.x + en.w / 2;
                const ey = en.y + en.h / 2;
                const dist = Math.sqrt(Math.pow(px - ex, 2) + Math.pow(py - ey, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = en;
                }
            }
        }
            return nearest;
        }

        function update(dt) {
            if (!gameState.isRunning) return;
            const lvl = levels[gameState.currentStage - 1];

            // í•„ì‚´ê¸° ê²Œì´ì§€ ì¶©ì „ (dt * 0.05, ì•½ 20ì´ˆì— ì™„ì¶©)
            if (gameState.ultGauge < 1 && !gameState.rainbowWave) {
                gameState.ultGauge = Math.min(1, gameState.ultGauge + dt * 0.05);
            }

            // ìƒì‹œ ìë™ ê³µê²© (0.4ì´ˆë§ˆë‹¤)
            gameState.autoFireTimer += dt;
            if (gameState.autoFireTimer >= 0.4) {
                const cx = gameState.player.x + gameState.player.w / 2;
                const cy = gameState.player.y;

                if (gameState.isHomingMode) {
                    // [CDSO ì „ëµ ìˆ˜ì •] 3ê°ˆë˜ ë©€í‹° ìœ ë„íƒ„ ë°œì‚¬
                    const target = findNearestEnemy(); // ë³´ìŠ¤ ìš°ì„  ì¸ì‹ ê¸°ëŠ¥ í¬í•¨ë¨
                    
                    // ì¢Œ(-0.25), ìš°(+0.25) ë‘ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ (ì•½ 15ë„ ê°ë„)
                    [-0.25, 0.25].forEach(angle => {
                        let vx = 0, vy = -550;
                        
                        // íƒ€ê²Ÿì´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ë°©í–¥ìœ¼ë¡œ ì´ˆê¸° ë²¡í„° ì„¤ì •
                        if (target) {
                            const tx = target.x + target.w / 2;
                            const ty = target.y + target.h / 2;
                            const dx = tx - cx;
                            const dy = ty - cy;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            
                            // ê¸°ë³¸ íƒ€ê²Ÿ ë°©í–¥ ë²¡í„°
                            let dirX = dx / dist;
                            let dirY = dy / dist;

                            // ë¶€ì±„ê¼´ë¡œ ë²Œë¦¬ê¸° (íšŒì „ ë³€í™˜ í–‰ë ¬ ì ìš©)
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            vx = (dirX * cos - dirY * sin) * 550;
                            vy = (dirX * sin + dirY * cos) * 550;
                        } else {
                            // íƒ€ê²Ÿ ì—†ì„ ë• ê·¸ëƒ¥ ë¶€ì±„ê¼´ë¡œ ë‚˜ê°
                            vx = Math.sin(angle) * 550;
                            vy = -Math.cos(angle) * 550;
                        }

                        gameState.bullets.push({
                            x: cx - 5, y: cy, w: 10, h: 15, speed: 550,
                            isHoming: true, 
                            target: target, // [ì¤‘ìš”] íƒ€ê²Ÿ ê°ì²´ ìì²´ë¥¼ ì‹¬ìŒ (ì‹¤ì‹œê°„ ì¶”ì ìš©)
                            vx: vx, vy: vy,
                            turnRate: 8.0 // íšŒì „ ì†ë„ (ë†’ì„ìˆ˜ë¡ ë” ì˜ êº¾ìŒ)
                        });
                    });

                } else {
                    // ì¼ë°˜ ì§ì„  ë°œì‚¬
                    gameState.bullets.push({ x: cx - 5, y: cy, w: 10, h: 15, speed: 550 });
                }
                gameState.autoFireTimer = 0;
            }

            // ìœ ë„íƒ„ ëª¨ë“œ íƒ€ì´ë¨¸
            if (gameState.isHomingMode) {
                gameState.homingTimer -= dt;
                if (gameState.homingTimer <= 0) {
                    gameState.isHomingMode = false;
                }
            }

            // ë¬´ì§€ê°œ íŒŒë™ ì²˜ë¦¬
            if (gameState.rainbowWave) {
                gameState.rainbowWave.y -= 500 * dt;  // ì´ˆë‹¹ 500px ìƒìŠ¹

                // íŒŒë™ë³´ë‹¤ ì•„ë˜ ìˆëŠ” ëª¨ë“  ì  ì œê±°
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    if (en.y + en.h > gameState.rainbowWave.y) {
                        gameState.score += getEnemyScore(en.type) * 2;  // ë³´ë„ˆìŠ¤ ì ìˆ˜
                        gameState.enemies.splice(i, 1);
                    }
                }

                // íŒŒë™ì´ í™”ë©´ ìœ„ë¡œ ë‚˜ê°€ë©´ ì¢…ë£Œ
                if (gameState.rainbowWave.y < -50) {
                    gameState.rainbowWave = null;
                }
            }

            // í˜„ì¬ ì ìˆ˜ UI ì—…ë°ì´íŠ¸
            document.getElementById('current-score').textContent = Math.round(gameState.score);

            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= dt;
                if (gameState.invincibilityTimer <= 0) gameState.isInvincible = false;
            }

            if (gameState.downgradeFlash > 0) gameState.downgradeFlash -= dt;

            // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ íƒ€ì´ë¨¸
            if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                gameState.timeBonusDisplay.timer -= dt;
                if (gameState.timeBonusDisplay.timer <= 0) {
                    gameState.timeBonusDisplay = null;
                }
            }

            if (gameState.isLaserMode) {
                gameState.laserTimer -= dt;
                if (gameState.laserTimer <= 0) gameState.isLaserMode = false;
            }

            // Phase 5: ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ í†µí•©
            handleStageTransition(dt);

            // í”Œë ˆì´ì–´ ì´ë™ (í‚¤ë³´ë“œ ë° ë²„íŠ¼ ëª¨ë“œ)
            if ((gameState.keys['ArrowLeft'] || gameState.keys['a']) && gameState.player.x > 0)
                gameState.player.x -= gameState.player.speed * dt;
            if ((gameState.keys['ArrowRight'] || gameState.keys['d']) && gameState.player.x < canvas.width - gameState.player.w)
                gameState.player.x += gameState.player.speed * dt;

            // [ìˆ˜ì •] ëª¨ë°”ì¼ í„°ì¹˜ ë¶€ë“œëŸ¬ìš´ ì¶”ì  (TRACKING ëª¨ë“œì¼ ë•Œë§Œ ì‹¤í–‰)
            if (controlMode === 'TRACKING' && gameState.touchTarget !== null) {
                const target = Math.max(0, Math.min(canvas.width - gameState.player.w, gameState.touchTarget));
                const diff = target - gameState.player.x;
                
                // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë–¨ë¦¼ ë°©ì§€
                if (Math.abs(diff) > 2) {
                    gameState.player.x += Math.sign(diff) * gameState.player.speed * dt;
                } else {
                    gameState.player.x = target;
                }
            }

            const cx = gameState.player.x + gameState.player.w / 2;
            const cy = gameState.player.y;

            // ìŠ¤í‚¬ ëª¨ë“œ ì²˜ë¦¬
            if (gameState.skillTimer > 0) {
                gameState.skillTimer -= dt;
                document.getElementById('skill-display').textContent = `${gameState.skillMode}: ${gameState.skillTimer.toFixed(1)}s`;
            } else {
                gameState.skillMode = 'NORMAL';
                // ìœ ë„íƒ„ ëª¨ë“œ, ë ˆì´ì € ëª¨ë“œ, ë£¨ë‚˜ ëª¨ë“œ í‘œì‹œ
                let displayText = '';
                if (gameState.isHomingMode) displayText = `HOMING: ${gameState.homingTimer.toFixed(1)}s`;
                else if (gameState.isLaserMode) displayText = `LASER: ${gameState.laserTimer.toFixed(1)}s`;
                else if (gameState.isLunarMode) displayText = 'LUNAR MODE';
                document.getElementById('skill-display').textContent = displayText;
            }

            // í™©ê¸ˆ ê¸°ì²´ 3ê°ˆë˜ ê³µê²©
            if (gameState.isTransformed && !gameState.isLaserMode && Math.random() < 0.06) {
                [-15, 0, 15].forEach(ox => gameState.bullets.push({ x: cx + ox - 4, y: cy - 10, w: 8, h: 18, speed: 620 }));
            }

            updateDrones(dt);

            // ë ˆì´ì € ëª¨ë“œ ì  ì²˜ë¦¬ (SHOCKWAVE, METEORëŠ” ìƒì‡„ ë¶ˆê°€)
            if (gameState.isLaserMode) {
                const laserL = cx - 20, laserR = cx + 20;
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    if (en.type !== 'BULLET' && en.type !== 'METEOR' && en.type !== 'SHOCKWAVE' && en.x + en.w > laserL && en.x < laserR && en.y < cy) {
                        gameState.enemies.splice(i, 1);
                        gameState.score += 3;
                    }
                }
            }

            // ì  ì²˜ë¦¬ ë£¨í”„
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const en = gameState.enemies[i];

                if (en.type === 'BULLET' || en.type === 'SHOCKWAVE' || en.type === 'METEOR' || en.type === 'ENEMY_BULLET') {
                    en.x += (en.vx || 0) * dt;
                    en.y += (en.vy || 0) * dt;
                } else if (en.type === 'MINION') {
                    en.y += en.speed * dt;
                    en.time += dt * 3;
                    en.x += Math.sin(en.time) * 1.5;
                } else if (en.type === 'SHOOTER') {
                    // SHOOTER: ìƒë‹¨ ì§„ì… â†’ ì¢Œìš° ì´ë™í•˜ë©° ì—°ì† ë°œì‚¬ â†’ í•˜ê°• í‡´ì¥
                    en.phase = en.phase || 'ENTER';      // ENTER â†’ STRAFE â†’ EXIT
                    en.strafeDir = en.strafeDir || 1;    // ì¢Œìš° ì´ë™ ë°©í–¥
                    en.shotsFired = en.shotsFired || 0;  // ë°œì‚¬í•œ ì´ì•Œ ìˆ˜
                    en.setsFired = en.setsFired || 0;    // ë°œì‚¬í•œ ì„¸íŠ¸ ìˆ˜
                    en.shootTimer = en.shootTimer || 0;

                    if (en.phase === 'ENTER') {
                        // ìƒë‹¨(y=80)ê¹Œì§€ ì§„ì…
                        en.y += en.speed * dt * 0.8;
                        if (en.y >= 80) {
                            en.phase = 'STRAFE';
                            en.y = 80;
                        }
                    } else if (en.phase === 'STRAFE') {
                        // ì¢Œìš° ì´ë™í•˜ë©° 0.1ì´ˆ ê°„ê²© 5ë°œ ì—°ì† ë°œì‚¬ (ë‚œì´ë„ í•˜í–¥)
                        en.x += en.strafeDir * 200 * dt;
                        if (en.x <= 20) en.strafeDir = 1;
                        if (en.x >= canvas.width - en.w - 20) en.strafeDir = -1;

                        en.shootTimer += dt;
                        if (en.shootTimer >= 0.1 && en.shotsFired < 5) {
                            gameState.enemies.push({
                                x: en.x + en.w / 2 - 5, y: en.y + en.h,
                                w: 10, h: 10, speed: 0, type: 'ENEMY_BULLET',
                                vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                            });
                            en.shotsFired++;
                            en.shootTimer = 0;
                        }

                        // 5ë°œ ë°œì‚¬ í›„ ì„¸íŠ¸ ì™„ë£Œ
                        if (en.shotsFired >= 5) {
                            en.setsFired++;
                            en.shotsFired = 0;
                            en.shootTimer = -0.5;  // 0.5ì´ˆ ì¿¨ë‹¤ìš´

                            // 3ì„¸íŠ¸ ì™„ë£Œ ì‹œ í‡´ì¥
                            if (en.setsFired >= 3) {
                                en.phase = 'EXIT';
                            }
                        }
                    } else if (en.phase === 'EXIT') {
                        // ë¹ ë¥´ê²Œ í•˜ê°•í•˜ë©° í‡´ì¥
                        en.y += en.speed * dt * 2.5;
                    }
                } else if (en.type === 'BOMBER') {
                    // BOMBER: í™”ë©´ ì¤‘ê°„ì—ì„œ í­ë°œí•˜ë©° 8ë°©í–¥ íƒ„í™˜
                    en.y += en.speed * dt * 0.6;
                    if (en.y > 200 && !en.exploded) {
                        en.exploded = true;
                        for (let a = 0; a < 8; a++) {
                            const rad = (a * 45) * Math.PI / 180;
                            gameState.enemies.push({
                                x: en.x + en.w / 2 - 6, y: en.y + en.h / 2 - 6,
                                w: 12, h: 12, speed: 0, type: 'ENEMY_BULLET',
                                vx: Math.cos(rad) * 200, vy: Math.sin(rad) * 200,
                                amplitude: 0, turnRate: 0, time: 0
                            });
                        }
                        gameState.enemies.splice(i, 1);
                        continue;
                    }
                } else if (en.type === 'LASER_ENEMY') {
                    // LASER_ENEMY: ì •ì§€ í›„ ìˆ˜ì§ ë ˆì´ì €
                    if (!en.locked) {
                        en.y += en.speed * dt * 0.5;
                        if (en.y > 80) {
                            en.locked = true;
                            en.chargeTimer = 0;
                        }
                    } else {
                        en.chargeTimer = (en.chargeTimer || 0) + dt;
                        if (en.chargeTimer > 1.0 && !en.fired) {
                            en.fired = true;
                            // ìˆ˜ì§ ë ˆì´ì € íƒ„í™˜ ë°œì‚¬
                            for (let ly = en.y + en.h; ly < canvas.height; ly += 30) {
                                gameState.enemies.push({
                                    x: en.x + en.w / 2 - 8, y: ly,
                                    w: 16, h: 25, speed: 0, type: 'ENEMY_BULLET',
                                    vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                                });
                            }
                        }
                        if (en.chargeTimer > 1.5) {
                            gameState.enemies.splice(i, 1);
                            continue;
                        }
                    }
                } else {
                    en.y += en.speed * dt;
                    if (en.type === 'ZIGZAG') { en.time += dt * 5; en.x += Math.sin(en.time) * en.amplitude; }
                    if (en.type === 'HOMING') { en.x += Math.sign(gameState.player.x + 10 - en.x - 15) * en.turnRate * dt; }
                }

                en.x = Math.max(-20, Math.min(canvas.width + 20, en.x));

                if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, en)) {
                    gameState.enemies.splice(i, 1);
                    if (gameState.isLunarMode) { gameState.isLunarMode = false; }
                    else { 
                        gameState.lastHitBy = en.type; // [ì¶”ê°€] ì‚¬ë§ ì›ì¸ ê¸°ë¡ (ì˜ˆ: 'ZIGZAG','ENEMY_BULLET')
                        takeDamage(); }
                    continue;
                }
                // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•í™” - í™”ë©´ ë°– ì  ì¦‰ì‹œ ì œê±°
                if (en.y > canvas.height + 50 || en.y < -100 || en.x < -80 || en.x > canvas.width + 80) {
                    gameState.enemies.splice(i, 1);
                    if (en.type !== 'BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'ENEMY_BULLET' && en.type !== 'METEOR') {
                        gameState.score += getEnemyScore(en.type);
                    }
                }
            }

            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const it = gameState.items[i];
                it.y += it.speed * dt;
                if (checkRectCollision(gameState.player, it)) {
                    gameState.itemsCollected++; // [ì¶”ê°€] íšë“ ì¹´ìš´íŠ¸ ì¦ê°€

                    if (it.type === 'DRONE') {
                        if (!gameState.isTransformed) {
                            gameState.drones.push({ offsetX: (gameState.drones.length === 0 ? -1 : 1) * 35, shootTimer: 0 });
                            if (gameState.drones.length >= 3) {
                                gameState.isTransformed = true;
                                gameState.drones = [];
                            }
                        }


                    } else if (it.type === 'LIFE') {
                    // [CDSO ì¶”ê°€] í•˜íŠ¸ íšë“ ì‹œ ìƒëª…ë ¥ íšŒë³µ
                    if (gameState.lives < gameState.maxLives) {
                        gameState.lives++;
                        updateLivesUI(); // í•˜íŠ¸ UI ì¦‰ì‹œ ê°±ì‹ 
                        // íšë“ ë©”ì‹œì§€ (ì„ íƒ ì‚¬í•­)
                        gameState.skillMode = 'HEALED';
                        gameState.skillTimer = 2.0;
                    } else {
                        // ì´ë¯¸ í’€í”¼ë¼ë©´ ë³´ë„ˆìŠ¤ ì ìˆ˜
                        gameState.score += 400;
                    }



                    } else if (it.type === 'BLASTER') {
                        // BLASTER â†’ ìœ ë„íƒ„ ëª¨ë“œë¡œ ë³€ê²½ (7ì´ˆ)
                        if (gameState.isTransformed) {
                            gameState.isLaserMode = true;
                            gameState.laserTimer = 3.0;
                        } else {
                            gameState.isHomingMode = true;
                            gameState.homingTimer = 7.0;
                        }
                    } else if (it.type === 'LUNAR_ITEM') {
                        gameState.isLunarMode = true;
                    } else {
                        gameState.skillMode = it.type;
                        gameState.skillTimer = 5.0;
                    }
                    gameState.items.splice(i, 1);
                }
                if (it.y > canvas.height) gameState.items.splice(i, 1);
            }

                // ë£¨ë‚˜ ê°€ë””ì–¸ ê³µì „ ë° ì¶©ëŒ ì²˜ë¦¬
            if (gameState.isLunarMode) {
                gameState.lunarAngle += dt * 360;  // íšŒì „ ì†ë„
                const rad = gameState.lunarAngle * Math.PI / 180;
                const guardianX = cx + Math.cos(rad) * 40 - 10;
                const guardianY = cy - 15 + Math.sin(rad) * 40 - 10;
                const guardian = { x: guardianX, y: guardianY, w: 20, h: 20 };

                // ê°€ë””ì–¸ê³¼ ì  ì¶©ëŒ ì²˜ë¦¬
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    if (checkRectCollision(guardian, gameState.enemies[i])) {
                        // [CDSO ìˆ˜ì •] ì ë§Œ ì œê±°í•˜ê³  ë£¨ë‚˜ ëª¨ë“œëŠ” ìœ ì§€ (ê³µê²©í˜• ë¹„íŠ¸)
                        gameState.enemies.splice(i, 1);
                        gameState.score += 3;
                        
                        // ì‹œê°ì  íƒ€ê²©ê° ì¶”ê°€ (ì„ íƒ ì‚¬í•­)
                        // createExplosion(guardianX, guardianY); 
                        
                        break;
                    }
                }
            }

            for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                const b = gameState.bullets[bi];
                
                if (b.isLunar) {
                    b.x += (b.vx || 0) * dt;
                    b.y += (b.vy || 0) * dt;
                } else if (b.isHoming) {
                    // â˜… ì§€ëŠ¥í˜• ì¶”ì  ë¡œì§ ì‹œì‘ â˜…
                    
                    // íƒ€ê²Ÿì´ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸
                    const targetAlive = b.target && (gameState.enemies.includes(b.target) || b.target === gameState.boss) && (b.target.hp === undefined || b.target.hp > 0);

                    if (b.target && targetAlive) {
                        // 1. í˜„ì¬ ë‚´ ìœ„ì¹˜ì™€ íƒ€ê²Ÿ ìœ„ì¹˜ íŒŒì•…
                        const tx = b.target.x + b.target.w / 2;
                        const ty = b.target.y + b.target.h / 2;
                        const bx = b.x + b.w / 2;
                        const by = b.y + b.h / 2;

                        // 2. ëª©í‘œ ë°©í–¥ ê³„ì‚°
                        const dx = tx - bx;
                        const dy = ty - by;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const targetDirX = dx / dist;
                        const targetDirY = dy / dist;

                        // 3. í˜„ì¬ ì´ë™ ë°©í–¥ ê³„ì‚°
                        const currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                        const currentDirX = b.vx / currentSpeed;
                        const currentDirY = b.vy / currentSpeed;

                        // 4. ë°©í–¥ êº¾ê¸° (turnRateë§Œí¼ ë¶€ë“œëŸ½ê²Œ íšŒì „)
                        const turn = (b.turnRate || 5.0) * dt; 
                        let newDirX = currentDirX + (targetDirX - currentDirX) * turn;
                        let newDirY = currentDirY + (targetDirY - currentDirY) * turn;

                        // 5. ì†ë„ ì ìš©
                        const newLen = Math.sqrt(newDirX * newDirX + newDirY * newDirY);
                        b.vx = (newDirX / newLen) * b.speed;
                        b.vy = (newDirY / newLen) * b.speed;
                    }

                    // ê³„ì‚°ëœ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    
                } else {
                    b.y -= b.speed * dt;
                }


                if (b.y < -20 || b.y > canvas.height + 20 || b.x < -20 || b.x > canvas.width + 20) {
                    gameState.bullets.splice(bi, 1); continue;
                }
                for (let ei = gameState.enemies.length - 1; ei >= 0; ei--) {
                    const en = gameState.enemies[ei];
                    // SHOCKWAVE, METEORëŠ” ìƒì‡„ ë¶ˆê°€
                    if (en.type === 'SHOCKWAVE' || en.type === 'METEOR') continue;
                    if (checkRectCollision(b, en)) {
                        gameState.enemies.splice(ei, 1); gameState.bullets.splice(bi, 1); gameState.score += 2; break;
                    }
                }
            }

            let targetProgress = 0;
            if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) {
                targetProgress = 1 - (gameState.boss.hp / gameState.boss.maxHp);
            } else if (gameState.survivalMode) {
                targetProgress = 1 - (gameState.enemies.length / gameState.survivalStartCount);
            } else {
                targetProgress = (30 - gameState.stageTimer) / 30;
            }
            gameState.progressDisplay += (targetProgress - gameState.progressDisplay) * dt * 5;

            // íƒ€ì´ë¨¸ ìˆ¨ê¹€ - SURVIVE/BOSS í‘œì‹œë§Œ ìœ ì§€
            let stageDisplay = lvl.isBoss
                ? (gameState.bossPhase === 'BOSS' ? 'BOSS!' : (gameState.bossPhase === 'SURVIVAL' ? 'SURVIVE!' : ''))
                : (gameState.survivalMode ? 'SURVIVE!' : '');
            document.getElementById('stage-info').textContent = `STAGE ${gameState.currentStage}${stageDisplay ? ' | ' + stageDisplay : ''}`;
        }

        function checkRectCollision(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
        }

        function drawProgressBar() {
            const lvl = levels[gameState.currentStage - 1];
            const barWidth = canvas.width * 0.8;
            const barHeight = 8;  // ë” ë‘ê»ê²Œ
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 16;

            // ë°°ê²½
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // í•„ì‚´ê¸° ê²Œì´ì§€ í‘œì‹œ
            const ultProgress = Math.min(gameState.ultGauge, 1);

            if (ultProgress >= 1) {
                // ì™„ì¶© ì‹œ ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜ + ê¹œë¹¡ì„
                const grad = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                const offset = (Date.now() / 20) % 360;
                for (let i = 0; i <= 6; i++) {
                    const hue = (offset + i * 60) % 360;
                    grad.addColorStop(i / 6, `hsl(${hue}, 100%, 60%)`);
                }
                const pulse = 0.7 + Math.sin(Date.now() / 100) * 0.3;
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = grad;
            } else {
                // ì¶©ì „ ì¤‘: ë³´ë¼ìƒ‰ ê²Œì´ì§€
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#a0f';
                ctx.fillStyle = '#c4f';
            }

            ctx.fillRect(barX, barY, barWidth * ultProgress, barHeight);

            // ULT í…ìŠ¤íŠ¸ í‘œì‹œ
            ctx.shadowBlur = 0;
            ctx.fillStyle = ultProgress >= 1 ? '#fff' : '#aaa';
            ctx.font = 'bold 10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(ultProgress >= 1 ? 'ğŸŒˆ PRESS SPACE ğŸŒˆ' : `ULT: ${Math.floor(ultProgress * 100)}%`, canvas.width / 2, barY - 4);

            ctx.shadowBlur = 0;
        }

        function drawGiftBox(it) {
            const x = it.x, y = it.y, w = it.w, h = it.h;

            // [CDSO ìˆ˜ì •] LIFE ì•„ì´í…œ: í•˜íŠ¸ ë Œë”ë§
            if (it.type === 'LIFE') {
                const cx = x + w / 2;
                const cy = y + h / 2;
                const pulse = 1 + Math.sin(Date.now() / 150) * 0.15; 

                ctx.save();
                ctx.translate(cx, cy);
                // [CDSO ìˆ˜ì •] í•˜íŠ¸ í¬ê¸° 2.3ë°° í™•ëŒ€ (pulse * 2.5)
                ctx.scale(pulse * 2.3, pulse * 2.3);

                ctx.shadowBlur = 25; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.bezierCurveTo(5, -12, 12, -5, 0, 8); 
                ctx.bezierCurveTo(-12, -5, -5, -12, 0, -5); 
                ctx.fill();
                
                ctx.shadowBlur = 0; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-3, -3, 2, 0, Math.PI * 2); ctx.fill();

                ctx.restore();
                return;
            }

            // [ë³µêµ¬ë¨] LUNAR_ITEM ì²´í¬ ì¡°ê±´ë¬¸ì´ ë¹ ì ¸ìˆì—ˆìŒ!
            if (it.type === 'LUNAR_ITEM') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath();
                ctx.arc(x + w / 2, y + h / 2, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(x + w / 2 + 6, y + h / 2 - 4, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // ì¼ë°˜ ì•„ì´í…œ ë°•ìŠ¤
            const boxColor = it.type === 'DRONE' ? '#0ff' : (it.type === 'SHIELD' ? '#0f0' : '#f0f');
            ctx.shadowBlur = 12; ctx.shadowColor = boxColor;
            ctx.fillStyle = boxColor; ctx.fillRect(x + 2, y + 6, w - 4, h - 6);
            ctx.fillStyle = '#fff'; ctx.fillRect(x + w / 2 - 2, y + 6, 4, h - 6); ctx.fillRect(x + 2, y + h / 2 + 2, w - 4, 4);
            ctx.fillStyle = boxColor; ctx.fillRect(x, y + 4, w, 6);
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(x + w / 2 - 5, y + 4, 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + w / 2 + 5, y + 4, 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + w / 2, y + 2, 3, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }



        function drawAlien(en, stage) {
            const cx = en.x + en.w / 2, cy = en.y + en.h / 2;
            const isCold = stage <= 5;

            // ENEMY_BULLET ë Œë”ë§
            if (en.type === 'ENEMY_BULLET') {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f44';
                ctx.fillStyle = '#f66';
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // SHOOTER ë Œë”ë§ (ë¶‰ì€ ì‚¼ê°í˜•)
            if (en.type === 'SHOOTER') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f44';
                ctx.fillStyle = '#f66';
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy + 15);
                ctx.lineTo(cx - 12, cy - 10);
                ctx.lineTo(cx + 12, cy - 10);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
                // í¬ì‹  í‘œì‹œ
                ctx.fillRect(cx - 3, cy + 12, 6, 8);
                ctx.shadowBlur = 0;
                return;
            }

            // BOMBER ë Œë”ë§ (ì£¼í™© ì›)
            if (en.type === 'BOMBER') {
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.15;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#f80';
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(cx, cy, 14 * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // LASER_ENEMY ë Œë”ë§ (ë³´ë¼ìƒ‰ ì‚¬ê°í˜• + ì°¨ì§• íš¨ê³¼)
            if (en.type === 'LASER_ENEMY') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#a0f';
                ctx.fillStyle = '#c4f';
                ctx.fillRect(en.x, en.y, en.w, en.h);
                if (en.locked && !en.fired) {
                    // ì°¨ì§• í‘œì‹œ
                    const chargeProgress = Math.min((en.chargeTimer || 0) / 1.0, 1);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(en.x, en.y + en.h, en.w, 3);
                    ctx.fillStyle = '#f0f';
                    ctx.fillRect(en.x, en.y + en.h, en.w * chargeProgress, 3);
                }
                ctx.shadowBlur = 0;
                return;
            }

            ctx.shadowBlur = 12;
            ctx.shadowColor = isCold ? '#8ef' : '#f80';
            ctx.fillStyle = isCold ? '#aef' : '#f64';
            ctx.strokeStyle = isCold ? '#0ff' : '#f40';
            ctx.lineWidth = 2;

            ctx.beginPath();
            if (en.type === 'MINION') {
                ctx.shadowColor = '#f0f';
                ctx.fillStyle = '#f0f';
                ctx.fillRect(en.x + 4, en.y + 4, en.w - 8, en.h - 8);
                return;
            } else if (isCold) {
                if (en.type === 'HOMING') {
                    const rot = Date.now() / 200;
                    for (let i = 0; i < 6; i++) {
                        const a = rot + i * Math.PI / 3;
                        const px = cx + Math.cos(a) * 14;
                        const py = cy + Math.sin(a) * 14;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else if (en.type === 'ZIGZAG') {
                    for (let i = 0; i < 8; i++) {
                        const r = i % 2 === 0 ? 15 : 7;
                        const a = i * Math.PI / 4;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else {
                    ctx.moveTo(cx, cy - 14);
                    ctx.lineTo(cx + 11, cy);
                    ctx.lineTo(cx, cy + 14);
                    ctx.lineTo(cx - 11, cy);
                }
            } else {
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.12;
                if (en.type === 'HOMING') {
                    const rot = Date.now() / 150;
                    for (let i = 0; i < 10; i++) {
                        const r = i % 2 === 0 ? 16 * pulse : 8;
                        const a = rot + i * Math.PI / 5;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else if (en.type === 'ZIGZAG') {
                    for (let i = 0; i < 6; i++) {
                        const r = i % 2 === 0 ? 15 * pulse : 6;
                        const a = i * Math.PI / 3 - Math.PI / 2;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else {
                    ctx.moveTo(cx, cy + 14 * pulse);
                    ctx.lineTo(cx - 13, cy - 9);
                    ctx.lineTo(cx, cy - 4);
                    ctx.lineTo(cx + 13, cy - 9);
                }
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }

        function drawLunarBoss(boss) {
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            ctx.shadowBlur = 40; ctx.shadowColor = '#88f';
            ctx.fillStyle = '#aaf';
            ctx.beginPath(); ctx.arc(cx, cy, 45, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#669';
            [[20, -12, 9], [35, 15, 7], [-15, 8, 8], [-25, -5, 5]].forEach(([ox, oy, r]) => {
                ctx.beginPath(); ctx.arc(cx + ox, cy + oy, r, 0, Math.PI * 2); ctx.fill();
            });
            ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
            ctx.fillStyle = '#4af'; ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText('LUNAR', cx, boss.y - 7);
        }

        function drawSunBoss(boss) {
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            ctx.shadowBlur = boss.isSupernova ? 80 : 60;
            ctx.shadowColor = boss.isSupernova ? '#f0f' : '#f80';
            const grad = ctx.createRadialGradient(cx, cy, 15, cx, cy, 50);
            if (boss.isSupernova) {
                grad.addColorStop(0, '#fff'); grad.addColorStop(0.5, '#f0f'); grad.addColorStop(1, '#80f');
            } else {
                grad.addColorStop(0, '#ff0'); grad.addColorStop(0.6, '#f80'); grad.addColorStop(1, '#f00');
            }
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, 48, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = boss.isSupernova ? '#f8f' : '#fa0'; ctx.lineWidth = 4;
            for (let i = 0; i < 12; i++) {
                const a = (i * 30 + Date.now() / 25) * Math.PI / 180;
                ctx.beginPath(); ctx.moveTo(cx + Math.cos(a) * 48, cy + Math.sin(a) * 48);
                ctx.lineTo(cx + Math.cos(a) * 72, cy + Math.sin(a) * 72); ctx.stroke();
            }
            ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
            ctx.fillStyle = boss.isSupernova ? '#f0f' : '#f40';
            ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText(boss.isSupernova ? 'SUPERNOVA' : 'SUN', cx, boss.y - 7);
        }

        function drawLaser() {
            if (!gameState.isLaserMode) return;
            const cx = gameState.player.x + gameState.player.w / 2;
            const laserWidth = 40;

            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0';
            const grad = ctx.createLinearGradient(cx - laserWidth / 2, 0, cx + laserWidth / 2, 0);
            grad.addColorStop(0, 'rgba(255,255,0,0.3)');
            grad.addColorStop(0.5, 'rgba(255,255,0,0.9)');
            grad.addColorStop(1, 'rgba(255,255,0,0.3)');
            ctx.fillStyle = grad;
            ctx.fillRect(cx - laserWidth / 2, 0, laserWidth, gameState.player.y);

            ctx.fillStyle = '#fff';
            ctx.fillRect(cx - 5, 0, 10, gameState.player.y);
            ctx.shadowBlur = 0;
        }

        function draw() {
            const lvl = levels[gameState.currentStage - 1];
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // stageClearing ì¤‘ì—ë„ ì•„ë˜ ë Œë”ë§ ê³„ì† ì‹¤í–‰ (ì•„ì´í…œ íšë“ ìœ„í•´)
            if (gameState.stageClearing) {
                const nextStage = gameState.currentStage + 1;
                ctx.fillStyle = lvl.theme; ctx.font = 'bold 36px Orbitron'; ctx.textAlign = 'center';
                ctx.shadowBlur = 20; ctx.shadowColor = lvl.theme;
                ctx.fillText(nextStage <= 10 ? `NEXT: STAGE ${nextStage}` : 'ğŸ‰ VICTORY!', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
                // return ì œê±° - ì•„ë˜ ë Œë”ë§ ê³„ì†
            }

            // SURVIVE ë¬¸êµ¬ í‘œì‹œ (ì¼ë°˜ ìŠ¤í…Œì´ì§€ë§Œ)
            if (gameState.survivalMode && !lvl.isBoss) {
                ctx.fillStyle = '#f55'; ctx.font = 'bold 28px Orbitron'; ctx.textAlign = 'center';
                ctx.shadowBlur = 15; ctx.shadowColor = '#f55';
                ctx.fillText('SURVIVE!', canvas.width / 2, 80); ctx.shadowBlur = 0;
            }


            drawLaser();
            drawDrones(); drawPlayer();

            // ë£¨ë‚˜ ê°€ë””ì–¸ ë Œë”ë§
            if (gameState.isLunarMode) {
                const px = gameState.player.x + gameState.player.w / 2;
                const py = gameState.player.y;
                const rad = gameState.lunarAngle * Math.PI / 180;
                const gx = px + Math.cos(rad) * 40;
                const gy = py - 15 + Math.sin(rad) * 40;

                ctx.shadowBlur = 20;
                ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath();
                ctx.arc(gx, gy, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(gx + 5, gy - 3, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            if (gameState.boss) {
                if (gameState.boss.type === 'LUNAR') drawLunarBoss(gameState.boss);
                else if (gameState.boss.type === 'SUN') drawSunBoss(gameState.boss);

                // DANGER ê²½ê³  í‘œì‹œ (LUNAR ë³´ìŠ¤)
                if (gameState.dangerWarning > 0 && gameState.boss.type === 'LUNAR') {
                    const blink = Math.floor(Date.now() / 100) % 2 === 0;
                    if (blink) {
                        ctx.fillStyle = '#f00';
                        ctx.font = 'bold 16px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#f00';
                        ctx.fillText('âš  DANGER âš ', gameState.boss.x + gameState.boss.w / 2, gameState.boss.y - 35);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            gameState.enemies.forEach(en => {
                if (en.type === 'BULLET') {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = gameState.currentStage <= 5 ? '#8af' : '#f84';
                    ctx.fillStyle = ctx.shadowColor;
                    ctx.beginPath(); ctx.arc(en.x + en.w / 2, en.y + en.h / 2, en.w / 2, 0, Math.PI * 2); ctx.fill();
                } else if (en.type === 'SHOCKWAVE') {
                    // ì›”ê´‘ ì¶©ê²©íŒŒ ë Œë”ë§ + ë°˜ì§ì„ íš¨ê³¼ (ìƒì‡„ ë¶ˆê°€ í‘œì‹œ)
                    const shimmer = 1 + Math.sin(Date.now() / 50) * 0.3;
                    ctx.shadowBlur = 15 * shimmer;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(en.x + en.w / 2, en.y + en.h / 2, (en.w / 2 + 2) * shimmer, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(en.x + en.w / 2 + 5, en.y + en.h / 2 - 3, en.w / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    // ë°˜ì§ì„ í‘œì‹œ
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('âœ¨', en.x + en.w - 5, en.y + 5);
                } else if (en.type === 'METEOR') {
                    // ìœ ì„± ë Œë”ë§ - ë¶ˆíƒ€ëŠ” ê¼¬ë¦¬ íš¨ê³¼ + ë°˜ì§ì„ (ìƒì‡„ ë¶ˆê°€)
                    const mx = en.x + en.w / 2, my = en.y + en.h / 2;
                    const shimmer = 1 + Math.sin(Date.now() / 50) * 0.2;
                    // ê¼¬ë¦¬
                    ctx.shadowBlur = 20 * shimmer;
                    ctx.shadowColor = '#f80';
                    const grad = ctx.createLinearGradient(mx, my - 15, mx, my + 25);
                    grad.addColorStop(0, 'rgba(255,100,50,0.8)');
                    grad.addColorStop(1, 'rgba(255,200,100,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(mx - 10, my);
                    ctx.lineTo(mx, my - 20);
                    ctx.lineTo(mx + 10, my);
                    ctx.fill();
                    // ë³¸ì²´
                    ctx.fillStyle = '#88f';
                    ctx.beginPath();
                    ctx.arc(mx, my, 14 * shimmer, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(mx - 3, my - 3, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // ë°˜ì§ì„ í‘œì‹œ
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('âœ¨', mx + 10, my - 10);
                    ctx.shadowBlur = 0;
                } else {
                    drawAlien(en, gameState.currentStage);
                }
            });

            gameState.items.forEach(it => drawGiftBox(it));

            ctx.shadowBlur = 5; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
            gameState.bullets.forEach(b => {
                if (b.isLunar) {
                    // í¬ë ˆì„¼íŠ¸ ë°˜ë‹¬ íƒ„í™˜
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(b.x + 6, b.y + 6, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(b.x + 9, b.y + 4, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (b.isHoming) {
                    // ìœ ë„íƒ„ - ë³´ë¼ìƒ‰ ì‚¼ê°í˜•
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#c4f';
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w / 2, b.y);
                    ctx.lineTo(b.x, b.y + b.h);
                    ctx.lineTo(b.x + b.w, b.y + b.h);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                }
            });
            ctx.shadowBlur = 0;

            // ë¬´ì§€ê°œ íŒŒë™ ë Œë”ë§
            if (gameState.rainbowWave) {
                const waveY = gameState.rainbowWave.y;
                const waveHeight = 30;

                // ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜
                const grad = ctx.createLinearGradient(0, waveY - waveHeight / 2, 0, waveY + waveHeight / 2);
                const offset = (Date.now() / 10) % 360;
                for (let i = 0; i <= 6; i++) {
                    const hue = (offset + i * 60) % 360;
                    grad.addColorStop(i / 6, `hsla(${hue}, 100%, 60%, 0.9)`);
                }

                ctx.shadowBlur = 40;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = grad;
                ctx.fillRect(0, waveY - waveHeight / 2, canvas.width, waveHeight);

                // ì¤‘ì•™ ë°ì€ ë¼ì¸
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillRect(0, waveY - 2, canvas.width, 4);
                ctx.shadowBlur = 0;
            }

            // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ
            if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                const alpha = Math.min(1, gameState.timeBonusDisplay.timer);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 24px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0';
                ctx.fillText(`TIME BONUS: +${gameState.timeBonusDisplay.amount}`, canvas.width / 2, 130);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            drawProgressBar();
        }

        function drawPlayer() {
            const p = gameState.player, cx = p.x + p.w / 2, cy = p.y + p.h / 2;

            if (gameState.isInvincible && Math.floor(gameState.invincibilityTimer * 10) % 2 === 0) ctx.globalAlpha = 0.3;
            if (gameState.downgradeFlash > 0) ctx.globalAlpha = 0.5 + Math.sin(gameState.downgradeFlash * 20) * 0.5;

            // í•„ì‚´ê¸° ê²Œì´ì§€ 100% ì‹œ ë¬´ì§€ê°œ ë°˜ì§ì„
            let playerColor;
            if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                const hue = (Date.now() / 5) % 360;  // ë¹ ë¥´ê²Œ ë¬´ì§€ê°œìƒ‰ ìˆœí™˜
                playerColor = `hsl(${hue}, 100%, 60%)`;
                ctx.shadowBlur = 40 + Math.sin(Date.now() / 100) * 10;
            } else {
                const baseColor = gameState.isTransformed ? '#FFD700' : '#C0C0C0';
                ctx.shadowBlur = gameState.isTransformed ? 30 : 20;
                playerColor = gameState.isLaserMode ? '#ff0' : (gameState.skillMode === 'SHIELD' ? '#0f0' : (gameState.isHomingMode ? '#c4f' : baseColor));
            }
            ctx.shadowColor = playerColor;
            ctx.fillStyle = playerColor; ctx.strokeStyle = playerColor; ctx.lineWidth = 2;

            ctx.beginPath();
            if (gameState.isTransformed) {
                ctx.moveTo(cx, cy - 28);
                ctx.lineTo(cx - 22, cy + 18); ctx.lineTo(cx - 8, cy + 10);
                ctx.lineTo(cx, cy + 14);
                ctx.lineTo(cx + 8, cy + 10); ctx.lineTo(cx + 22, cy + 18);
            } else {
                ctx.moveTo(cx, cy - 25); ctx.lineTo(cx - 18, cy + 15); ctx.lineTo(cx - 5, cy + 8);
                ctx.lineTo(cx, cy + 12); ctx.lineTo(cx + 5, cy + 8); ctx.lineTo(cx + 18, cy + 15);
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = gameState.isTransformed ? '#ff0' : '#f80';
            ctx.beginPath();
            const flameH = gameState.isTransformed ? 25 : 20;
            ctx.moveTo(cx - 3, cy + 12); ctx.lineTo(cx, cy + flameH + Math.random() * 6); ctx.lineTo(cx + 3, cy + 12);
            ctx.closePath(); ctx.fill();

            if (gameState.isTransformed) {
                ctx.fillStyle = gameState.isLaserMode ? '#ff0' : '#FFD700';
                ctx.beginPath(); ctx.arc(cx - 20, cy + 5, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx + 20, cy + 5, 5, 0, Math.PI * 2); ctx.fill();
            }

            ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
        }

        function drawDrones() {
            if (gameState.isTransformed) return;
            gameState.drones.forEach(drone => {
                const dx = gameState.player.x + 10 + drone.offsetX, dy = gameState.player.y + 15;
                ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff';
                ctx.beginPath(); ctx.moveTo(dx, dy - 12); ctx.lineTo(dx - 10, dy + 6); ctx.lineTo(dx, dy + 2); ctx.lineTo(dx + 10, dy + 6);
                ctx.closePath(); ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function gameOver() {
            gameState.isRunning = false;
            showResultScreen('MISSION FAILED');

            // [CDSO ì¶”ê°€] ê²Œì„ ì¢…ë£Œ ì‹œ ë­í‚¹íŒ ìµœì‹ í™” (ì´ë•Œë§Œ ì½ê¸° ë¹„ìš© ë°œìƒ)
            initFirebaseRanking();

        }

        async function saveAndRestart() { // async í‚¤ì›Œë“œ ì¶”ê°€
            const btn = document.querySelector('#rank-input-screen button');
            btn.textContent = "SAVING..."; // ì €ì¥ ì¤‘ì„ì„ í‘œì‹œ
            btn.disabled = true; // ì¤‘ë³µ í´ë¦­ ë°©ì§€

            const name = document.getElementById('initial-input').value.toUpperCase() || 'AAA';
            const finalScore = Math.round(gameState.score);

            // ì €ì¥ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼ (await)
            await saveToFirebase(name, finalScore, gameState.currentStage);

            // ì €ì¥ì´ í™•ì‹¤íˆ ëë‚œ í›„ ìƒˆë¡œê³ ì¹¨
            location.reload();
        }

        let lastTime = performance.now();
        function gameLoop(now) {
            const dt = (now - lastTime) / 1000; lastTime = now;
            spawnEntities(dt); update(dt); draw();
            if (gameState.isRunning) requestAnimationFrame(gameLoop);
        }

        window.addEventListener('firebase-ready', initFirebaseRanking);
        setTimeout(() => { if (!firebaseReady) initFirebaseRanking(); }, 1000);
    </script>
</body>

</html>
