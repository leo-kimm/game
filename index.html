<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dodge - Legend Edition</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            background: #111;
            border: 3px solid #0ff;
            display: block;
            box-shadow: 0 0 20px #0ff;
            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Î™®Î∞îÏùº Î∞òÏùëÌòï */
        @media (max-width: 500px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
                max-height: 100vh;
                border-width: 1px;
            }

            #game-container {
                width: 100vw;
            }
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
        }

        .ui-panel {
            position: absolute;
            top: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            box-sizing: border-box;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            font-size: 0.9em;
        }

        #current-score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff;
            pointer-events: none;
            z-index: 10;
        }

        #leaderboard {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            font-size: 1em;
            width: 320px;
        }

        #leaderboard h3 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-shadow: 0 0 10px #0ff;
        }

        #leaderboard li {
            margin: 8px 0;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        #leaderboard li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* 1Îì± - Í≥®Îìú Í∞ïÏ°∞ */
        #leaderboard li.rank-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 180, 0, 0.15));
            border: 2px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            font-size: 1.15em;
            font-weight: bold;
        }

        /* 2Îì± - Ïã§Î≤Ñ */
        #leaderboard li.rank-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(150, 150, 150, 0.1));
            border: 1px solid #c0c0c0;
        }

        /* 3Îì± - Î∏åÎ°†Ï¶à */
        #leaderboard li.rank-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(180, 100, 40, 0.1));
            border: 1px solid #cd7f32;
        }

        /* Ïã†Í∑ú Ïú†Ï†Ä ÌïòÏù¥ÎùºÏù¥Ìä∏ */
        #leaderboard li.new-user {
            animation: newUserPulse 1.5s ease infinite;
            border-color: #0ff !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        @keyframes newUserPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            }
        }

        .rank-badge {
            min-width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
        }

        .rank-1 .rank-badge {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .rank-2 .rank-badge {
            background: linear-gradient(135deg, #c0c0c0, #888);
            color: #000;
        }

        .rank-3 .rank-badge {
            background: linear-gradient(135deg, #cd7f32, #a05a20);
            color: #fff;
        }

        .rank-4 .rank-badge,
        .rank-5 .rank-badge {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .player-name {
            flex: 1;
            text-align: left;
            color: #fff;
        }

        .player-score {
            font-weight: bold;
            color: #0ff;
            margin-right: 10px;
        }

        .player-stage {
            color: #888;
            font-size: 0.85em;
        }

        /* Í≤∞Í≥º Ïª®ÌÖåÏù¥ÎÑà Ïä§ÌÉÄÏùº */
        .result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px 40px;
            border: 2px solid #f0f;
            box-shadow: 0 0 20px #f0f, inset 0 0 15px rgba(255, 0, 255, 0.1);
            background: rgba(20, 0, 30, 0.9);
            animation: slideDown 0.5s ease-out, glitch 0.1s infinite alternate;
        }

        .result-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
            margin-bottom: 20px;
            animation: textGlitch 2s infinite;
        }

        .result-stats {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(0, 255, 255, 0.05);
            border-left: 3px solid #0ff;
        }

        .stat-row .label {
            font-size: 0.9em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        #initial-input {
            background: transparent;
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 2em;
            text-align: center;
            width: 150px;
            outline: none;
            text-transform: uppercase;
            margin-top: 20px;
            animation: inputPulse 1.5s ease-in-out infinite;
        }

        button {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 25px;
            cursor: pointer;
            font-size: 1.2em;
            margin-top: 20px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 25px #0ff;
        }

        .active-skill {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #f0f;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Ïï†ÎãàÎ©îÏù¥ÏÖò */
        @keyframes slideDown {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes glitch {
            0% {
                transform: translate(0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, -1px);
            }

            75% {
                transform: translate(-1px, -1px);
            }

            100% {
                transform: translate(1px, 1px);
            }
        }

        @keyframes textGlitch {

            0%,
            90%,
            100% {
                text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
                clip-path: none;
            }

            92% {
                text-shadow: -3px 0 #0ff, 3px 0 #f0f;
                clip-path: inset(20% 0 30% 0);
            }

            94% {
                text-shadow: 3px 0 #0ff, -3px 0 #f0f;
                clip-path: inset(50% 0 10% 0);
            }

            96% {
                text-shadow: -2px 0 #0ff, 2px 0 #f0f;
                clip-path: inset(10% 0 60% 0);
            }

            98% {
                text-shadow: 2px 0 #0ff, -2px 0 #f0f;
                clip-path: inset(40% 0 20% 0);
            }
        }

        @keyframes inputPulse {

            0%,
            100% {
                box-shadow: 0 0 5px #f0f;
                border-color: #f0f;
            }

            50% {
                box-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
                border-color: #fff;
            }
        }

        /* Í≤∞Í≥º ÌôîÎ©¥ Ïä¨ÎùºÏù¥Îìú Ïù∏ */
        #rank-input-screen.show {
            animation: screenGlitchIn 0.3s ease-out;
        }

        @keyframes screenGlitchIn {
            0% {
                opacity: 0;
            }

            10% {
                opacity: 1;
                transform: translateX(-5px);
            }

            20% {
                transform: translateX(5px);
            }

            30% {
                transform: translateX(-3px);
            }

            40% {
                transform: translateX(3px);
            }

            50% {
                transform: translateX(-1px);
            }

            60% {
                transform: translateX(1px);
            }

            100% {
                transform: translateX(0);
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp }
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBTLq7p5i6GZ89kkWyTFXUMN2TLRBfdL8w",
            authDomain: "neon-dodge-global.firebaseapp.com",
            projectId: "neon-dodge-global",
            storageBucket: "neon-dodge-global.firebasestorage.app",
            messagingSenderId: "104500725211",
            appId: "1:104500725211:web:aa5e89d87ec21808ec4fe"
        };

        window.firebaseApp = initializeApp(firebaseConfig);
        window.firebaseDB = getFirestore(window.firebaseApp);
        window.firebaseModules = { collection, addDoc, query, orderBy, limit, onSnapshot, serverTimestamp };
        window.dispatchEvent(new Event('firebase-ready'));
    </script>
</head>

<body>
    <div id="game-container">
        <div class="ui-panel">
            <div id="lives">LIVES: ‚ô•‚ô•‚ô•</div>
            <div id="current-score">0</div>
            <div id="stage-info">STAGE 1 | TIME: 30</div>
        </div>
        <div id="skill-display" class="active-skill"></div>
        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="overlay">
            <h1>NEON DODGE</h1>
            <ul id="leaderboard">
                <li>Loading...</li>
            </ul>
            <div id="my-rank"
                style="display:none; margin-top: 10px; color: #0ff; font-size: 14px; text-shadow: 0 0 10px #0ff;">
                YOUR RANK: <span id="rank-position">-</span>th
            </div>
            <button onclick="startGame()">GAME START</button>
        </div>

        <div id="rank-input-screen" class="overlay" style="display:none;">
            <div class="result-container">
                <div class="result-title" id="res-title">MISSION FAILED</div>
                <div class="result-stats">
                    <div class="stat-row">
                        <span class="label">STAGE</span>
                        <span class="value" id="res-stage">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">SCORE</span>
                        <span class="value" id="res-score">0</span>
                    </div>
                </div>
            </div>
            <input type="text" id="initial-input" maxlength="3" placeholder="AAA">
            <button onclick="saveAndRestart()">SAVE RECORD</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 450; canvas.height = 700;

        const levels = [
            { stage: 1, duration: 10, theme: '#0ff', speedMult: 1.0, spawnRate: 0.69, types: ['NORMAL'], isBoss: false },
            { stage: 2, duration: 11, theme: '#0f0', speedMult: 1.1, spawnRate: 0.62, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
            { stage: 3, duration: 12, theme: '#8ef', speedMult: 1.2, spawnRate: 0.54, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
            { stage: 4, duration: 13, theme: '#aaf', speedMult: 1.3, spawnRate: 0.46, types: ['NORMAL', 'ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 5, duration: 14, theme: '#88f', speedMult: 1.4, spawnRate: 0.42, types: ['ZIGZAG', 'HOMING'], isBoss: true, bossHP: 55, bossType: 'LUNAR' },
            { stage: 6, duration: 15, theme: '#f80', speedMult: 1.5, spawnRate: 0.31, types: ['ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 7, duration: 16, theme: '#f64', speedMult: 1.6, spawnRate: 0.27, types: ['ZIGZAG', 'HOMING'], isBoss: false },
            { stage: 8, duration: 17, theme: '#f44', speedMult: 1.7, spawnRate: 0.25, types: ['NORMAL', 'ZIGZAG', 'HOMING', 'SHOOTER'], isBoss: false },
            { stage: 9, duration: 18, theme: '#f22', speedMult: 1.9, spawnRate: 0.22, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER'], isBoss: false },
            { stage: 10, duration: 19, theme: '#f80', speedMult: 2.0, spawnRate: 0.19, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER', 'LASER_ENEMY'], isBoss: true, bossHP: 50, bossType: 'SUN' }
        ];

        let gameState = {
            isRunning: false, score: 0,
            player: { x: 215, y: 630, w: 20, h: 20, speed: 450 },
            enemies: [], items: [], bullets: [], keys: {},
            skillMode: 'NORMAL', skillTimer: 0,
            lives: 3, maxLives: 3, isInvincible: false, invincibilityTimer: 0,
            drones: [],
            isTransformed: false,
            isLaserMode: false, laserTimer: 0,
            spawnTimer: 0, itemSpawnTimer: 0,
            currentStage: 1, stageTimer: 30, boss: null,
            stageClearing: false, stageClearTimer: 0, survivalMode: false,
            bossPhase: 'MINION',
            bossTimer: 0,
            bossResurrected: false,
            downgradeFlash: 0,
            progressDisplay: 0,
            survivalStartCount: 0,
            spawnDelay: 0,
            isLunarMode: false,
            lunarAngle: 0,
            touchTarget: null,
            stageTimerEnded: false,
            survivalTimer: 0,
            pendingBoss: null,
            // ÏÉàÎ°úÏö¥ Í∏∞Îä•Îì§
            ultGauge: 0,           // ÌïÑÏÇ¥Í∏∞ Í≤åÏù¥ÏßÄ (0~1)
            autoFireTimer: 0,      // ÏûêÎèô Î∞úÏÇ¨ ÌÉÄÏù¥Î®∏
            isHomingMode: false,   // Ïú†ÎèÑÌÉÑ Î™®Îìú
            homingTimer: 0,        // Ïú†ÎèÑÌÉÑ ÏßÄÏÜç ÏãúÍ∞Ñ
            rainbowWave: null,     // Î¨¥ÏßÄÍ∞ú ÌååÎèô ÏÉÅÌÉú
            dangerWarning: 0,      // DANGER Í≤ΩÍ≥† ÌÉÄÏù¥Î®∏
            timeBonusDisplay: null // ÏãúÍ∞Ñ Î≥¥ÎÑàÏä§ ÌëúÏãú
        };

        let firebaseReady = false;
        let lastSavedName = '';  // Ïã†Í∑ú Îì±Î°ù Ïú†Ï†Ä ÌïòÏù¥ÎùºÏù¥Ìä∏Ïö©

        function initFirebaseRanking() {
            if (!window.firebaseDB) { setTimeout(initFirebaseRanking, 100); return; }
            firebaseReady = true;
            const { collection, query, orderBy, limit, onSnapshot } = window.firebaseModules;
            const list = document.getElementById('leaderboard');
            try {
                const q = query(collection(window.firebaseDB, 'rankings'), orderBy('score', 'desc'), limit(5));
                onSnapshot(q, (snapshot) => {
                    list.innerHTML = '<h3>üåê GLOBAL TOP 5</h3>';
                    if (snapshot.empty) { list.innerHTML += '<li class="rank-1">No Records Yet</li>'; return; }
                    snapshot.docs.forEach((doc, i) => {
                        const r = doc.data();
                        const rank = i + 1;
                        const isNewUser = lastSavedName && r.name === lastSavedName;
                        const rankClass = `rank-${rank}${isNewUser ? ' new-user' : ''}`;
                        const rankEmoji = rank === 1 ? 'ü•á' : (rank === 2 ? 'ü•à' : (rank === 3 ? 'ü•â' : rank));
                        list.innerHTML += `
                            <li class="${rankClass}">
                                <span class="rank-badge">${rankEmoji}</span>
                                <span class="player-name">${r.name}</span>
                                <span class="player-score">${r.score.toLocaleString()}</span>
                                <span class="player-stage">ST.${r.stage}</span>
                            </li>`;
                    });
                });
            } catch (e) { console.error(e); }

            // Phase 1: ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï†ÄÏû•Îêú Ï†êÏàòÍ∞Ä ÏûàÏúºÎ©¥ ÏàúÏúÑ ÌëúÏãú
            const lastScore = localStorage.getItem('lastScore');
            if (lastScore && parseInt(lastScore) > 0) {
                updateMyRank(parseInt(lastScore));
            }
        }

        async function saveToFirebase(name, score, stage) {
            if (!firebaseReady) return;

            // Phase 1: Ï†êÏàòÎ•º localStorageÏóê ÏûÑÏãú Ï†ÄÏû•
            localStorage.setItem('lastScore', score);

            const { collection, addDoc, serverTimestamp } = window.firebaseModules;
            try {
                await addDoc(collection(window.firebaseDB, 'rankings'), { name, score, stage, timestamp: serverTimestamp() });
                lastSavedName = name;

                // ÎÇ¥ ÏàúÏúÑ Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
                await updateMyRank(score);
            }
            catch (e) { console.error(e); }
        }

        async function updateMyRank(myScore) {
            // Phase 2: 0Ï†êÏù¥Î©¥ Î¨¥Ïãú
            if (!firebaseReady || !myScore || myScore <= 0) return;

            const { collection, query, where, getDocs } = window.firebaseModules;
            try {
                // ÎÇ¥ Ï†êÏàòÎ≥¥Îã§ ÎÜíÏùÄ Ï†êÏàòÎßå Ïπ¥Ïö¥Ìä∏ (Ï†ÑÏ≤¥ ÏøºÎ¶¨ Ï†úÍ±∞)
                const higherQuery = query(
                    collection(window.firebaseDB, 'rankings'),
                    where('score', '>', myScore)
                );
                const higherSnapshot = await getDocs(higherQuery);
                const myRank = higherSnapshot.size + 1;

                // UI ÏóÖÎç∞Ïù¥Ìä∏ (Ï†ÑÏ≤¥ Ïù∏Ïõê ÌëúÏãú ÏÉùÎûµ)
                document.getElementById('rank-position').textContent = myRank;
                document.getElementById('my-rank').style.display = 'block';

                // Ï∫êÏãú Ï†ïÎ¶¨
                // localStorage.removeItem('lastScore');
            } catch (e) {
                console.error('Failed to calculate rank:', e);
            }
        }

        // Ïã§Ï†ú Ï†Å Í∏∞Ï≤¥Îßå Ïπ¥Ïö¥Ìä∏ (ÌÉÑÌôò + Ìè≠Î∞ú/Î∞úÏÇ¨ ÏôÑÎ£å Ï†Å Ï†úÏô∏)
        function getActiveEnemyCount() {
            return gameState.enemies.filter(en =>
                en.type !== 'BULLET' &&
                en.type !== 'ENEMY_BULLET' &&
                en.type !== 'SHOCKWAVE' &&
                en.type !== 'METEOR' &&
                !(en.type === 'BOMBER' && en.exploded) &&
                !(en.type === 'LASER_ENEMY' && en.fired)
            ).length;
        }

        // Ï†Å ÌÉÄÏûÖÎ≥Ñ Ï∞®Îì± Ï†êÏàò (ÏÜåÏàòÏ†ê Îã®ÏúÑ)
        function getEnemyScore(type) {
            const scoreTable = {
                'NORMAL': 1.0,
                'ZIGZAG': 1.2,
                'HOMING': 1.5,
                'SHOOTER': 1.8,
                'BOMBER': 2.0,
                'LASER_ENEMY': 2.2,
                'MINION': 0.5
            };
            return scoreTable[type] || 1.0;
        }

        // Phase 6: Safety Margin Ï∂©Îèå ÌåêÏ†ï (2px Ïó¨Ïú†)
        function checkCollisionWithMargin(a, b, margin = 2) {
            return !(
                a.x + a.w + margin < b.x ||
                a.x - margin > b.x + b.w ||
                a.y + a.h + margin < b.y ||
                a.y - margin > b.y + b.h
            );
        }

        function takeDamage() {
            if (gameState.isInvincible || gameState.skillMode === 'SHIELD') return;

            if (gameState.isTransformed) {
                gameState.isTransformed = false;
                gameState.isLaserMode = false;
                gameState.laserTimer = 0;
                gameState.isLunarMode = false;  // Ìô©Í∏à Î≥ÄÏã† Ìï¥Ï†ú Ïãú Î£®ÎÇòÎ™®ÎìúÎèÑ Ìï®Íªò Ìï¥Ï†ú
                gameState.drones = [{ offsetX: -35, shootTimer: 0 }];
                gameState.isInvincible = true;
                gameState.invincibilityTimer = 1.5;
                gameState.downgradeFlash = 0.5;
                return;
            }

            if (gameState.drones.length > 0) {
                gameState.drones.pop();
                return;
            }

            gameState.lives--;
            updateLivesUI();
            if (gameState.lives <= 0) gameOver();
            else { gameState.isInvincible = true; gameState.invincibilityTimer = 2.0; }
        }

        function updateLivesUI() {
            document.getElementById('lives').textContent = `LIVES: ${'‚ô•'.repeat(gameState.lives)}${'‚ô°'.repeat(gameState.maxLives - gameState.lives)}`;
        }

        function updateDrones(dt) {
            if (gameState.isTransformed) return;
            gameState.drones.forEach(drone => {
                drone.shootTimer += dt;
                if (drone.shootTimer > 0.5) {
                    gameState.bullets.push({ x: gameState.player.x + 10 + drone.offsetX - 4, y: gameState.player.y, w: 8, h: 15, speed: 650 });
                    drone.shootTimer = 0;
                }
            });
        }

        window.addEventListener('keydown', e => {
            gameState.keys[e.key] = true;
            // Space ÌÇ§Î°ú ÌïÑÏÇ¥Í∏∞ Î∞úÎèô
            if (e.code === 'Space' && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                activateRainbowWave();
            }
        });
        window.addEventListener('keyup', e => gameState.keys[e.key] = false);

        // Î™®Î∞îÏùº ÌÑ∞Ïπò Ï¢åÌëú Î≥ÄÌôò
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = e.touches[0];
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // Î™®Î∞îÏùº ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ (Ï†úÏä§Ï≤ò Ï∞®Îã® + Î∂ÄÎìúÎü¨Ïö¥ Ï∂îÏ†Å)
        let isTouching = false;
        canvas.addEventListener('touchstart', function (e) {
            e.preventDefault();
            isTouching = true;
            const pos = getTouchPos(e);
            gameState.touchTarget = pos.x - gameState.player.w / 2;

            // Ï†ÑÌà¨Í∏∞ Í∑ºÏ≤ò ÌÑ∞Ïπò Ïãú ÌïÑÏÇ¥Í∏∞ Î∞úÎèô
            const playerCenterX = gameState.player.x + gameState.player.w / 2;
            const playerCenterY = gameState.player.y + gameState.player.h / 2;
            const touchDist = Math.sqrt(Math.pow(pos.x - playerCenterX, 2) + Math.pow(pos.y - playerCenterY, 2));
            if (touchDist < 80 && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                activateRainbowWave();
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            if (!isTouching) return;
            const pos = getTouchPos(e);
            gameState.touchTarget = pos.x - gameState.player.w / 2;
        }, { passive: false });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
            isTouching = false;
        }, { passive: false });

        canvas.addEventListener('touchcancel', function (e) {
            e.preventDefault();
            isTouching = false;
        }, { passive: false });

        // ÏûêÎèô ÏùºÏãúÏ†ïÏßÄ (Ï†ÑÌôî/Ìôà ÌôîÎ©¥ Ï†ÑÌôò Ïãú)
        document.addEventListener('visibilitychange', function () {
            if (document.hidden && gameState.isRunning) {
                gameState.isRunning = false;
                document.getElementById('start-screen').style.display = 'flex';
                document.querySelector('#start-screen h1').textContent = 'PAUSED';
                document.querySelector('#start-screen button').textContent = 'RESUME';
            }
        });

        function startGame() {
        // [Ï∂îÍ∞Ä] ÏÉà Í≤åÏûÑ ÏãúÏûë Ïãú Ïù¥Ï†Ñ Îû≠ÌÇπ ÌëúÏãúÏö© Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
            localStorage.removeItem('lastScore');
            document.getElementById('my-rank').style.display = 'none';

            document.getElementById('start-screen').style.display = 'none';
            resetState();
            gameState.isRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function resetState() {
            Object.assign(gameState, {
                score: 0, enemies: [], items: [], bullets: [],
                skillMode: 'NORMAL', skillTimer: 0, spawnTimer: 0, itemSpawnTimer: 0,
                lives: 3, isInvincible: false, invincibilityTimer: 0, drones: [],
                isTransformed: false, isLaserMode: false, laserTimer: 0, isLunarMode: false,
                currentStage: 1, stageTimer: 30, boss: null,
                stageClearing: false, stageClearTimer: 0, survivalMode: false,
                bossPhase: 'MINION', bossTimer: 0, bossResurrected: false,
                downgradeFlash: 0, progressDisplay: 0, survivalStartCount: 0,
                spawnDelay: 1.0,
                stageTimerEnded: false, survivalTimer: 0, pendingBoss: null,
                // ÏÉàÎ°úÏö¥ Í∏∞Îä•Îì§ Ï¥àÍ∏∞Ìôî
                ultGauge: 0, autoFireTimer: 0,
                isHomingMode: false, homingTimer: 0,
                rainbowWave: null, dangerWarning: 0, timeBonusDisplay: null
            });
            gameState.player.x = 215;
            updateLivesUI();
            // ÎÇ¥ ÏàúÏúÑ ÌëúÏãú Ïà®Í∏∞Í∏∞
            document.getElementById('my-rank').style.display = 'none';
        }

        function spawnEntities(dt) {
            if (gameState.spawnDelay > 0) {
                gameState.spawnDelay -= dt;
                return;
            }

            const lvl = levels[gameState.currentStage - 1];

            if (lvl.isBoss && gameState.bossPhase === 'BOSS') {
                if (gameState.bossTimer < 10) {
                    gameState.spawnTimer += dt;
                    if (gameState.spawnTimer > 1.2) {
                        gameState.enemies.push({
                            x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25,
                            speed: 180 + Math.random() * 80, type: 'MINION',
                            amplitude: 1, turnRate: 80, time: 0
                        });
                        gameState.spawnTimer = 0;
                    }
                }
                gameState.itemSpawnTimer += dt;
                if (gameState.itemSpawnTimer > 7) {
                    const type = Math.random() < 0.7 ? 'BLASTER' : 'SHIELD';
                    gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type });
                    gameState.itemSpawnTimer = 0;
                }
                return;
            }

            if (gameState.stageClearing || gameState.survivalMode) return;

            gameState.spawnTimer += dt;
            if (gameState.spawnTimer > lvl.spawnRate && lvl.types.length > 0) {
                const type = lvl.types[Math.floor(Math.random() * lvl.types.length)];
                gameState.enemies.push({
                    x: Math.random() * (canvas.width - 24), y: -32, w: 24, h: 24,
                    speed: (200 + Math.random() * 100) * lvl.speedMult, type,
                    amplitude: Math.random() * 2 + 1, turnRate: 120 + Math.random() * 60, time: 0
                });
                gameState.spawnTimer = 0;
            }

            gameState.itemSpawnTimer += dt;
            if (gameState.itemSpawnTimer > 8) {
                const rand = Math.random();
                const type = rand < 0.15 ? 'DRONE' : (rand < 0.55 ? 'SHIELD' : 'BLASTER');
                gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type });
                gameState.itemSpawnTimer = 0;
            }
        }

        function spawnBoss(hp, type) {
            const isLunar = type === 'LUNAR';
            const w = isLunar ? 115 : 100;  // Î£®ÎÇò 15% ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
            const h = isLunar ? 92 : 80;
            gameState.boss = {
                x: canvas.width / 2 - w / 2, y: 50, w, h,
                hp, maxHp: hp, moveDir: 1, shootTimer: 0, type: type || 'LUNAR',
                isSupernova: false, shockwaveTimer: 0
            };
            // gameState.enemies = [];
            gameState.bossTimer = 0;
            gameState.spawnTimer = 0;
        }

        function triggerBigBang() {
            const boss = gameState.boss;
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            for (let i = 0; i < 24; i++) {
                const rad = (i * 15) * Math.PI / 180;
                const speed = 200 + Math.random() * 100;
                gameState.enemies.push({
                    x: cx - 6, y: cy,
                    w: 12, h: 12, speed: 0, type: 'BULLET',
                    vx: Math.cos(rad) * speed, vy: Math.sin(rad) * speed,
                    amplitude: 0, turnRate: 0, time: 0
                });
            }
        }

        function updateBoss(dt) {
            const boss = gameState.boss;
            if (!boss) return;

            gameState.bossTimer += dt;
            boss.x += boss.moveDir * 120 * dt;
            if (boss.x <= 0 || boss.x >= canvas.width - boss.w) boss.moveDir *= -1;
            boss.shootTimer += dt;

            if (boss.type === 'LUNAR') {
                // Ïú†ÏÑ± Í≥µÍ≤© (METEOR)
                if (boss.shootTimer > 1.8) {
                    for (let angle = -30; angle <= 30; angle += 30) {
                        const rad = (90 + angle) * Math.PI / 180;
                        gameState.enemies.push({
                            x: boss.x + boss.w / 2 - 14, y: boss.y + boss.h,
                            w: 28, h: 28, speed: 0, type: 'METEOR',
                            vx: Math.cos(rad) * 180, vy: Math.sin(rad) * 180,
                            amplitude: 0, turnRate: 0, time: 0
                        });
                    }
                    boss.shootTimer = 0;
                }
                // ÏõîÍ¥ë Ï∂©Í≤©Ìåå (3Ï¥àÎßàÎã§) + DANGER Í≤ΩÍ≥†
                boss.shockwaveTimer += dt;

                // Ï∂©Í≤©Ìåå Î∞úÏÇ¨ 0.5Ï¥à Ï†Ñ DANGER Í≤ΩÍ≥† ÏãúÏûë
                if (boss.shockwaveTimer > 2.5 && boss.shockwaveTimer <= 3) {
                    gameState.dangerWarning = 0.5 - (3 - boss.shockwaveTimer);
                }

                if (boss.shockwaveTimer > 3) {
                    const px = gameState.player.x + gameState.player.w / 2;
                    const bx = boss.x + boss.w / 2, by = boss.y + boss.h;
                    const dx = px - bx, dy = gameState.player.y - by;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    gameState.enemies.push({
                        x: bx - 10, y: by,
                        w: 20, h: 20, speed: 0, type: 'SHOCKWAVE',
                        vx: (dx / dist) * 350, vy: (dy / dist) * 350,
                        amplitude: 0, turnRate: 0, time: 0
                    });
                    boss.shockwaveTimer = 0;
                    gameState.dangerWarning = 0;  // Í≤ΩÍ≥† Ï¢ÖÎ£å
                }
            } else if (boss.type === 'SUN') {
                const fireRate = boss.isSupernova ? 1.5 : 2.0;
                const bulletCount = boss.isSupernova ? 16 : 12;
                if (boss.shootTimer > fireRate) {
                    for (let i = 0; i < bulletCount; i++) {
                        const rad = (i * (360 / bulletCount) + Date.now() / 50) * Math.PI / 180;
                        gameState.enemies.push({
                            x: boss.x + boss.w / 2 - 6, y: boss.y + boss.h / 2,
                            w: 12, h: 12, speed: 0, type: 'BULLET',
                            vx: Math.cos(rad) * (boss.isSupernova ? 220 : 180),
                            vy: Math.sin(rad) * (boss.isSupernova ? 220 : 180),
                            amplitude: 0, turnRate: 0, time: 0
                        });
                    }
                    boss.shootTimer = 0;
                }
            }

            if (gameState.isLaserMode) {
                const laserL = gameState.player.x + gameState.player.w / 2 - 20;
                const laserR = gameState.player.x + gameState.player.w / 2 + 20;
                if (boss.x + boss.w > laserL && boss.x < laserR) {
                    boss.hp -= dt * 8;
                    gameState.score += Math.floor(dt * 10);
                }
            }

            for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                if (checkRectCollision(gameState.bullets[bi], boss)) {
                    boss.hp--; gameState.bullets.splice(bi, 1); gameState.score += 5;
                }
            }

            if (boss.hp <= 0) {
                if (boss.type === 'SUN' && !gameState.bossResurrected) {
                    triggerBigBang();
                    boss.hp = boss.maxHp * 0.5;
                    boss.isSupernova = true;
                    gameState.bossResurrected = true;
                } else {
                    // ÏãúÍ∞Ñ Î≥¥ÎÑàÏä§ Ï†êÏàò Í≥ÑÏÇ∞
                    let timeBonus = 0;
                    if (gameState.bossTimer <= 10) {
                        timeBonus = 500;  // 10Ï¥à Ïù¥ÎÇ¥
                    } else if (gameState.bossTimer <= 20) {
                        timeBonus = 300;  // 20Ï¥à Ïù¥ÎÇ¥
                    } else {
                        timeBonus = 100;  // Í∑∏ Ïù¥ÏÉÅ
                    }
                    gameState.score += timeBonus;
                    gameState.timeBonusDisplay = { amount: timeBonus, timer: 2.0 };  // 2Ï¥àÍ∞Ñ ÌëúÏãú

                    // Î£®ÎÇò Î≥¥Ïä§ Ï≤òÏπò Ïãú Ï¶âÏãú 3Î∞©Ìñ• ÏôÄÏù¥Îìú ÏÉ∑ ÌôúÏÑ±Ìôî
                    if (boss.type === 'LUNAR') {
                        gameState.isLunarMode = true;
                    }
                    triggerStageClear();
                }
                return;
            }

            if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, boss)) takeDamage();
        }

        function triggerStageClear() {
            gameState.stageClearing = true;
            gameState.stageClearTimer = 1.0;  // Ïä§ÌÖåÏù¥ÏßÄ Î¨∏Íµ¨ 1Ï¥à
            gameState.boss = null;
            gameState.survivalMode = false;
            gameState.bossPhase = 'MINION';
            gameState.bossResurrected = false;
            // Phase 3: pendingBoss Î°úÏßÅ Ï†úÍ±∞ - spawnBoss ÏßÅÏ†ë Ìò∏Ï∂ú Î∞©Ïãù ÏÇ¨Ïö©
        }

        // Phase 5: Ïä§ÌÖåÏù¥ÏßÄ Ï†ÑÏù¥ Î°úÏßÅ ÌÜµÌï© Ìï®Ïàò
        function handleStageTransition(dt) {
            const lvl = levels[gameState.currentStage - 1];

            // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ï≤òÎ¶¨
            if (gameState.stageClearing) {
                gameState.stageClearTimer -= dt;
                if (gameState.stageClearTimer <= 0) {
                    gameState.enemies = [];
                    advanceStage();
                }
                return;
            }

            // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ
            if (lvl.isBoss) {
                if (gameState.bossPhase === 'MINION') {
                    gameState.stageTimer -= dt;
                    if (gameState.stageTimer <= 0) {
                        gameState.bossPhase = 'BOSS';
                        gameState.stageTimerEnded = true;
                        spawnBoss(lvl.bossHP, lvl.bossType);
                    }
                } else if (gameState.bossPhase === 'BOSS') {
                    updateBoss(dt);
                }
                return;
            }

            // ÏùºÎ∞ò Ïä§ÌÖåÏù¥ÏßÄ
            if (!gameState.stageTimerEnded) {
                gameState.stageTimer -= dt;
                if (gameState.stageTimer <= 0) {
                    gameState.stageTimerEnded = true;
                }
            }

            if (gameState.stageTimerEnded && !gameState.survivalMode && getActiveEnemyCount() === 0) {
                gameState.survivalMode = true;
                gameState.survivalTimer = 0.7;
                gameState.enemies = [];
            }

            if (gameState.survivalMode) {
                gameState.survivalTimer -= dt;
                if (gameState.survivalTimer <= 0) {
                    triggerStageClear();
                }
            }
        }

        function advanceStage() {
            if (gameState.currentStage >= 10) { gameComplete(); return; }
            gameState.currentStage++;
            const lvl = levels[gameState.currentStage - 1];
            gameState.stageTimer = lvl.duration;
            gameState.stageClearing = false;
            gameState.survivalMode = false;
            gameState.stageTimerEnded = false;  // ‚òÖ Ï∂îÍ∞Ä
            gameState.survivalTimer = 0;        // ‚òÖ Ï∂îÍ∞Ä
            gameState.spawnTimer = 0;
            gameState.bossPhase = 'MINION';
            gameState.bossResurrected = false;
            gameState.progressDisplay = 0;
            gameState.enemies = [];
            gameState.items = [];
            gameState.spawnDelay = 0.8;
        }

        function showResultScreen(title) {
            const finalScore = Math.round(gameState.score);  // ÏÜåÏàòÏ†ê Î∞òÏò¨Î¶º
            document.getElementById('res-title').textContent = title;
            document.getElementById('res-stage').textContent = gameState.currentStage;
            document.getElementById('res-score').textContent = finalScore;

            const screen = document.getElementById('rank-input-screen');
            screen.style.display = 'flex';
            screen.classList.add('show');

            // ÏûÖÎ†•Ï∞Ω Ìè¨Ïª§Ïä§
            setTimeout(() => document.getElementById('initial-input').focus(), 300);
        }

        function gameComplete() {
            gameState.isRunning = false;
            showResultScreen('üéâ MISSION COMPLETE');
        }

        // Î¨¥ÏßÄÍ∞ú ÌååÎèô Î∞úÎèô
        function activateRainbowWave() {
            gameState.rainbowWave = { active: true, y: canvas.height };
            gameState.ultGauge = 0;
        }

        // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å Ï∞æÍ∏∞ (Ïú†ÎèÑÌÉÑÏö©)
        function findNearestEnemy() {
            const px = gameState.player.x + gameState.player.w / 2;
            const py = gameState.player.y;
            let nearest = null;
            let minDist = Infinity;

            // [Ï∂îÍ∞ÄÎêú Î°úÏßÅ] Î≥¥Ïä§Í∞Ä Ï°¥Ïû¨ÌïòÎ©¥ ÏùºÎã® Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ÅÏúºÎ°ú ÏÑ§Ï†ï
            if (gameState.boss) {
                const bx = gameState.boss.x + gameState.boss.w / 2;
                const by = gameState.boss.y + gameState.boss.h / 2;
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Î≥¥Ïä§ ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨ Í≥ÑÏÇ∞
                const dist = Math.sqrt(Math.pow(px - bx, 2) + Math.pow(py - by, 2));
                minDist = dist;
                nearest = gameState.boss;
            }

            // Í∏∞Ï°¥ Ï†ÅÎì§Í≥º Í±∞Î¶¨ ÎπÑÍµê (Î≥¥Ïä§Î≥¥Îã§ Îçî Í∞ÄÍπåÏö¥ Ï†ÅÏù¥ ÏûàÏúºÎ©¥ ÌÉÄÍ≤ü Î≥ÄÍ≤Ω)
            for (const en of gameState.enemies) {
            if (en.y < py && en.type !== 'BULLET' && en.type !== 'ENEMY_BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'METEOR') {
                const ex = en.x + en.w / 2;
                const ey = en.y + en.h / 2;
                const dist = Math.sqrt(Math.pow(px - ex, 2) + Math.pow(py - ey, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = en;
                }
            }
        }
            return nearest;
        }

        function update(dt) {
            if (!gameState.isRunning) return;
            const lvl = levels[gameState.currentStage - 1];

            // ÌïÑÏÇ¥Í∏∞ Í≤åÏù¥ÏßÄ Ï∂©Ï†Ñ (dt * 0.05, ÏïΩ 20Ï¥àÏóê ÏôÑÏ∂©)
            if (gameState.ultGauge < 1 && !gameState.rainbowWave) {
                gameState.ultGauge = Math.min(1, gameState.ultGauge + dt * 0.05);
            }

            // ÏÉÅÏãú ÏûêÎèô Í≥µÍ≤© (0.4Ï¥àÎßàÎã§)
            gameState.autoFireTimer += dt;
            if (gameState.autoFireTimer >= 0.4) {
                const cx = gameState.player.x + gameState.player.w / 2;
                const cy = gameState.player.y;

                if (gameState.isHomingMode) {
                    // Ïú†ÎèÑÌÉÑ Î™®Îìú: Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å Ï∂îÏ†Å
                    const target = findNearestEnemy();
                    if (target) {
                        const tx = target.x + target.w / 2;
                        const ty = target.y + target.h / 2;
                        const dx = tx - cx;
                        const dy = ty - cy;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        gameState.bullets.push({
                            x: cx - 5, y: cy, w: 10, h: 15, speed: 550,
                            isHoming: true, targetX: tx, targetY: ty,
                            vx: (dx / dist) * 550, vy: (dy / dist) * 550
                        });
                    } else {
                        // Ï†ÅÏù¥ ÏóÜÏúºÎ©¥ ÏùºÎ∞ò ÏßÅÏÑ† Î∞úÏÇ¨
                        gameState.bullets.push({ x: cx - 5, y: cy, w: 10, h: 15, speed: 550 });
                    }
                } else {
                    // ÏùºÎ∞ò ÏßÅÏÑ† Î∞úÏÇ¨
                    gameState.bullets.push({ x: cx - 5, y: cy, w: 10, h: 15, speed: 550 });
                }
                gameState.autoFireTimer = 0;
            }

            // Ïú†ÎèÑÌÉÑ Î™®Îìú ÌÉÄÏù¥Î®∏
            if (gameState.isHomingMode) {
                gameState.homingTimer -= dt;
                if (gameState.homingTimer <= 0) {
                    gameState.isHomingMode = false;
                }
            }

            // Î¨¥ÏßÄÍ∞ú ÌååÎèô Ï≤òÎ¶¨
            if (gameState.rainbowWave) {
                gameState.rainbowWave.y -= 500 * dt;  // Ï¥àÎãπ 500px ÏÉÅÏäπ

                // ÌååÎèôÎ≥¥Îã§ ÏïÑÎûò ÏûàÎäî Î™®Îì† Ï†Å Ï†úÍ±∞
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    if (en.y + en.h > gameState.rainbowWave.y) {
                        gameState.score += getEnemyScore(en.type) * 2;  // Î≥¥ÎÑàÏä§ Ï†êÏàò
                        gameState.enemies.splice(i, 1);
                    }
                }

                // ÌååÎèôÏù¥ ÌôîÎ©¥ ÏúÑÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï¢ÖÎ£å
                if (gameState.rainbowWave.y < -50) {
                    gameState.rainbowWave = null;
                }
            }

            // ÌòÑÏû¨ Ï†êÏàò UI ÏóÖÎç∞Ïù¥Ìä∏
            document.getElementById('current-score').textContent = Math.round(gameState.score);

            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= dt;
                if (gameState.invincibilityTimer <= 0) gameState.isInvincible = false;
            }

            if (gameState.downgradeFlash > 0) gameState.downgradeFlash -= dt;

            // ÏãúÍ∞Ñ Î≥¥ÎÑàÏä§ ÌëúÏãú ÌÉÄÏù¥Î®∏
            if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                gameState.timeBonusDisplay.timer -= dt;
                if (gameState.timeBonusDisplay.timer <= 0) {
                    gameState.timeBonusDisplay = null;
                }
            }

            if (gameState.isLaserMode) {
                gameState.laserTimer -= dt;
                if (gameState.laserTimer <= 0) gameState.isLaserMode = false;
            }

            // Phase 5: Ïä§ÌÖåÏù¥ÏßÄ Ï†ÑÏù¥ Î°úÏßÅ ÌÜµÌï©
            handleStageTransition(dt);

            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô (ÌÇ§Î≥¥Îìú)
            if ((gameState.keys['ArrowLeft'] || gameState.keys['a']) && gameState.player.x > 0)
                gameState.player.x -= gameState.player.speed * dt;
            if ((gameState.keys['ArrowRight'] || gameState.keys['d']) && gameState.player.x < canvas.width - gameState.player.w)
                gameState.player.x += gameState.player.speed * dt;

            // Î™®Î∞îÏùº ÌÑ∞Ïπò Î∂ÄÎìúÎü¨Ïö¥ Ï∂îÏ†Å
            if (gameState.touchTarget !== null) {
                const target = Math.max(0, Math.min(canvas.width - gameState.player.w, gameState.touchTarget));
                const diff = target - gameState.player.x;
                if (Math.abs(diff) > 2) {
                    gameState.player.x += Math.sign(diff) * gameState.player.speed * dt;
                } else {
                    gameState.player.x = target;
                }
            }

            const cx = gameState.player.x + gameState.player.w / 2;
            const cy = gameState.player.y;

            // Ïä§ÌÇ¨ Î™®Îìú Ï≤òÎ¶¨
            if (gameState.skillTimer > 0) {
                gameState.skillTimer -= dt;
                document.getElementById('skill-display').textContent = `${gameState.skillMode}: ${gameState.skillTimer.toFixed(1)}s`;
            } else {
                gameState.skillMode = 'NORMAL';
                // Ïú†ÎèÑÌÉÑ Î™®Îìú, Î†àÏù¥Ï†Ä Î™®Îìú, Î£®ÎÇò Î™®Îìú ÌëúÏãú
                let displayText = '';
                if (gameState.isHomingMode) displayText = `HOMING: ${gameState.homingTimer.toFixed(1)}s`;
                else if (gameState.isLaserMode) displayText = `LASER: ${gameState.laserTimer.toFixed(1)}s`;
                else if (gameState.isLunarMode) displayText = 'LUNAR MODE';
                document.getElementById('skill-display').textContent = displayText;
            }

            // Ìô©Í∏à Í∏∞Ï≤¥ 3Í∞àÎûò Í≥µÍ≤©
            if (gameState.isTransformed && !gameState.isLaserMode && Math.random() < 0.06) {
                [-15, 0, 15].forEach(ox => gameState.bullets.push({ x: cx + ox - 4, y: cy - 10, w: 8, h: 18, speed: 620 }));
            }

            updateDrones(dt);

            // Î†àÏù¥Ï†Ä Î™®Îìú Ï†Å Ï≤òÎ¶¨ (SHOCKWAVE, METEORÎäî ÏÉÅÏáÑ Î∂àÍ∞Ä)
            if (gameState.isLaserMode) {
                const laserL = cx - 20, laserR = cx + 20;
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    if (en.type !== 'BULLET' && en.type !== 'METEOR' && en.type !== 'SHOCKWAVE' && en.x + en.w > laserL && en.x < laserR && en.y < cy) {
                        gameState.enemies.splice(i, 1);
                        gameState.score += 3;
                    }
                }
            }

            // Ï†Å Ï≤òÎ¶¨ Î£®ÌîÑ
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const en = gameState.enemies[i];

                if (en.type === 'BULLET' || en.type === 'SHOCKWAVE' || en.type === 'METEOR' || en.type === 'ENEMY_BULLET') {
                    en.x += (en.vx || 0) * dt;
                    en.y += (en.vy || 0) * dt;
                } else if (en.type === 'MINION') {
                    en.y += en.speed * dt;
                    en.time += dt * 3;
                    en.x += Math.sin(en.time) * 1.5;
                } else if (en.type === 'SHOOTER') {
                    // SHOOTER: ÏÉÅÎã® ÏßÑÏûÖ ‚Üí Ï¢åÏö∞ Ïù¥ÎèôÌïòÎ©∞ Ïó∞ÏÜç Î∞úÏÇ¨ ‚Üí ÌïòÍ∞ï Ìá¥Ïû•
                    en.phase = en.phase || 'ENTER';      // ENTER ‚Üí STRAFE ‚Üí EXIT
                    en.strafeDir = en.strafeDir || 1;    // Ï¢åÏö∞ Ïù¥Îèô Î∞©Ìñ•
                    en.shotsFired = en.shotsFired || 0;  // Î∞úÏÇ¨Ìïú Ï¥ùÏïå Ïàò
                    en.setsFired = en.setsFired || 0;    // Î∞úÏÇ¨Ìïú ÏÑ∏Ìä∏ Ïàò
                    en.shootTimer = en.shootTimer || 0;

                    if (en.phase === 'ENTER') {
                        // ÏÉÅÎã®(y=80)ÍπåÏßÄ ÏßÑÏûÖ
                        en.y += en.speed * dt * 0.8;
                        if (en.y >= 80) {
                            en.phase = 'STRAFE';
                            en.y = 80;
                        }
                    } else if (en.phase === 'STRAFE') {
                        // Ï¢åÏö∞ Ïù¥ÎèôÌïòÎ©∞ 0.1Ï¥à Í∞ÑÍ≤© 5Î∞ú Ïó∞ÏÜç Î∞úÏÇ¨ (ÎÇúÏù¥ÎèÑ ÌïòÌñ•)
                        en.x += en.strafeDir * 200 * dt;
                        if (en.x <= 20) en.strafeDir = 1;
                        if (en.x >= canvas.width - en.w - 20) en.strafeDir = -1;

                        en.shootTimer += dt;
                        if (en.shootTimer >= 0.1 && en.shotsFired < 5) {
                            gameState.enemies.push({
                                x: en.x + en.w / 2 - 5, y: en.y + en.h,
                                w: 10, h: 10, speed: 0, type: 'ENEMY_BULLET',
                                vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                            });
                            en.shotsFired++;
                            en.shootTimer = 0;
                        }

                        // 5Î∞ú Î∞úÏÇ¨ ÌõÑ ÏÑ∏Ìä∏ ÏôÑÎ£å
                        if (en.shotsFired >= 5) {
                            en.setsFired++;
                            en.shotsFired = 0;
                            en.shootTimer = -0.5;  // 0.5Ï¥à Ïø®Îã§Ïö¥

                            // 3ÏÑ∏Ìä∏ ÏôÑÎ£å Ïãú Ìá¥Ïû•
                            if (en.setsFired >= 3) {
                                en.phase = 'EXIT';
                            }
                        }
                    } else if (en.phase === 'EXIT') {
                        // Îπ†Î•¥Í≤å ÌïòÍ∞ïÌïòÎ©∞ Ìá¥Ïû•
                        en.y += en.speed * dt * 2.5;
                    }
                } else if (en.type === 'BOMBER') {
                    // BOMBER: ÌôîÎ©¥ Ï§ëÍ∞ÑÏóêÏÑú Ìè≠Î∞úÌïòÎ©∞ 8Î∞©Ìñ• ÌÉÑÌôò
                    en.y += en.speed * dt * 0.6;
                    if (en.y > 200 && !en.exploded) {
                        en.exploded = true;
                        for (let a = 0; a < 8; a++) {
                            const rad = (a * 45) * Math.PI / 180;
                            gameState.enemies.push({
                                x: en.x + en.w / 2 - 6, y: en.y + en.h / 2 - 6,
                                w: 12, h: 12, speed: 0, type: 'ENEMY_BULLET',
                                vx: Math.cos(rad) * 200, vy: Math.sin(rad) * 200,
                                amplitude: 0, turnRate: 0, time: 0
                            });
                        }
                        gameState.enemies.splice(i, 1);
                        continue;
                    }
                } else if (en.type === 'LASER_ENEMY') {
                    // LASER_ENEMY: Ï†ïÏßÄ ÌõÑ ÏàòÏßÅ Î†àÏù¥Ï†Ä
                    if (!en.locked) {
                        en.y += en.speed * dt * 0.5;
                        if (en.y > 80) {
                            en.locked = true;
                            en.chargeTimer = 0;
                        }
                    } else {
                        en.chargeTimer = (en.chargeTimer || 0) + dt;
                        if (en.chargeTimer > 1.0 && !en.fired) {
                            en.fired = true;
                            // ÏàòÏßÅ Î†àÏù¥Ï†Ä ÌÉÑÌôò Î∞úÏÇ¨
                            for (let ly = en.y + en.h; ly < canvas.height; ly += 30) {
                                gameState.enemies.push({
                                    x: en.x + en.w / 2 - 8, y: ly,
                                    w: 16, h: 25, speed: 0, type: 'ENEMY_BULLET',
                                    vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                                });
                            }
                        }
                        if (en.chargeTimer > 1.5) {
                            gameState.enemies.splice(i, 1);
                            continue;
                        }
                    }
                } else {
                    en.y += en.speed * dt;
                    if (en.type === 'ZIGZAG') { en.time += dt * 5; en.x += Math.sin(en.time) * en.amplitude; }
                    if (en.type === 'HOMING') { en.x += Math.sign(gameState.player.x + 10 - en.x - 15) * en.turnRate * dt; }
                }

                en.x = Math.max(-20, Math.min(canvas.width + 20, en.x));

                if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, en)) {
                    gameState.enemies.splice(i, 1);
                    if (gameState.isLunarMode) { gameState.isLunarMode = false; }
                    else { takeDamage(); }
                    continue;
                }
                // Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò Í∞ïÌôî - ÌôîÎ©¥ Î∞ñ Ï†Å Ï¶âÏãú Ï†úÍ±∞
                if (en.y > canvas.height + 50 || en.y < -100 || en.x < -80 || en.x > canvas.width + 80) {
                    gameState.enemies.splice(i, 1);
                    if (en.type !== 'BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'ENEMY_BULLET' && en.type !== 'METEOR') {
                        gameState.score += getEnemyScore(en.type);
                    }
                }
            }

            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const it = gameState.items[i];
                it.y += it.speed * dt;
                if (checkRectCollision(gameState.player, it)) {
                    if (it.type === 'DRONE') {
                        if (!gameState.isTransformed) {
                            gameState.drones.push({ offsetX: (gameState.drones.length === 0 ? -1 : 1) * 35, shootTimer: 0 });
                            if (gameState.drones.length >= 3) {
                                gameState.isTransformed = true;
                                gameState.drones = [];
                            }
                        }
                    } else if (it.type === 'BLASTER') {
                        // BLASTER ‚Üí Ïú†ÎèÑÌÉÑ Î™®ÎìúÎ°ú Î≥ÄÍ≤Ω (7Ï¥à)
                        if (gameState.isTransformed) {
                            gameState.isLaserMode = true;
                            gameState.laserTimer = 3.0;
                        } else {
                            gameState.isHomingMode = true;
                            gameState.homingTimer = 7.0;
                        }
                    } else if (it.type === 'LUNAR_ITEM') {
                        gameState.isLunarMode = true;
                    } else {
                        gameState.skillMode = it.type;
                        gameState.skillTimer = 5.0;
                    }
                    gameState.items.splice(i, 1);
                }
                if (it.y > canvas.height) gameState.items.splice(i, 1);
            }

            // Î£®ÎÇò Í∞ÄÎîîÏñ∏ Í≥µÏ†Ñ Î∞è Ï∂©Îèå Ï≤òÎ¶¨
            if (gameState.isLunarMode) {
                gameState.lunarAngle += dt * 180;  // Ï¥àÎãπ 180ÎèÑ ÌöåÏ†Ñ
                const rad = gameState.lunarAngle * Math.PI / 180;
                const guardianX = cx + Math.cos(rad) * 40 - 10;
                const guardianY = cy - 15 + Math.sin(rad) * 40 - 10;
                const guardian = { x: guardianX, y: guardianY, w: 20, h: 20 };

                // Í∞ÄÎîîÏñ∏Í≥º Ï†Å Ï∂©Îèå Ï≤òÎ¶¨
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    if (checkRectCollision(guardian, gameState.enemies[i])) {
                        gameState.enemies.splice(i, 1);
                        gameState.isLunarMode = false;
                        gameState.score += 3;
                        break;
                    }
                }
            }

            for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                const b = gameState.bullets[bi];
                if (b.isLunar) {
                    b.x += (b.vx || 0) * dt;
                    b.y += (b.vy || 0) * dt;
                } else if (b.isHoming) {
                    // Ïú†ÎèÑÌÉÑ: Î∞©Ìñ• Î≤°ÌÑ∞ÎåÄÎ°ú Ïù¥Îèô
                    b.x += (b.vx || 0) * dt;
                    b.y += (b.vy || 0) * dt;
                } else {
                    b.y -= b.speed * dt;
                }
                if (b.y < -20 || b.y > canvas.height + 20 || b.x < -20 || b.x > canvas.width + 20) {
                    gameState.bullets.splice(bi, 1); continue;
                }
                for (let ei = gameState.enemies.length - 1; ei >= 0; ei--) {
                    const en = gameState.enemies[ei];
                    // SHOCKWAVE, METEORÎäî ÏÉÅÏáÑ Î∂àÍ∞Ä
                    if (en.type === 'SHOCKWAVE' || en.type === 'METEOR') continue;
                    if (checkRectCollision(b, en)) {
                        gameState.enemies.splice(ei, 1); gameState.bullets.splice(bi, 1); gameState.score += 2; break;
                    }
                }
            }

            let targetProgress = 0;
            if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) {
                targetProgress = 1 - (gameState.boss.hp / gameState.boss.maxHp);
            } else if (gameState.survivalMode) {
                targetProgress = 1 - (gameState.enemies.length / gameState.survivalStartCount);
            } else {
                targetProgress = (30 - gameState.stageTimer) / 30;
            }
            gameState.progressDisplay += (targetProgress - gameState.progressDisplay) * dt * 5;

            // ÌÉÄÏù¥Î®∏ Ïà®ÍπÄ - SURVIVE/BOSS ÌëúÏãúÎßå Ïú†ÏßÄ
            let stageDisplay = lvl.isBoss
                ? (gameState.bossPhase === 'BOSS' ? 'BOSS!' : (gameState.bossPhase === 'SURVIVAL' ? 'SURVIVE!' : ''))
                : (gameState.survivalMode ? 'SURVIVE!' : '');
            document.getElementById('stage-info').textContent = `STAGE ${gameState.currentStage}${stageDisplay ? ' | ' + stageDisplay : ''}`;
        }

        function checkRectCollision(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
        }

        function drawProgressBar() {
            const lvl = levels[gameState.currentStage - 1];
            const barWidth = canvas.width * 0.8;
            const barHeight = 8;  // Îçî ÎëêÍªçÍ≤å
            const barX = (canvas.width - barWidth) / 2;
            const barY = canvas.height - 16;

            // Î∞∞Í≤Ω
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // ÌïÑÏÇ¥Í∏∞ Í≤åÏù¥ÏßÄ ÌëúÏãú
            const ultProgress = Math.min(gameState.ultGauge, 1);

            if (ultProgress >= 1) {
                // ÏôÑÏ∂© Ïãú Î¨¥ÏßÄÍ∞ú Í∑∏ÎùºÎç∞Ïù¥ÏÖò + ÍπúÎπ°ÏûÑ
                const grad = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                const offset = (Date.now() / 20) % 360;
                for (let i = 0; i <= 6; i++) {
                    const hue = (offset + i * 60) % 360;
                    grad.addColorStop(i / 6, `hsl(${hue}, 100%, 60%)`);
                }
                const pulse = 0.7 + Math.sin(Date.now() / 100) * 0.3;
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = grad;
            } else {
                // Ï∂©Ï†Ñ Ï§ë: Î≥¥ÎùºÏÉâ Í≤åÏù¥ÏßÄ
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#a0f';
                ctx.fillStyle = '#c4f';
            }

            ctx.fillRect(barX, barY, barWidth * ultProgress, barHeight);

            // ULT ÌÖçÏä§Ìä∏ ÌëúÏãú
            ctx.shadowBlur = 0;
            ctx.fillStyle = ultProgress >= 1 ? '#fff' : '#aaa';
            ctx.font = 'bold 10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(ultProgress >= 1 ? 'üåà PRESS SPACE üåà' : `ULT: ${Math.floor(ultProgress * 100)}%`, canvas.width / 2, barY - 4);

            ctx.shadowBlur = 0;
        }

        function drawGiftBox(it) {
            const x = it.x, y = it.y, w = it.w, h = it.h;

            // LUNAR_ITEMÏùÄ Ï¥àÏäπÎã¨ ÏïÑÏù¥ÏΩòÏúºÎ°ú ÌäπÎ≥Ñ Î†åÎçîÎßÅ
            if (it.type === 'LUNAR_ITEM') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath();
                ctx.arc(x + w / 2, y + h / 2, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(x + w / 2 + 6, y + h / 2 - 4, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            const boxColor = it.type === 'DRONE' ? '#0ff' : (it.type === 'SHIELD' ? '#0f0' : '#f0f');

            ctx.shadowBlur = 12;
            ctx.shadowColor = boxColor;

            ctx.fillStyle = boxColor;
            ctx.fillRect(x + 2, y + 6, w - 4, h - 6);

            ctx.fillStyle = '#fff';
            ctx.fillRect(x + w / 2 - 2, y + 6, 4, h - 6);
            ctx.fillRect(x + 2, y + h / 2 + 2, w - 4, 4);

            ctx.fillStyle = boxColor;
            ctx.fillRect(x, y + 4, w, 6);

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x + w / 2 - 5, y + 4, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w / 2 + 5, y + 4, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w / 2, y + 2, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        function drawAlien(en, stage) {
            const cx = en.x + en.w / 2, cy = en.y + en.h / 2;
            const isCold = stage <= 5;

            // ENEMY_BULLET Î†åÎçîÎßÅ
            if (en.type === 'ENEMY_BULLET') {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f44';
                ctx.fillStyle = '#f66';
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // SHOOTER Î†åÎçîÎßÅ (Î∂âÏùÄ ÏÇºÍ∞ÅÌòï)
            if (en.type === 'SHOOTER') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f44';
                ctx.fillStyle = '#f66';
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy + 15);
                ctx.lineTo(cx - 12, cy - 10);
                ctx.lineTo(cx + 12, cy - 10);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
                // Ìè¨Ïã† ÌëúÏãú
                ctx.fillRect(cx - 3, cy + 12, 6, 8);
                ctx.shadowBlur = 0;
                return;
            }

            // BOMBER Î†åÎçîÎßÅ (Ï£ºÌô© Ïõê)
            if (en.type === 'BOMBER') {
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.15;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#f80';
                ctx.fillStyle = '#fa0';
                ctx.beginPath();
                ctx.arc(cx, cy, 14 * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return;
            }

            // LASER_ENEMY Î†åÎçîÎßÅ (Î≥¥ÎùºÏÉâ ÏÇ¨Í∞ÅÌòï + Ï∞®Ïßï Ìö®Í≥º)
            if (en.type === 'LASER_ENEMY') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#a0f';
                ctx.fillStyle = '#c4f';
                ctx.fillRect(en.x, en.y, en.w, en.h);
                if (en.locked && !en.fired) {
                    // Ï∞®Ïßï ÌëúÏãú
                    const chargeProgress = Math.min((en.chargeTimer || 0) / 1.0, 1);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(en.x, en.y + en.h, en.w, 3);
                    ctx.fillStyle = '#f0f';
                    ctx.fillRect(en.x, en.y + en.h, en.w * chargeProgress, 3);
                }
                ctx.shadowBlur = 0;
                return;
            }

            ctx.shadowBlur = 12;
            ctx.shadowColor = isCold ? '#8ef' : '#f80';
            ctx.fillStyle = isCold ? '#aef' : '#f64';
            ctx.strokeStyle = isCold ? '#0ff' : '#f40';
            ctx.lineWidth = 2;

            ctx.beginPath();
            if (en.type === 'MINION') {
                ctx.shadowColor = '#f0f';
                ctx.fillStyle = '#f0f';
                ctx.fillRect(en.x + 4, en.y + 4, en.w - 8, en.h - 8);
                return;
            } else if (isCold) {
                if (en.type === 'HOMING') {
                    const rot = Date.now() / 200;
                    for (let i = 0; i < 6; i++) {
                        const a = rot + i * Math.PI / 3;
                        const px = cx + Math.cos(a) * 14;
                        const py = cy + Math.sin(a) * 14;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else if (en.type === 'ZIGZAG') {
                    for (let i = 0; i < 8; i++) {
                        const r = i % 2 === 0 ? 15 : 7;
                        const a = i * Math.PI / 4;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else {
                    ctx.moveTo(cx, cy - 14);
                    ctx.lineTo(cx + 11, cy);
                    ctx.lineTo(cx, cy + 14);
                    ctx.lineTo(cx - 11, cy);
                }
            } else {
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.12;
                if (en.type === 'HOMING') {
                    const rot = Date.now() / 150;
                    for (let i = 0; i < 10; i++) {
                        const r = i % 2 === 0 ? 16 * pulse : 8;
                        const a = rot + i * Math.PI / 5;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else if (en.type === 'ZIGZAG') {
                    for (let i = 0; i < 6; i++) {
                        const r = i % 2 === 0 ? 15 * pulse : 6;
                        const a = i * Math.PI / 3 - Math.PI / 2;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                } else {
                    ctx.moveTo(cx, cy + 14 * pulse);
                    ctx.lineTo(cx - 13, cy - 9);
                    ctx.lineTo(cx, cy - 4);
                    ctx.lineTo(cx + 13, cy - 9);
                }
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }

        function drawLunarBoss(boss) {
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            ctx.shadowBlur = 40; ctx.shadowColor = '#88f';
            ctx.fillStyle = '#aaf';
            ctx.beginPath(); ctx.arc(cx, cy, 45, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#669';
            [[20, -12, 9], [35, 15, 7], [-15, 8, 8], [-25, -5, 5]].forEach(([ox, oy, r]) => {
                ctx.beginPath(); ctx.arc(cx + ox, cy + oy, r, 0, Math.PI * 2); ctx.fill();
            });
            ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
            ctx.fillStyle = '#4af'; ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText('LUNAR', cx, boss.y - 7);
        }

        function drawSunBoss(boss) {
            const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
            ctx.shadowBlur = boss.isSupernova ? 80 : 60;
            ctx.shadowColor = boss.isSupernova ? '#f0f' : '#f80';
            const grad = ctx.createRadialGradient(cx, cy, 15, cx, cy, 50);
            if (boss.isSupernova) {
                grad.addColorStop(0, '#fff'); grad.addColorStop(0.5, '#f0f'); grad.addColorStop(1, '#80f');
            } else {
                grad.addColorStop(0, '#ff0'); grad.addColorStop(0.6, '#f80'); grad.addColorStop(1, '#f00');
            }
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, 48, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = boss.isSupernova ? '#f8f' : '#fa0'; ctx.lineWidth = 4;
            for (let i = 0; i < 12; i++) {
                const a = (i * 30 + Date.now() / 25) * Math.PI / 180;
                ctx.beginPath(); ctx.moveTo(cx + Math.cos(a) * 48, cy + Math.sin(a) * 48);
                ctx.lineTo(cx + Math.cos(a) * 72, cy + Math.sin(a) * 72); ctx.stroke();
            }
            ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
            ctx.fillStyle = boss.isSupernova ? '#f0f' : '#f40';
            ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
            ctx.fillText(boss.isSupernova ? 'SUPERNOVA' : 'SUN', cx, boss.y - 7);
        }

        function drawLaser() {
            if (!gameState.isLaserMode) return;
            const cx = gameState.player.x + gameState.player.w / 2;
            const laserWidth = 40;

            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0';
            const grad = ctx.createLinearGradient(cx - laserWidth / 2, 0, cx + laserWidth / 2, 0);
            grad.addColorStop(0, 'rgba(255,255,0,0.3)');
            grad.addColorStop(0.5, 'rgba(255,255,0,0.9)');
            grad.addColorStop(1, 'rgba(255,255,0,0.3)');
            ctx.fillStyle = grad;
            ctx.fillRect(cx - laserWidth / 2, 0, laserWidth, gameState.player.y);

            ctx.fillStyle = '#fff';
            ctx.fillRect(cx - 5, 0, 10, gameState.player.y);
            ctx.shadowBlur = 0;
        }

        function draw() {
            const lvl = levels[gameState.currentStage - 1];
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // stageClearing Ï§ëÏóêÎèÑ ÏïÑÎûò Î†åÎçîÎßÅ Í≥ÑÏÜç Ïã§Ìñâ (ÏïÑÏù¥ÌÖú ÌöçÎìù ÏúÑÌï¥)
            if (gameState.stageClearing) {
                const nextStage = gameState.currentStage + 1;
                ctx.fillStyle = lvl.theme; ctx.font = 'bold 36px Orbitron'; ctx.textAlign = 'center';
                ctx.shadowBlur = 20; ctx.shadowColor = lvl.theme;
                ctx.fillText(nextStage <= 10 ? `NEXT: STAGE ${nextStage}` : 'üéâ VICTORY!', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
                // return Ï†úÍ±∞ - ÏïÑÎûò Î†åÎçîÎßÅ Í≥ÑÏÜç
            }

            // SURVIVE Î¨∏Íµ¨ ÌëúÏãú (ÏùºÎ∞ò Ïä§ÌÖåÏù¥ÏßÄÎßå)
            if (gameState.survivalMode && !lvl.isBoss) {
                ctx.fillStyle = '#f55'; ctx.font = 'bold 28px Orbitron'; ctx.textAlign = 'center';
                ctx.shadowBlur = 15; ctx.shadowColor = '#f55';
                ctx.fillText('SURVIVE!', canvas.width / 2, 80); ctx.shadowBlur = 0;
            }


            drawLaser();
            drawDrones(); drawPlayer();

            // Î£®ÎÇò Í∞ÄÎîîÏñ∏ Î†åÎçîÎßÅ
            if (gameState.isLunarMode) {
                const px = gameState.player.x + gameState.player.w / 2;
                const py = gameState.player.y;
                const rad = gameState.lunarAngle * Math.PI / 180;
                const gx = px + Math.cos(rad) * 40;
                const gy = py - 15 + Math.sin(rad) * 40;

                ctx.shadowBlur = 20;
                ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath();
                ctx.arc(gx, gy, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(gx + 5, gy - 3, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            if (gameState.boss) {
                if (gameState.boss.type === 'LUNAR') drawLunarBoss(gameState.boss);
                else if (gameState.boss.type === 'SUN') drawSunBoss(gameState.boss);

                // DANGER Í≤ΩÍ≥† ÌëúÏãú (LUNAR Î≥¥Ïä§)
                if (gameState.dangerWarning > 0 && gameState.boss.type === 'LUNAR') {
                    const blink = Math.floor(Date.now() / 100) % 2 === 0;
                    if (blink) {
                        ctx.fillStyle = '#f00';
                        ctx.font = 'bold 16px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#f00';
                        ctx.fillText('‚ö† DANGER ‚ö†', gameState.boss.x + gameState.boss.w / 2, gameState.boss.y - 35);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            gameState.enemies.forEach(en => {
                if (en.type === 'BULLET') {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = gameState.currentStage <= 5 ? '#8af' : '#f84';
                    ctx.fillStyle = ctx.shadowColor;
                    ctx.beginPath(); ctx.arc(en.x + en.w / 2, en.y + en.h / 2, en.w / 2, 0, Math.PI * 2); ctx.fill();
                } else if (en.type === 'SHOCKWAVE') {
                    // ÏõîÍ¥ë Ï∂©Í≤©Ìåå Î†åÎçîÎßÅ + Î∞òÏßùÏûÑ Ìö®Í≥º (ÏÉÅÏáÑ Î∂àÍ∞Ä ÌëúÏãú)
                    const shimmer = 1 + Math.sin(Date.now() / 50) * 0.3;
                    ctx.shadowBlur = 15 * shimmer;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(en.x + en.w / 2, en.y + en.h / 2, (en.w / 2 + 2) * shimmer, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(en.x + en.w / 2 + 5, en.y + en.h / 2 - 3, en.w / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Î∞òÏßùÏûÑ ÌëúÏãú
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('‚ú®', en.x + en.w - 5, en.y + 5);
                } else if (en.type === 'METEOR') {
                    // Ïú†ÏÑ± Î†åÎçîÎßÅ - Î∂àÌÉÄÎäî Íº¨Î¶¨ Ìö®Í≥º + Î∞òÏßùÏûÑ (ÏÉÅÏáÑ Î∂àÍ∞Ä)
                    const mx = en.x + en.w / 2, my = en.y + en.h / 2;
                    const shimmer = 1 + Math.sin(Date.now() / 50) * 0.2;
                    // Íº¨Î¶¨
                    ctx.shadowBlur = 20 * shimmer;
                    ctx.shadowColor = '#f80';
                    const grad = ctx.createLinearGradient(mx, my - 15, mx, my + 25);
                    grad.addColorStop(0, 'rgba(255,100,50,0.8)');
                    grad.addColorStop(1, 'rgba(255,200,100,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(mx - 10, my);
                    ctx.lineTo(mx, my - 20);
                    ctx.lineTo(mx + 10, my);
                    ctx.fill();
                    // Î≥∏Ï≤¥
                    ctx.fillStyle = '#88f';
                    ctx.beginPath();
                    ctx.arc(mx, my, 14 * shimmer, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(mx - 3, my - 3, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // Î∞òÏßùÏûÑ ÌëúÏãú
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.fillText('‚ú®', mx + 10, my - 10);
                    ctx.shadowBlur = 0;
                } else {
                    drawAlien(en, gameState.currentStage);
                }
            });

            gameState.items.forEach(it => drawGiftBox(it));

            ctx.shadowBlur = 5; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
            gameState.bullets.forEach(b => {
                if (b.isLunar) {
                    // ÌÅ¨Î†àÏÑºÌä∏ Î∞òÎã¨ ÌÉÑÌôò
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(b.x + 6, b.y + 6, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(b.x + 9, b.y + 4, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (b.isHoming) {
                    // Ïú†ÎèÑÌÉÑ - Î≥¥ÎùºÏÉâ ÏÇºÍ∞ÅÌòï
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#c4f';
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w / 2, b.y);
                    ctx.lineTo(b.x, b.y + b.h);
                    ctx.lineTo(b.x + b.w, b.y + b.h);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                }
            });
            ctx.shadowBlur = 0;

            // Î¨¥ÏßÄÍ∞ú ÌååÎèô Î†åÎçîÎßÅ
            if (gameState.rainbowWave) {
                const waveY = gameState.rainbowWave.y;
                const waveHeight = 30;

                // Î¨¥ÏßÄÍ∞ú Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                const grad = ctx.createLinearGradient(0, waveY - waveHeight / 2, 0, waveY + waveHeight / 2);
                const offset = (Date.now() / 10) % 360;
                for (let i = 0; i <= 6; i++) {
                    const hue = (offset + i * 60) % 360;
                    grad.addColorStop(i / 6, `hsla(${hue}, 100%, 60%, 0.9)`);
                }

                ctx.shadowBlur = 40;
                ctx.shadowColor = '#fff';
                ctx.fillStyle = grad;
                ctx.fillRect(0, waveY - waveHeight / 2, canvas.width, waveHeight);

                // Ï§ëÏïô Î∞ùÏùÄ ÎùºÏù∏
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillRect(0, waveY - 2, canvas.width, 4);
                ctx.shadowBlur = 0;
            }

            // ÏãúÍ∞Ñ Î≥¥ÎÑàÏä§ ÌëúÏãú
            if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                const alpha = Math.min(1, gameState.timeBonusDisplay.timer);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 24px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0';
                ctx.fillText(`TIME BONUS: +${gameState.timeBonusDisplay.amount}`, canvas.width / 2, 130);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            drawProgressBar();
        }

        function drawPlayer() {
            const p = gameState.player, cx = p.x + p.w / 2, cy = p.y + p.h / 2;

            if (gameState.isInvincible && Math.floor(gameState.invincibilityTimer * 10) % 2 === 0) ctx.globalAlpha = 0.3;
            if (gameState.downgradeFlash > 0) ctx.globalAlpha = 0.5 + Math.sin(gameState.downgradeFlash * 20) * 0.5;

            // ÌïÑÏÇ¥Í∏∞ Í≤åÏù¥ÏßÄ 100% Ïãú Î¨¥ÏßÄÍ∞ú Î∞òÏßùÏûÑ
            let playerColor;
            if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                const hue = (Date.now() / 5) % 360;  // Îπ†Î•¥Í≤å Î¨¥ÏßÄÍ∞úÏÉâ ÏàúÌôò
                playerColor = `hsl(${hue}, 100%, 60%)`;
                ctx.shadowBlur = 40 + Math.sin(Date.now() / 100) * 10;
            } else {
                const baseColor = gameState.isTransformed ? '#FFD700' : '#C0C0C0';
                ctx.shadowBlur = gameState.isTransformed ? 30 : 20;
                playerColor = gameState.isLaserMode ? '#ff0' : (gameState.skillMode === 'SHIELD' ? '#0f0' : (gameState.isHomingMode ? '#c4f' : baseColor));
            }
            ctx.shadowColor = playerColor;
            ctx.fillStyle = playerColor; ctx.strokeStyle = playerColor; ctx.lineWidth = 2;

            ctx.beginPath();
            if (gameState.isTransformed) {
                ctx.moveTo(cx, cy - 28);
                ctx.lineTo(cx - 22, cy + 18); ctx.lineTo(cx - 8, cy + 10);
                ctx.lineTo(cx, cy + 14);
                ctx.lineTo(cx + 8, cy + 10); ctx.lineTo(cx + 22, cy + 18);
            } else {
                ctx.moveTo(cx, cy - 25); ctx.lineTo(cx - 18, cy + 15); ctx.lineTo(cx - 5, cy + 8);
                ctx.lineTo(cx, cy + 12); ctx.lineTo(cx + 5, cy + 8); ctx.lineTo(cx + 18, cy + 15);
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = gameState.isTransformed ? '#ff0' : '#f80';
            ctx.beginPath();
            const flameH = gameState.isTransformed ? 25 : 20;
            ctx.moveTo(cx - 3, cy + 12); ctx.lineTo(cx, cy + flameH + Math.random() * 6); ctx.lineTo(cx + 3, cy + 12);
            ctx.closePath(); ctx.fill();

            if (gameState.isTransformed) {
                ctx.fillStyle = gameState.isLaserMode ? '#ff0' : '#FFD700';
                ctx.beginPath(); ctx.arc(cx - 20, cy + 5, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx + 20, cy + 5, 5, 0, Math.PI * 2); ctx.fill();
            }

            ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
        }

        function drawDrones() {
            if (gameState.isTransformed) return;
            gameState.drones.forEach(drone => {
                const dx = gameState.player.x + 10 + drone.offsetX, dy = gameState.player.y + 15;
                ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff';
                ctx.beginPath(); ctx.moveTo(dx, dy - 12); ctx.lineTo(dx - 10, dy + 6); ctx.lineTo(dx, dy + 2); ctx.lineTo(dx + 10, dy + 6);
                ctx.closePath(); ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function gameOver() {
            gameState.isRunning = false;
            showResultScreen('MISSION FAILED');
        }

        function saveAndRestart() {
            const name = document.getElementById('initial-input').value.toUpperCase() || 'AAA';
            const finalScore = Math.round(gameState.score);  // ÏÜåÏàòÏ†ê Î∞òÏò¨Î¶º
            saveToFirebase(name, finalScore, gameState.currentStage);
            setTimeout(() => location.reload(), 500);
        }

        let lastTime = performance.now();
        function gameLoop(now) {
            const dt = (now - lastTime) / 1000; lastTime = now;
            spawnEntities(dt); update(dt); draw();
            if (gameState.isRunning) requestAnimationFrame(gameLoop);
        }

        window.addEventListener('firebase-ready', initFirebaseRanking);
        setTimeout(() => { if (!firebaseReady) initFirebaseRanking(); }, 1000);
    </script>
</body>

</html>
