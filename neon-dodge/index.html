 <!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dodge - Legend Edition</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 450px;
            /* ë„ˆë¹„ ê³ ì • */
            height: 800px;
            /* ë†’ì´ ê³ ì • */
            overflow: hidden;
            /* ì‚ì ¸ë‚˜ê°€ëŠ” ê²ƒ ìˆ¨ê¹€ */
            transform-origin: center center;
            /* ì¤‘ì•™ ê¸°ì¤€ í™•ëŒ€/ì¶•ì†Œ */

            /* í„°ì¹˜ ë°©ì§€ ì˜µì…˜ ìœ ì§€ */
            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            background: #111;
            border: 3px solid #0ff;
            display: block;
            box-shadow: 0 0 20px #0ff;

            /* [CDSO ìˆ˜ì •] í…Œë‘ë¦¬ í¬í•¨ í¬ê¸° ê³„ì‚° ë° ì»¨í…Œì´ë„ˆ ë§ì¶¤ */
            box-sizing: border-box;
            /* í…Œë‘ë¦¬ë¥¼ 450px ì•ˆì— í¬í•¨ì‹œí‚´ */
            width: 100%;
            /* ì»¨í…Œì´ë„ˆ ë„ˆë¹„ì— ë”± ë§ì¶¤ */
            height: 100%;
            /* ì»¨í…Œì´ë„ˆ ë†’ì´ì— ë”± ë§ì¶¤ */


            touch-action: none !important;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* ëª¨ë°”ì¼ ë°˜ì‘í˜• (JSë¡œ ì œì–´í•˜ê¸° ìœ„í•´ ì£¼ì„ ì²˜ë¦¬í•¨) */
        /*
        @media (max-width: 500px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
                max-height: 100vh;
                border-width: 1px;
            }

            #game-container {
                width: 100vw;
            }
        }
        */
        /* PC í™”ë©´(ë„ˆë¹„ 501px ì´ìƒ)ì—ì„œëŠ” ì„¤ì • ë²„íŠ¼ ìˆ¨ê¹€ */
        @media (min-width: 501px) {
            #settings-ui {
                display: none !important;
            }
        }



        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
        }

        /* [êµì²´] ì „ì²´ UI íŒ¨ë„ (ì¢Œì¸¡ ìƒë‹¨ ì •ë ¬ì„ ìœ„í•´ ìˆ˜ì •) */
        /* [UI íŒ¨ë„ ì „ì²´] */
        #ui-layer-v2 {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            padding: 15px;
            
            /* â–¼â–¼â–¼ [ìˆ˜ì • í•µì‹¬] ì²˜ìŒì—” ìˆ¨ê²¨ë‘¡ë‹ˆë‹¤! â–¼â–¼â–¼ */
            display: none; 
            /* â–²â–²â–² ê²Œì„ ì‹œì‘ ì‹œ JSë¡œ flexë¡œ ë°”ê¿€ ê²ë‹ˆë‹¤ â–²â–²â–² */

            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 9999;
            box-sizing: border-box;
        }

        .top-left-v2 {
            display: flex;
            flex-direction: column; /* ì„¸ë¡œ ì •ë ¬ í™•ì‹¤í•˜ê²Œ */
            align-items: flex-start;
        }

        #lives-v2 {
            font-size: 1.2em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 5px #f00;
            margin-bottom: 8px; /* ì•„ë˜ìª½ ì—¬ë°± ê°•ì œ */
            display: block;
        }

        #hud-panel-v2 {
            position: relative; /* absolute ì•„ë‹˜! íë¦„ì— ë”°ë¦„ */
            width: 140px;
            padding: 6px 10px;
            background: rgba(0, 15, 30, 0.75);
            border-left: 3px solid #0ff;
            border-radius: 0 5px 5px 0;
            margin-top: 0; /* lives-v2ì˜ margin-bottomìœ¼ë¡œ ê°„ê²© í™•ë³´ */
            box-shadow: 0 0 10px rgba(0,255,255,0.1);
        }

        .hud-row-v2 {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.8em;
            color: #fff;
            font-weight: bold;
        }

        .hud-bar-track {
            width: 100%; height: 4px;
            background: rgba(255,255,255,0.2);
        }

        #hud-progress {
            height: 100%; width: 0%;
            background: #0ff;
            transition: width 0.1s;
        }

        /* ê¸°ì¡´ì— ìˆë˜ í° HUD ìŠ¤íƒ€ì¼ë“¤ ìˆ¨ê¹€ */
        .hud-header, .hud-icon { display: none; }

        #current-score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff;
            pointer-events: none;
            z-index: 10;
        }

        #leaderboard {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            font-size: 1em;
            width: 320px;
        }

        #leaderboard h3 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-shadow: 0 0 10px #0ff;
        }

        /* [ìˆ˜ì •] ë‚´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ì—ë„ ë™ì¼í•œ ìŠ¤íƒ€ì¼ ì ìš© */
        #leaderboard li,
        #my-rank-list li,
        #result-rank-list li {
            margin: 8px 0;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            list-style: none;
            /* ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ì œê±° */
        }

        /* ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ë„ ë™ì¼í•˜ê²Œ ì ìš© */
        #my-rank-list,
        #result-rank-list {
            padding: 0;
            margin: 15px 0;
            /* ê°„ê²© í™•ë³´ */
            width: 320px;
        }




        /* [ì¶”ê°€] ë‚´ ìˆœìœ„ ì „ìš© - ë¶‰ì€ìƒ‰ í…Œë‘ë¦¬ ë° ìŠ¤íƒ€ì¼ */
        li.rank-me {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.2), rgba(100, 0, 0, 0.1)) !important;
            border: 2px solid #ff0000 !important;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            font-weight: bold;
            margin-top: 20px !important;
            /* ìœ„ìª½ TOP5ì™€ ê°„ê²© ë„ìš°ê¸° */
            animation: pulseRed 2s infinite;
        }

        /* [ì¶”ê°€] ë¶‰ì€ìƒ‰ ë°°ì§€ */
        .rank-me .rank-badge {
            background: linear-gradient(135deg, #ff0000, #990000);
            color: #fff;
            box-shadow: 0 0 10px #f00;
        }

        @keyframes pulseRed {
            0% {
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 0, 0, 0.7);
            }

            100% {
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
            }
        }

        /* [ì¶”ê°€] ë‚´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #my-rank-list {
            padding: 0;
            margin: 0;
            width: 320px;
        }



        #leaderboard li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* 1ë“± - ê³¨ë“œ ê°•ì¡° */
        #leaderboard li.rank-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 180, 0, 0.15));
            border: 2px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            font-size: 1.15em;
            font-weight: bold;
        }

        /* 2ë“± - ì‹¤ë²„ */
        #leaderboard li.rank-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(150, 150, 150, 0.1));
            border: 1px solid #c0c0c0;
        }

        /* 3ë“± - ë¸Œë¡ ì¦ˆ */
        #leaderboard li.rank-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(180, 100, 40, 0.1));
            border: 1px solid #cd7f32;
        }

        /* ì‹ ê·œ ìœ ì € í•˜ì´ë¼ì´íŠ¸ */
        #leaderboard li.new-user {
            animation: newUserPulse 1.5s ease infinite;
            border-color: #0ff !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        @keyframes newUserPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            }
        }

        .rank-badge {
            min-width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
        }

        .rank-1 .rank-badge {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .rank-2 .rank-badge {
            background: linear-gradient(135deg, #c0c0c0, #888);
            color: #000;
        }

        .rank-3 .rank-badge {
            background: linear-gradient(135deg, #cd7f32, #a05a20);
            color: #fff;
        }

        .rank-4 .rank-badge,
        .rank-5 .rank-badge {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .player-name {
            flex: 1;
            text-align: left;
            color: #fff;
        }

        .player-score {
            font-weight: bold;
            color: #0ff;
            margin-right: 10px;
        }

        .player-stage {
            color: #888;
            font-size: 0.85em;
        }

        /* ê²°ê³¼ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px 40px;
            border: 2px solid #f0f;
            box-shadow: 0 0 20px #f0f, inset 0 0 15px rgba(255, 0, 255, 0.1);
            background: rgba(20, 0, 30, 0.9);
            animation: slideDown 0.5s ease-out, glitch 0.1s infinite alternate;
        }

        .result-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
            margin-bottom: 20px;
            animation: textGlitch 2s infinite;
        }

        .result-stats {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(0, 255, 255, 0.05);
            border-left: 3px solid #0ff;
        }

        .stat-row .label {
            font-size: 0.9em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        #initial-input {
            background: transparent;
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 2em;
            text-align: center;
            width: 150px;
            outline: none;
            text-transform: uppercase;
            margin-top: 20px;
            animation: inputPulse 1.5s ease-in-out infinite;
        }

        button {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 25px;
            cursor: pointer;
            font-size: 1.2em;
            margin-top: 20px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 25px #0ff;
        }

        .active-skill {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #f0f;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes slideDown {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes glitch {
            0% {
                transform: translate(0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, -1px);
            }

            75% {
                transform: translate(-1px, -1px);
            }

            100% {
                transform: translate(1px, 1px);
            }
        }

        @keyframes textGlitch {

            0%,
            90%,
            100% {
                text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
                clip-path: none;
            }

            92% {
                text-shadow: -3px 0 #0ff, 3px 0 #f0f;
                clip-path: inset(20% 0 30% 0);
            }

            94% {
                text-shadow: 3px 0 #0ff, -3px 0 #f0f;
                clip-path: inset(50% 0 10% 0);
            }

            96% {
                text-shadow: -2px 0 #0ff, 2px 0 #f0f;
                clip-path: inset(10% 0 60% 0);
            }

            98% {
                text-shadow: 2px 0 #0ff, -2px 0 #f0f;
                clip-path: inset(40% 0 20% 0);
            }
        }

        @keyframes inputPulse {

            0%,
            100% {
                box-shadow: 0 0 5px #f0f;
                border-color: #f0f;
            }

            50% {
                box-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
                border-color: #fff;
            }
        }

        /* ê²°ê³¼ í™”ë©´ ìŠ¬ë¼ì´ë“œ ì¸ */
        #rank-input-screen.show {
            animation: screenGlitchIn 0.3s ease-out;
        }

        @keyframes screenGlitchIn {
            0% {
                opacity: 0;
            }

            10% {
                opacity: 1;
                transform: translateX(-5px);
            }

            20% {
                transform: translateX(5px);
            }

            30% {
                transform: translateX(-3px);
            }

            40% {
                transform: translateX(3px);
            }

            50% {
                transform: translateX(-1px);
            }

            60% {
                transform: translateX(1px);
            }

            100% {
                transform: translateX(0);
            }
        }

        /* [CDSO ì¶”ê°€] ì„¤ì • ë²„íŠ¼ ìŠ¤íƒ€ì¼ (PCì—ì„œëŠ” ìˆ¨ê¹€, ëª¨ë°”ì¼ì—ì„œëŠ” ë…¸ì¶œ) */
        #setting-btn {
            display: none;
            /* ê¸°ë³¸ê°’: PCì—ì„œëŠ” ì•ˆ ë³´ì„ */
            margin-top: 15px;
            font-size: 0.9em;
            background: transparent;
            border: 2px solid #888;
            color: #aaa;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px #000;
        }

        #setting-btn:hover {
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* ëª¨ë°”ì¼ í™”ë©´ì—ì„œë§Œ ë²„íŠ¼ ë³´ì´ê¸° */
        @media (max-width: 500px) {
            #setting-btn {
                display: block !important;
            }
        }

        /* [CDSO Patch: ì‹œì¦Œ 2 ë°°ì§€ ë””ìì¸] */
        .season-badge {
            display: inline-block;
            margin-top: -10px;
            /* íƒ€ì´í‹€ê³¼ ê°„ê²© ì¢íˆê¸° */
            margin-bottom: 20px;
            /* ë­í‚¹íŒê³¼ ê°„ê²© ë²Œë¦¬ê¸° */
            padding: 5px 15px;

            font-size: 16px;
            font-weight: bold;
            letter-spacing: 3px;
            /* ê¸€ì ê°„ê²© ë„“ê²Œ */
            color: #00fff2;
            /* ì‚¬ì´ë²„í‘í¬ ì²­ë¡ìƒ‰ */

            border: 2px solid #00fff2;
            border-radius: 15px;
            /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
            background: rgba(0, 255, 242, 0.15);
            /* ë°˜íˆ¬ëª… ë°°ê²½ */

            box-shadow: 0 0 15px rgba(0, 255, 242, 0.5);
            /* ë„¤ì˜¨ ê´‘ì› íš¨ê³¼ */
            text-shadow: 0 0 5px #00fff2;

            animation: badgePulse 2s infinite alternate;
            /* ìˆ¨ì‰¬ëŠ” íš¨ê³¼ */
        }

        /* ë°°ì§€ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes badgePulse {
            0% {
                transform: scale(1.0);
                opacity: 0.8;
                box-shadow: 0 0 10px #00fff2;
            }

            100% {
                transform: scale(1.05);
                opacity: 1.0;
                box-shadow: 0 0 20px #00fff2, inset 0 0 10px rgba(0, 255, 242, 0.5);
            }
        }

        /* [CDSO Design] ì‚¬ì´ë²„í‘í¬ HUD ìŠ¤íƒ€ì¼ */
        #hud-panel {
            position: absolute;
            bottom: 30px;
            left: 20px;
            width: 220px;
            padding: 12px 15px;
            
            /* ìœ ë¦¬ ì§ˆê° ë°°ê²½ */
            background: rgba(10, 20, 30, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            
            /* í…Œë‘ë¦¬ ë° ì¥ì‹ */
            border-left: 4px solid #0ff;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 0 15px 0 0; /* ìš°ì¸¡ ìƒë‹¨ë§Œ ë‘¥ê¸€ê²Œ */
            
            /* í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            pointer-events: none; /* í´ë¦­ í†µê³¼ */
            z-index: 50;
            
            /* ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ */
            transform: skewX(-10deg); /* ì•½ê°„ ê¸°ìš¸ì—¬ì„œ ì†ë„ê° í‘œí˜„ */
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .hud-header {
            display: flex;
            align-items: center;
            font-size: 0.7em;
            color: #888;
            margin-bottom: 4px;
            letter-spacing: 2px;
        }

        .hud-icon {
            margin-right: 6px;
            font-size: 1.2em;
            animation: spinSlow 4s linear infinite;
        }

        .hud-main {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 1.1em;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            margin-bottom: 6px;
        }

        #hud-timer {
            font-size: 0.8em;
            color: #ff0;
        }

        /* íƒ€ì´ë¨¸ ê²Œì´ì§€ ë°” */
        .hud-bar-bg {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        #hud-progress {
            width: 0%; /* JSë¡œ ì œì–´ */
            height: 100%;
            background: linear-gradient(90deg, #0ff, #fff);
            box-shadow: 0 0 10px #0ff;
            transition: width 0.1s linear, background 0.3s;
        }

        @keyframes spinSlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }





    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        // [ì¤‘ìš” ìˆ˜ì •] ì•„ë˜ import ì¤„ ëë¶€ë¶„ì— where, getDocsê°€ ë°˜ë“œì‹œ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        import { getFirestore, collection, addDoc, updateDoc,query, orderBy, limit, onSnapshot, serverTimestamp, where, getDocs }
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBTLq7p5i6GZ89kkWyTFXUMN2TLRBfdL8w",
            authDomain: "neon-dodge-global.firebaseapp.com",
            projectId: "neon-dodge-global",
            storageBucket: "neon-dodge-global.firebasestorage.app",
            messagingSenderId: "104500725211",
            appId: "1:104500725211:web:aa5e89d87ec21808ec4fe"
        };

        window.firebaseApp = initializeApp(firebaseConfig);
        window.firebaseDB = getFirestore(window.firebaseApp);

        // 2. window.firebaseModules ëª©ë¡ì—ë„ where, getDocs ì¶”ê°€
        window.firebaseModules = { collection, addDoc, updateDoc, query, orderBy, limit, onSnapshot, serverTimestamp, where, getDocs };
        window.dispatchEvent(new Event('firebase-ready'));
    </script>
</head>

<body>
    <div id="game-container">
        <div id="ui-layer-v2">
            
            <div class="top-left-v2">
                <div id="lives-v2">LIVES: â™¥â™¥â™¥</div>
                
                <div id="hud-panel-v2">
                    <div class="hud-row-v2">
                        <span id="hud-mode">SYSTEM NORMAL</span>
                        <span id="hud-timer"></span>
                    </div>
                    <div class="hud-bar-track">
                        <div id="hud-progress"></div>
                    </div>
                </div>
            </div>

            <div id="current-score">0</div>
            <div id="stage-info">STAGE 1 | TIME: 30</div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="overlay">
            <div id="settings-ui" style="position: absolute; top: 20px; right: 20px; z-index: 1001;">
                <button id="gear-btn" onclick="toggleSettings()" style="background:none; border:none; box-shadow:none; font-size: 1.5em; cursor:pointer; padding:10px;">âš™ï¸</button>
                
                <div id="settings-panel" style="display:none; position: absolute; top: 50px; right: 0; background: rgba(0,20,30,0.95); border: 2px solid #0ff; padding: 15px; border-radius: 8px; width: 180px; box-shadow: 0 0 20px rgba(0,255,255,0.2);">
                    <h4 style="margin:0 0 12px 0; font-size: 14px; color: #0ff; font-family: 'Orbitron';">CONTROL</h4>
                    <div style="display:flex; flex-direction:column; gap:12px; color:white; font-family: 'Orbitron'; font-size: 12px;">
                        <label style="cursor:pointer; display:flex; align-items:center; gap:8px;">
                            <input type="radio" name="ctrl-mode" value="JOYSTICK" onclick="setControlMode('JOYSTICK')"> JOYSTICK
                        </label>
                        <label style="cursor:pointer; display:flex; align-items:center; gap:8px;">
                            <input type="radio" name="ctrl-mode" value="TOUCH" checked onclick="setControlMode('TOUCH')"> SIDE TOUCH
                        </label>
                    </div>
                </div>
            </div>


            <h1>NEON DODGE</h1>
            <span class="season-badge">SEASON 2</span>

            <div id="step-1-ranking" style="display:flex; flex-direction:column; align-items:center;">
                <ul id="leaderboard">
                    <li>Loading...</li>
                </ul>

                <ul id="my-rank-list" style="display:none; margin-bottom: 10px;"></ul>

                <button onclick="goToNameInput()">ì „íˆ¬ ì‹œì‘</button>

            </div>

            <div id="step-2-input" style="display:none; flex-direction:column; align-items:center;">
                <h2 style="color:#0ff; text-shadow:0 0 10px #0ff; margin-bottom:20px;">IDENTIFICATION</h2>

                <input type="text" id="pilot-name-input" maxlength="3" placeholder="CODE NAME"
                    style="background: rgba(0,0,0,0.6); border: 2px solid #0ff; color: #fff; 
                              padding: 15px; font-family: 'Orbitron'; text-align: center; 
                              font-size: 1.5em; text-transform: uppercase; width: 220px; 
                              outline: none; border-radius: 5px; box-shadow: 0 0 20px rgba(0,255,255,0.2); margin-bottom: 20px;">

                <button onclick="startGame()"
                    style="font-size:1.4em; padding:15px 40px; border-color:#f0f; color:#f0f;">
                    ğŸš€ LAUNCH
                </button>

                <button onclick="backToRanking()" style="margin-top:20px; font-size:0.8em; border:none; color:#888;">
                    â†© BACK
                </button>
            </div>

            <ul id="my-rank-list" style="display:none;"></ul>
        </div>

        <div id="rank-input-screen" class="overlay" style="display:none;">
            <div class="result-container">
                <div class="result-title" id="res-title">MISSION FAILED</div>
                <div class="result-stats">
                    <div class="stat-row">
                        <span class="label">STAGE</span>
                        <span class="value" id="res-stage">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">SCORE</span>
                        <span class="value" id="res-score">0</span>
                    </div>
                </div>
            </div>

            <div id="save-status"
                style="margin: 20px 0; color: #ff0; font-size: 1.2em; animation: pulseRed 1s infinite;">
                â³ AUTO-ARCHIVING...
            </div>

            <ul id="result-rank-list" style="display:none;"></ul>

            <div id="action-buttons" style="display:none; gap:15px; margin-top:5px;">
                <button onclick="location.reload()" style="border-color:#0ff; color:#0ff; padding: 10px 20px;">
                    ğŸ”„ RESTART
                </button>
                <button onclick="shareScore()" style="border-color:#f0f; color:#f0f; padding: 10px 20px;">
                    ğŸ“¤ SHARE
                </button>
            </div>
        </div>

        <script>
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 450; canvas.height = 800;

            const levels = [
                { stage: 1, duration: 10, theme: '#0ff', speedMult: 1.0, spawnRate: 0.69, types: ['NORMAL'], isBoss: false },
                { stage: 2, duration: 11, theme: '#0f0', speedMult: 1.1, spawnRate: 0.62, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
                { stage: 3, duration: 12, theme: '#8ef', speedMult: 1.2, spawnRate: 0.54, types: ['NORMAL', 'ZIGZAG'], isBoss: false },
                { stage: 4, duration: 13, theme: '#aaf', speedMult: 1.3, spawnRate: 0.46, types: ['NORMAL', 'ZIGZAG', 'HOMING'], isBoss: false },
                { stage: 5, duration: 14, theme: '#88f', speedMult: 1.4, spawnRate: 0.42, types: ['ZIGZAG', 'HOMING'], isBoss: true, bossHP: 100, bossType: 'LUNAR' },
                { stage: 6, duration: 15, theme: '#f80', speedMult: 1.5, spawnRate: 0.31, types: ['ZIGZAG', 'HOMING'], isBoss: false },
                { stage: 7, duration: 16, theme: '#f64', speedMult: 1.6, spawnRate: 0.27, types: ['ZIGZAG', 'HOMING'], isBoss: false },
                { stage: 8, duration: 17, theme: '#f44', speedMult: 1.7, spawnRate: 0.25, types: ['NORMAL', 'ZIGZAG', 'HOMING', 'SHOOTER'], isBoss: false },
                { stage: 9, duration: 18, theme: '#f22', speedMult: 1.9, spawnRate: 0.25, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER'], isBoss: false },
                { stage: 10, duration: 19, theme: '#f80', speedMult: 2.0, spawnRate: 0.25, types: ['ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER', 'LASER_ENEMY'], isBoss: true, bossHP: 200, bossType: 'SUN' }
            ];

            // â–¼â–¼â–¼ [CDSO ê¸´ê¸‰ íŒ¨ì¹˜] ì´ ì½”ë“œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”! â–¼â–¼â–¼
            if (typeof levels !== 'undefined') {
                levels.push({
                    stage: 11,
                    duration: 99999,      // ì‹œê°„ ë¬´ì œí•œ
                    theme: '#050505',     // ì‹¬ì—°ì˜ ê²€ì€ìƒ‰ ë°°ê²½
                    speedMult: 2.0,       // ì†ë„ ë°°ìœ¨
                    spawnRate: 0.1,       // ìŠ¤í°ìœ¨
                    types: [],            // ì  íƒ€ì… (spawnEntities í•¨ìˆ˜ê°€ ì²˜ë¦¬í•¨)
                    isBoss: false         // ë³´ìŠ¤ ì•„ë‹˜
                });
                console.log("âœ… Stage 11 Dummy Data Injected");
            }


            let gameState = {
                isRunning: false, score: 0,
                player: { x: 215, y: 720, w: 20, h: 20, speed: 750 },
                enemies: [], items: [], bullets: [], keys: {},
                skillMode: 'NORMAL', skillTimer: 0,
                lives: 3, maxLives: 3, isInvincible: false, invincibilityTimer: 0,
                drones: [],
                isTransformed: false,
                isLaserMode: false, laserTimer: 0,
                spawnTimer: 0, itemSpawnTimer: 0,
                currentStage: 1, stageTimer: 30, boss: null,
                stageClearing: false, stageClearTimer: 0, survivalMode: false,
                bossPhase: 'MINION',
                bossTimer: 0,
                bossResurrected: false,
                downgradeFlash: 0,
                progressDisplay: 0,
                survivalStartCount: 0,
                spawnDelay: 0,
                isLunarMode: false,
                lunarAngle: 0,
                touchTarget: null,
                stageTimerEnded: false,
                survivalTimer: 0,
                pendingBoss: null,
                // ìƒˆë¡œìš´ ê¸°ëŠ¥ë“¤
                ultGauge: 0,           // í•„ì‚´ê¸° ê²Œì´ì§€ (0~1)
                autoFireTimer: 0,      // ìë™ ë°œì‚¬ íƒ€ì´ë¨¸
                isHomingMode: false,   // ìœ ë„íƒ„ ëª¨ë“œ
                homingTimer: 0,        // ìœ ë„íƒ„ ì§€ì† ì‹œê°„
                rainbowWave: null,     // ë¬´ì§€ê°œ íŒŒë™ ìƒíƒœ
                dangerWarning: 0,      // DANGER ê²½ê³  íƒ€ì´ë¨¸
                timeBonusDisplay: null // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ
            };

            let lastTime = performance.now();
            // [ì°¾ê¸°] let lastTime = performance.now(); ì•„ë˜ì— ì‚½ì…
            gameState.controlMode = localStorage.getItem('prefControlMode') || 'TOUCH';

            function toggleSettings() {
                const panel = document.getElementById('settings-panel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }

            function setControlMode(mode) {
                gameState.controlMode = mode;
                localStorage.setItem('prefControlMode', mode);
                // ë¼ë””ì˜¤ ë²„íŠ¼ ìƒíƒœ ê°•ì œ ì—…ë°ì´íŠ¸
                const radios = document.querySelectorAll('input[name="ctrl-mode"]');
                radios.forEach(r => r.checked = (r.value === mode));
            }

            window.addEventListener('load', () => {
                const savedMode = localStorage.getItem('prefControlMode') || 'TOUCH';
                setControlMode(savedMode);
            });

            let gridOffset = 0;


            // [CDSO ì „ëµ] ì»¨íŠ¸ë¡¤ ëª¨ë“œ ìƒíƒœ ê´€ë¦¬ ('TRACKING' vs 'BUTTONS')
            // localStorageë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ ì €ì˜ ì„ íƒì„ ê¸°ì–µí•©ë‹ˆë‹¤.
            let controlMode = 'BUTTONS';


            let firebaseReady = false;
            let lastSavedName = '';  // ì‹ ê·œ ë“±ë¡ ìœ ì € í•˜ì´ë¼ì´íŠ¸ìš©

            window.isVeteranServer = false  // ê¸°ë³¸ê°’: ì•„ì§ ê³ ì¸ë¬¼ ì„œë²„ ì•„ë‹˜


            // [CDSO ì „ëµ ìˆ˜ì •] ë¹„ìš© ìµœì í™”: ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆ(onSnapshot) ì œê±° -> ë‹¨ë°œì„± ì¡°íšŒ(getDocs)ë¡œ ë³€ê²½
            async function initFirebaseRanking() {
                // DB ì—°ê²° ê°ì²´ì™€ í•¨ìˆ˜ ëª¨ë“ˆì´ ëª¨ë‘ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°
                if (!window.firebaseDB || !window.firebaseModules) {
                    console.log("Waiting for Firebase Modules...");
                    setTimeout(initFirebaseRanking, 100);
                    return;
                }

                firebaseReady = true;

                const { collection, query, orderBy, limit, getDocs } = window.firebaseModules;
                const list = document.getElementById('leaderboard');

                try {
                    // 1. ì¿¼ë¦¬ ìƒì„± (ê¸°ì¡´ê³¼ ë™ì¼)
                    const q = query(
                        // [ìˆ˜ì • ì „] collection(window.firebaseDB, 'rankings'),
                        // [ìˆ˜ì • í›„] ì‹œì¦Œ2ìš© ìƒˆ ì»¬ë ‰ì…˜ ì´ë¦„ìœ¼ë¡œ ë³€ê²½
                        collection(window.firebaseDB, 'rankings_v2'),
                        orderBy('score', 'desc'),
                        limit(10)
                    );

                    // 2. [ë³€ê²½] getDocsë¥¼ ì‚¬ìš©í•˜ì—¬ 1íšŒë§Œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë¹„ìš© ì ˆê° í•µì‹¬)
                    const snapshot = await getDocs(q);

                    // ì¡°ê±´: ë­í‚¹ì— 10ëª… ì´ìƒ ìˆê³  && 10ë“±(ì¸ë±ìŠ¤ 9)ì˜ ì ìˆ˜ê°€ 5000ì  ì´ìƒì¸ê°€?
                    if (snapshot.docs.length >= 10) {
                        const tenthRankScore = snapshot.docs[9].data().score;
                        if (tenthRankScore >= 5000) {
                            window.isVeteranServer = true;
                            console.log("âš”ï¸ Server Status: VETERAN (Cutline established)");
                        } else {
                            window.isVeteranServer = false;
                        }
                    } else {
                        window.isVeteranServer = false; // ì‚¬ëŒì´ 10ëª…ë„ ì•ˆ ë˜ë©´ ì•„ì§ ë£¨í‚¤ ëª¨ë“œ ì—†ìŒ
                    }


                    list.innerHTML = '<h3>ğŸŒ GLOBAL TOP 5</h3>';

                    // [CDSO í•µì‹¬ ì¶”ê°€] 3ë“± ì ìˆ˜ ì¶”ì¶œ (ì—†ìœ¼ë©´ 0ì )
                    // ë°°ì—´ ì¸ë±ìŠ¤ 2ê°€ 3ë“±ì…ë‹ˆë‹¤ (0=1ë“±, 1=2ë“±, 2=3ë“±)
                    if (snapshot.docs.length >= 3) {
                        // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ 3ë“±ì˜ ì ìˆ˜ë¥¼ ê°€ì ¸ì™€ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
                        gameState.rank3Score = snapshot.docs[2].data().score;
                        console.log("ğŸ¯ Target Score (Top 3 Cutline):", gameState.rank3Score);
                    } else {
                        // ë­í‚¹ì— ì‚¬ëŒì´ 3ëª…ë„ ì—†ìœ¼ë©´? ë¬´ì¡°ê±´ 1ë“± ì§„ì… ê°€ëŠ¥í•˜ë¯€ë¡œ ì»¤íŠ¸ë¼ì¸ 0
                        gameState.rank3Score = 0;
                    }



                    if (snapshot.empty) {
                        list.innerHTML += '<li class="rank-1">No Records Yet</li>';
                    } else {
                        snapshot.docs.forEach((doc, i) => {
                            const r = doc.data();
                            const rank = i + 1;
                            const isNewUser = lastSavedName && r.name === lastSavedName;
                            const rankClass = `rank-${rank}${isNewUser ? ' new-user' : ''}`;
                            const rankEmoji = rank === 1 ? 'ğŸ¥‡' : (rank === 2 ? 'ğŸ¥ˆ' : (rank === 3 ? 'ğŸ¥‰' : rank));

                            // [CDSO í•µì‹¬ ìˆ˜ì •] 6ë“±ë¶€í„°(index 5 ì´ìƒ)ëŠ” í™”ë©´ì—ì„œ ìˆ¨ê¹ë‹ˆë‹¤.
                            // í•˜ì§€ë§Œ HTMLì—ëŠ” ì¡´ì¬í•˜ë¯€ë¡œ shareScore í•¨ìˆ˜ê°€ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                            const hideStyle = i >= 5 ? 'style="display:none;"' : '';


                            list.innerHTML += `
                            <li class="${rankClass}" ${hideStyle}>
                                <span class="rank-badge">${rankEmoji}</span>
                                <span class="player-name">${r.name}</span>
                                <span class="player-score">${r.score.toLocaleString()}</span>
                                <span class="player-stage">ST.${r.stage}</span>
                            </li>`;
                        });
                    }
                } catch (e) {
                    console.error("Ranking Load Error:", e);
                    // ì—ëŸ¬ê°€ ë‚˜ë„ ë¡œë”© í…ìŠ¤íŠ¸ë¥¼ ì—†ì• ê³  ê¸°ë³¸ ìƒíƒœë¡œ ì „í™˜
                    list.innerHTML = '<h3>ğŸŒ GLOBAL TOP 5</h3><li class="rank-1">Network/Data Error</li>';
                    // ì—ëŸ¬ ì‹œ ì•ˆì „í•˜ê²Œ ì»¤íŠ¸ë¼ì¸ì„ 0ìœ¼ë¡œ ì„¤ì •
                    gameState.rank3Score = 0;

                }

                // ë‚´ ìµœê³  ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
                const savedData = localStorage.getItem('myBestRecord');
                if (savedData) {
                    try {
                        const r = JSON.parse(savedData);
                        if (r.score > 0) updateMyRank(r.name, r.score, r.stage);
                    } catch (e) { console.error('Data parsing error', e); }
                }
            }


            // [CDSO Finalized] í†µí•© ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ê¸° (All-in-One)
            function getSystemInfo() {
                const ua = navigator.userAgent;
                let os = 'UNKNOWN';
                let osVer = '';
                let browser = 'UNKNOWN';
                let model = 'PC/Generic';
                let engine = 'Unknown Engine';

                // 1. OS & Version ì •ë°€ ë¶„ì„
                if (/Windows/i.test(ua)) {
                    os = 'Windows';
                    const match = ua.match(/Windows NT ([\d.]+)/);
                    if (match) osVer = match[1];
                } else if (/Android/i.test(ua)) {
                    os = 'Android';
                    const match = ua.match(/Android\s([0-9.]+)/);
                    if (match) osVer = match[1];

                    // ì•ˆë“œë¡œì´ë“œ ëª¨ë¸ëª… ì¶”ì¶œ
                    const modelMatch = ua.match(/;\s([^;]+)\sBuild/);
                    if (modelMatch) model = modelMatch[1].trim();
                } else if (/iPhone|iPad|iPod/i.test(ua)) {
                    os = 'iOS';
                    const match = ua.match(/OS\s([\d_]+)/);
                    if (match) osVer = match[1].replace(/_/g, '.');
                    model = 'iPhone/iPad';
                } else if (/Mac/i.test(ua)) {
                    os = 'Mac';
                }

                // 2. Browser ì •ë°€ ë¶„ì„
                if (/KAKAOTALK/i.test(ua)) browser = 'KakaoTalk InApp';
                else if (/NAVER/i.test(ua)) browser = 'Naver InApp';
                else if (/Instagram/i.test(ua)) browser = 'Instagram InApp';
                else if (/Chrome/i.test(ua)) browser = 'Chrome';
                else if (/Safari/i.test(ua)) browser = 'Safari';
                else if (/Firefox/i.test(ua)) browser = 'Firefox';

                // 3. ì—”ì§„ ë²„ì „ ì¶”ì¶œ
                const engineMatch = ua.match(/(AppleWebKit\/[\d.]+)/);
                if (engineMatch) {
                    engine = engineMatch[1];
                } else if (/Gecko\//.test(ua)) {
                    engine = 'Gecko (Mozilla)';
                }

                // 4. í™”ë©´ ë° í”Œë«í¼ ì •ë³´ (êµ¬ë²„ì „ ê¸°ëŠ¥ í†µí•©)
                const isMobile = /Mobi|Android/i.test(ua) || window.innerWidth <= 500;
                const resolution = `${window.innerWidth}x${window.innerHeight}`;
                const controlType = localStorage.getItem('controlMode') || 'BUTTONS';

                // 5. í†µí•© ê°ì²´ ë°˜í™˜
                return {
                    // [Parsed Data]
                    os,
                    osVer,
                    browser,
                    model,
                    engine,

                    // [Environment Data]
                    platform: isMobile ? 'MOBILE' : 'PC',
                    resolution: resolution,
                    control: controlType,

                    // [Raw Data]
                    raw_ua: ua
                };
            }



            async function saveToFirebase(name, score, stage) {
                if (!firebaseReady) return;

                // ë¡œì»¬ ì €ì¥
                const myRecord = { name, score, stage };
                localStorage.setItem('myBestRecord', JSON.stringify(myRecord));

                // [CDSO] í†µí•©ëœ ì‹œìŠ¤í…œ ì •ë³´ í˜¸ì¶œ (ë³€ìˆ˜ëª… 'sys'ë¡œ í†µì¼)
                const sys = getSystemInfo();

                // í”Œë ˆì´ ì‹œê°„ ê³„ì‚°
                const playTimeSec = Math.floor((Date.now() - gameState.startTime) / 1000);

                // ì•„ì´í…œ íšë“ë¥  ê³„ì‚°
                const collectionRate = gameState.totalItemsSpawned > 0
                    ? Math.round((gameState.itemsCollected / gameState.totalItemsSpawned) * 100)
                    : 0;

                // íƒìš• ì‚¬ë§ íŒì •
                let isGreedyDeath = false;
                const px = gameState.player.x, py = gameState.player.y;
                for (let item of gameState.items) {
                    const dist = Math.sqrt(Math.pow(item.x - px, 2) + Math.pow(item.y - py, 2));
                    if (dist < 100) { isGreedyDeath = true; break; }
                }

                const { collection, addDoc, updateDoc, query, where, getDocs, serverTimestamp } = window.firebaseModules;

                try {
                    // ============================================================
                    // [PART 1] ë­í‚¹ ë°ì´í„° ì²˜ë¦¬ (ìµœê³  ê¸°ë¡ ê°±ì‹  ë¡œì§)
                    // ============================================================
                    
                    // 1. ë¨¼ì € ê°™ì€ ë‹‰ë„¤ì„ì´ ìˆëŠ”ì§€ ì°¾ì•„ë´…ë‹ˆë‹¤.
                    const rankRef = collection(window.firebaseDB, 'rankings_v2');
                    const q = query(rankRef, where('name', '==', name));
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        // 2. ì´ë¯¸ ë“±ë¡ëœ ìœ ì €ê°€ ìˆë‹¤ë©´?
                        const existingDoc = snapshot.docs[0]; // ì²« ë²ˆì§¸ ê²€ìƒ‰ ê²°ê³¼
                        const oldData = existingDoc.data();

                        // 3. ì‹ ê¸°ë¡ì¸ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸! (ê°™ê±°ë‚˜ ë‚®ìœ¼ë©´ ë¬´ì‹œ)
                        if (score > oldData.score) {
                            await updateDoc(existingDoc.ref, {
                                score: score,
                                stage: stage,
                                platform: sys.platform,
                                timestamp: serverTimestamp() // ê°±ì‹  ì‹œì  ì—…ë°ì´íŠ¸
                            });
                            console.log("âœ… Existing record updated with new high score!");
                        } else {
                            console.log("â¹ Score is not higher. Ranking preserved.");
                        }
                    } else {
                        // 4. ë“±ë¡ëœ ì  ì—†ëŠ” ì‹ ê·œ ìœ ì €ë¼ë©´? -> ìƒˆë¡œ ì¶”ê°€ (ê¸°ì¡´ ë°©ì‹)
                        await addDoc(rankRef, {
                            name: name,
                            score: score,
                            stage: stage,
                            platform: sys.platform,
                            timestamp: serverTimestamp()
                        });
                        console.log("âœ¨ New challenger registered!");
                    }

                    // ============================================================
                    // [PART 2] ê²Œì„ ë¡œê·¸ ì €ì¥ (ë¬´ì¡°ê±´ ì €ì¥ - ë¶„ì„ìš©)
                    // ============================================================
                    // ë¡œê·¸ëŠ” ê°±ì‹  ê°œë…ì´ ì•„ë‹ˆë¼ 'ì—­ì‚¬'ì´ë¯€ë¡œ ëª¨ë“  íŒì„ ë‹¤ ê¸°ë¡í•©ë‹ˆë‹¤.
                    await addDoc(collection(window.firebaseDB, 'game_logs_v2'), {
                        name: name,
                        score: score,
                        stage: stage,
                        timestamp: serverTimestamp(),
                        
                        system: {
                            os: sys.os,
                            osVer: sys.osVer,
                            browser: sys.browser,
                            model: sys.model,
                            engine: sys.engine,
                            platform: sys.platform,
                            screen: sys.resolution,
                            control: sys.control,
                            ua_full: sys.raw_ua
                        },

                        gameplay: {
                            playTimeSec: playTimeSec,
                            deathReason: gameState.lastHitBy,
                            itemCollectionRate: collectionRate,
                            isGreedyDeath: isGreedyDeath,
                            finalLives: gameState.lives
                        }
                    });

                    lastSavedName = name;
                    
                    // ë“±ìˆ˜ ê³„ì‚° ë° ë°˜í™˜
                    const rank = await updateMyRank(name, score, stage);
                    return rank;

                } catch (e) { 
                    console.error("Save Failed:", e); 
                    return null; 
                }
            }



            async function updateMyRank(name, score, stage) {
                // ì¸ìê°€ ë¶€ì¡±í•˜ë©´ ì‹¤í–‰ ì¤‘ë‹¨
                if (!firebaseReady || !score) return;

                const { collection, query, where, getDocs } = window.firebaseModules;
                try {
                    // ë‚´ ì ìˆ˜ë³´ë‹¤ ë†’ì€ ì‚¬ëŒ ìˆ˜ ê³„ì‚° (ë“±ìˆ˜ ì‚°ì •)
                    const higherQuery = query(
                        // [ìˆ˜ì • ì „] collection(window.firebaseDB, 'rankings'),
                        // [ìˆ˜ì • í›„]
                        collection(window.firebaseDB, 'rankings_v2'),
                        where('score', '>', score)
                    );
                    const higherSnapshot = await getDocs(higherQuery);
                    const myRank = higherSnapshot.size + 1;

                    // [ìˆ˜ì •] ê¸°ì¡´ í…ìŠ¤íŠ¸ div ëŒ€ì‹ , ë¦¬ìŠ¤íŠ¸(ul) ì•ˆì— ìƒˆë¡œìš´ li ë°•ìŠ¤ë¥¼ ìƒì„±í•´ ë„£ìŒ
                    const rankList = document.getElementById('my-rank-list');

                    // HTML êµ¬ì¡° ìƒì„± (CSSì˜ .rank-me ìŠ¤íƒ€ì¼ì´ ì ìš©ë¨)
                    rankList.innerHTML = `
                    <li class="rank-me">
                        <span class="rank-badge">${myRank}</span>
                        <span class="player-name">${name}</span>
                        <span class="player-score">${score.toLocaleString()}</span>
                        <span class="player-stage">ST.${stage}</span>
                    </li>
                `;
                    rankList.style.display = 'block';

                    // [í•µì‹¬] ê°’ì„ ë¦¬í„´í•©ë‹ˆë‹¤
                    return myRank;


                } catch (e) {
                    console.error('Failed to calculate rank:', e);
                    return null; // ì—ëŸ¬ ì‹œ null ë°˜í™˜
                }
            }

            // ì‹¤ì œ ì  ê¸°ì²´ë§Œ ì¹´ìš´íŠ¸ (íƒ„í™˜ + í­ë°œ/ë°œì‚¬ ì™„ë£Œ ì  ì œì™¸)
            function getActiveEnemyCount() {
                return gameState.enemies.filter(en =>
                    en.type !== 'BULLET' &&
                    en.type !== 'ENEMY_BULLET' &&
                    en.type !== 'SHOCKWAVE' &&
                    en.type !== 'METEOR' &&
                    !(en.type === 'BOMBER' && en.exploded) &&
                    !(en.type === 'LASER_ENEMY' && en.fired)
                ).length;
            }

            // ì  íƒ€ì…ë³„ ì°¨ë“± ì ìˆ˜ (ì†Œìˆ˜ì  ë‹¨ìœ„)
            function getEnemyScore(type) {
                const scoreTable = {
                    'NORMAL': 1.0,
                    'ZIGZAG': 1.2,
                    'HOMING': 1.5,
                    'SHOOTER': 1.8,
                    'BOMBER': 2.0,
                    'LASER_ENEMY': 2.2,
                    'MINION': 0.5,
                    // [Patch A] ë¬´ì˜ë¯¸í•œ ê°ì²´ ì ìˆ˜ 0 ì²˜ë¦¬ (Data Sanitization)
                    'BULLET': 0,
                    'ENEMY_BULLET': 0,
                    'OBSTACLE': 0 // ì¶”í›„ ì¥ì• ë¬¼ ì¶”ê°€ ëŒ€ë¹„
                };
                return (scoreTable[type] !== undefined) ? scoreTable[type] : 1.0;
            }

            // Phase 6: Safety Margin ì¶©ëŒ íŒì • (2px ì—¬ìœ )
            function checkCollisionWithMargin(a, b, margin = 2) {
                return !(
                    a.x + a.w + margin < b.x ||
                    a.x - margin > b.x + b.w ||
                    a.y + a.h + margin < b.y ||
                    a.y - margin > b.y + b.h
                );
            }

            function takeDamage() {

                // [CDSO Hardening] ê²Œì„ì´ ì¢…ë£Œëœ ìƒíƒœì—ì„œ í”¼ê²© ì´ë²¤íŠ¸ ë¬´ì‹œ
                if (!gameState.isRunning) return;

                // [CDSO ì¶”ê°€] ì´ë¯¸ ì‚¬ë§ ì²˜ë¦¬ ì¤‘ì´ë¼ë©´ ì¶”ê°€ í”¼ê²© ë¬´ì‹œ
                if (gameState.lives <= 0)
                    return;

                // â–¼â–¼â–¼ [CDSO Patch 4-5: ë¯¸ëŸ¬ ì½”íŠ¸ ì ˆëŒ€ ë°˜ì‚¬] â–¼â–¼â–¼
                if (gameState.isMirrorActive) {
                    triggerHaptic(50); // íŒ…ê²¨ë‚´ëŠ” ì†ë§›
                    addScore(100);     // ë°˜ì‚¬ ì ìˆ˜
                    gameState.downgradeFlash = 0.1; // ë²ˆì©
                    return; // â˜… ë°ë¯¸ì§€ ë¬´ì‹œí•˜ê³  ì¢…ë£Œ
                }


                // [CDSO ì¶”ê°€] 1000ì  ë¯¸ë§Œ ì ˆëŒ€ ë¬´ì  (Tutorial Guard)
                // ë£¨í‚¤ ëª¨ë“œì´ê³  + ì ìˆ˜ê°€ 1000ì  ë¯¸ë§Œì´ë¼ë©´?
                if (gameState.isRookieMode && gameState.score < 1000) {
                    // 1. ë°ë¯¸ì§€ ë¬´ì‹œ (ë¦¬í„´)
                    // 2. ëŒ€ì‹  "ë§ì•˜ë‹¤"ëŠ” ì‹œê°ì  í”¼ë“œë°±ë§Œ ì¤Œ (ê¹œë¹¡ê±°ë¦¼)
                    gameState.downgradeFlash = 0.3;

                    // (ì„ íƒì‚¬í•­) ì§„ë™ì€ ì¤˜ì„œ 'ìœ„í—˜í•˜ë‹¤'ëŠ” ì‹ í˜¸ëŠ” ë³´ëƒ„
                    triggerHaptic(100);

                    return; // â˜… í•¨ìˆ˜ ê°•ì œ ì¢…ë£Œ (ìƒëª…ë ¥ ê°ì†Œ ì½”ë“œ ì‹¤í–‰ ì•ˆ ë¨)
                }


                // [CDSO ìˆ˜ì •] ë¬´ì ì´ë‚˜ ì‰´ë“œ ìƒíƒœë©´ ì§„ë™ ì•ˆ í•¨
                if (gameState.isInvincible || gameState.skillMode === 'SHIELD') return;

                // [CDSO í•µì‹¬ ì¶”ê°€] í”¼ê²© ì‹œ 300ms(0.3ì´ˆ) ë™ì•ˆ ê°•í•œ ì§„ë™ ë°œìƒ!
                triggerHaptic(300);


                if (gameState.isInvincible || gameState.skillMode === 'SHIELD') return;

                if (gameState.isTransformed) {
                    gameState.isTransformed = false;
                    gameState.isLaserMode = false;
                    gameState.laserTimer = 0;

                    // â–¼â–¼â–¼ [CDSO Patch: ì¶”ê°€ ë¬´ì¥ ì´ˆê¸°í™” (Step 4)] â–¼â–¼â–¼
                    gameState.isSideMissileActive = false; // ë¯¸ì‚¬ì¼ ì••ìˆ˜
                    gameState.droneOverload = 0;           // ì¹´ìš´í„° ì´ˆê¸°í™”


                    gameState.isLunarMode = false;  // í™©ê¸ˆ ë³€ì‹  í•´ì œ ì‹œ ë£¨ë‚˜ëª¨ë“œë„ í•¨ê»˜ í•´ì œ
                    gameState.drones = [{ offsetX: -35, shootTimer: 0 }];
                    gameState.isInvincible = true;
                    gameState.invincibilityTimer = 1.5;
                    gameState.downgradeFlash = 0.5;

                    // [ì¶”ê°€] ë³€ì‹  í•´ì œ ì‹œ ì¶©ê²©íŒŒ(Shockwave) ë°œìƒìœ¼ë¡œ ì£¼ë³€ ì  ì •ë¦¬
                    activateDroneKamikaze(0, true);

                    return;
                }

                if (gameState.drones.length > 0) {
                    // 1. ì œê±°ë  ë“œë¡  ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                    const lostDrone = gameState.drones.pop();

                    // 2. í•´ë‹¹ ìœ„ì¹˜ì—ì„œ 'ìí­ ë¯¸ì‚¬ì¼' ë°œì‚¬!
                    activateDroneKamikaze(lostDrone.offsetX, false);

                    // 3. í”¼ë“œë°± (ë¬´ì  ì‹œê°„ ë° ì§„ë™)
                    gameState.isInvincible = true;
                    gameState.invincibilityTimer = 1.0; // ë¬´ì  ì‹œê°„ ë¶€ì—¬
                    triggerHaptic(200); // ê°•í•œ ì§„ë™
                    return;
                }

                // [CDSO ìˆ˜ì •] ë³¸ì²´ í”¼ê²© ì‹œ ì²˜ë¦¬
                gameState.lives--;
                gameState.isLunarMode = false; // â˜… í•µì‹¬: ë³¸ì²´ê°€ ë§ìœ¼ë©´ ë£¨ë‚˜ ê°€ë””ì–¸ íŒŒê´´ë¨

                updateLivesUI();
                if (gameState.lives <= 0) gameOver();
                else { gameState.isInvincible = true; gameState.invincibilityTimer = 2.0; }
            }


            // [CDSO System] ë“œë¡  ììœ¨ íƒ€ê²© í”„ë¡œí† ì½œ
            function activateDroneKamikaze(offsetX, isShockwave) {
                const cx = gameState.player.x + gameState.player.w / 2;
                const cy = gameState.player.y;

                // ì¶©ê²©íŒŒ ëª¨ë“œ (ë³€ì‹  í•´ì œ ì‹œ)
                if (isShockwave) {
                    gameState.bullets.push({
                        x: cx - 150, y: cy - 100, w: 300, h: 100, // í™”ë©´ ì „ì²´ ë„ˆë¹„ê¸‰
                        speed: 800,
                        type: 'DRONE_MISSILE', // íŠ¹ìˆ˜ íƒ€ì…
                        isPenetrating: true,   // ê´€í†µ ì†ì„±
                        life: 0.5,             // 0.5ì´ˆê°„ ì§€ì†
                        color: '#ffd700'
                    });
                    return;
                }

                // ì¼ë°˜ ë“œë¡  ìí­ ëª¨ë“œ (ì§ì„  ê´€í†µíƒ„)
                gameState.bullets.push({
                    x: cx + offsetX - 15, // ë“œë¡  ìœ„ì¹˜
                    y: cy,
                    w: 30, h: 60,         // ê±°ëŒ€í•œ íŒì • ë°•ìŠ¤
                    speed: 700,          // ì¤‘ê°„ì†ë„
                    type: 'DRONE_MISSILE',
                    isPenetrating: true,  // â˜… í•µì‹¬: ì ì„ ëš«ê³  ì§€ë‚˜ê°
                    color: '#0ff',
                    vx: 0, vy: -1
                });

                addScore(100); // ì•¡ì…˜ ë³´ë„ˆìŠ¤ ì ìˆ˜
            }



            // [CDSO ìˆ˜ì •] ê¸°ì¡´ updateLivesUI í•¨ìˆ˜ë¥¼ ì•„ë˜ ì½”ë“œë¡œ ì™„ì „íˆ ë®ì–´ì“°ê¸° í•˜ì‹­ì‹œì˜¤.
            function updateLivesUI() {
                // ID ë³€ê²½ ë°˜ì˜ (lives -> lives-v2)
                const livesEl = document.getElementById('lives-v2');
                if (livesEl) {
                    livesEl.innerHTML = `LIVES: ${'â™¥'.repeat(Math.max(0, gameState.lives))}`;
                    if (gameState.lives <= 1) livesEl.style.color = '#f00';
                    else livesEl.style.color = '#fff';
                }
            }

            function updateDrones(dt) {
                if (gameState.isTransformed) return;
                gameState.drones.forEach(drone => {
                    drone.shootTimer += dt;
                    if (drone.shootTimer > 0.5) {
                        gameState.bullets.push({ x: gameState.player.x + 10 + drone.offsetX - 4, y: gameState.player.y, w: 8, h: 15, speed: 650 });
                        drone.shootTimer = 0;
                    }
                });
            }

            window.addEventListener('keydown', e => {
                gameState.keys[e.key] = true;
                // Space í‚¤ë¡œ í•„ì‚´ê¸° ë°œë™
                if (e.code === 'Space' && gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                    activateRainbowWave();
                }
            });

            window.addEventListener('keyup', e => gameState.keys[e.key] = false);

            // ëª¨ë°”ì¼ í„°ì¹˜ ì¢Œí‘œ ë³€í™˜
            // [CDSO ìˆ˜ì • Step 2] ê¸°ê¸° ê¸°ë°˜ ì—„ê²©í•œ ë°°ìœ¨ ê³ ì • ì‹œìŠ¤í…œ
            let gameScale = 1;

            // ëª¨ë°”ì¼ ê¸°ê¸° ê°ì§€ (ì •ê·œì‹ í™œìš©)
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            function resizeGame() {
                const container = document.getElementById('game-container');
                const winW = window.innerWidth;
                const winH = window.innerHeight;
                const baseW = 450;
                const baseH = 800;

                // 1. ê¸°ê¸° íƒ€ì… íŒë³„
                const isMobile = isMobileDevice();

                if (!isMobile) {
                    // [PC ì „ëµ] ì°½ í¬ê¸°ì™€ ìƒê´€ì—†ì´ ì›ë³¸ í¬ê¸°(1.0) ì ˆëŒ€ ì‚¬ìˆ˜
                    // ì°½ì„ ì¤„ì´ë©´ ê²Œì„ í™”ë©´ì´ ì˜ë¦¬(Clipping)ë”ë¼ë„ í¬ê¸°ëŠ” ìœ ì§€ë¨
                    gameScale = 1.0;
                } else {
                    // [ëª¨ë°”ì¼ ì „ëµ] í™”ë©´ì— ê½‰ ì°¨ê²Œ ì¤„ì´ë˜, ìµœì†Œ ì•ˆì „ ë°°ìœ¨(0.5) ì„¤ì •
                    const ratio = Math.min(winW / baseW, winH / baseH);
                    gameScale = Math.max(ratio, 0.5); // 0.5ë°° ë¯¸ë§Œìœ¼ë¡œ ì‘ì•„ì§€ì§€ ì•ŠìŒ (ê°€ë…ì„± ë³´í˜¸)
                }

                // 2. ì»¨í…Œì´ë„ˆ ì¤‘ì•™ ì •ë ¬ ë° ìŠ¤ì¼€ì¼ ì ìš©
                container.style.position = 'absolute';
                container.style.left = '50%';
                container.style.top = '50%';
                container.style.transform = `translate(-50%, -50%) scale(${gameScale})`;
            }

            window.addEventListener('resize', resizeGame);

            // (getTouchPos í•¨ìˆ˜ëŠ” ìˆ˜ì •í•  í•„ìš” ì—†ì´ ê·¸ëŒ€ë¡œ ë‘ì‹œë©´ ë©ë‹ˆë‹¤.)

            // ìˆ˜ì •ëœ í„°ì¹˜ ì¢Œí‘œ ë³€í™˜ (ìŠ¤ì¼€ì¼ë§ ë°˜ì˜)
            function getTouchPos(e) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];

                // ì—­ë³´ì • ê³µì‹
                return {
                    x: (touch.clientX - rect.left) * (450 / rect.width),
                    y: (touch.clientY - rect.top) * (800 / rect.height)
                };
            }


            // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ (ì œìŠ¤ì²˜ ì°¨ë‹¨ + ë¶€ë“œëŸ¬ìš´ ì¶”ì )
            // [CDSO ì „ëµ] í”Œë¡œíŒ… ì¡°ì´ìŠ¤í‹± ì‹œìŠ¤í…œ (Floating Joystick)
            // í™”ë©´ ì–´ë””ë“  í„°ì¹˜í•˜ë©´ ê·¸ê³³ì´ ì¡°ì´ìŠ¤í‹±ì˜ ì¤‘ì‹¬ì´ ë©ë‹ˆë‹¤.

            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                // ìº”ë²„ìŠ¤ ë‚´ë¶€ ì¢Œí‘œë¡œ ë³€í™˜ (ìŠ¤ì¼€ì¼ë§ ê³ ë ¤)
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const tx = (touch.clientX - rect.left) * scaleX;
                const ty = (touch.clientY - rect.top) * scaleY;

                // [í•„ì‚´ê¸° ì²´í¬] í™”ë©´ í•˜ë‹¨ 15% í„°ì¹˜ ì‹œ í•„ì‚´ê¸° (ì¡°ì´ìŠ¤í‹± ì•„ë‹˜)
                if (ty > canvas.height * 0.85) {
                    if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                        activateRainbowWave();
                    }
                    return;
                }

                // [ì¡°ì´ìŠ¤í‹± í™œì„±í™”]
                gameState.joystick.active = true;
                gameState.joystick.baseX = tx;
                gameState.joystick.baseY = ty;
                gameState.joystick.stickX = tx;
                gameState.joystick.stickY = ty;
                gameState.joystick.vecX = 0;
                gameState.joystick.vecY = 0;
            }, { passive: false });

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (!gameState.joystick.active) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const tx = (touch.clientX - rect.left) * scaleX;
                const ty = (touch.clientY - rect.top) * scaleY;

                // ì¡°ì´ìŠ¤í‹± í—¤ë“œ ì´ë™ ë° ê±°ë¦¬ ì œí•œ (ìµœëŒ€ 50px)
                const maxDist = 30;
                const dx = tx - gameState.joystick.baseX;
                const dy = ty - gameState.joystick.baseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // ì •ê·œí™”ëœ ë²¡í„° ê³„ì‚° (ì´ë™ ë°©í–¥)
                if (dist > 0) {
                    gameState.joystick.vecX = dx / dist;
                    gameState.joystick.vecY = dy / dist;
                }

                // ìŠ¤í‹± ì‹œê°ì  ìœ„ì¹˜ ì œí•œ
                if (dist > maxDist) {
                    gameState.joystick.stickX = gameState.joystick.baseX + (dx / dist) * maxDist;
                    gameState.joystick.stickY = gameState.joystick.baseY + (dy / dist) * maxDist;
                } else {
                    gameState.joystick.stickX = tx;
                    gameState.joystick.stickY = ty;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', e => {
                e.preventDefault();
                // ì†ì„ ë–¼ë©´ ì¡°ì´ìŠ¤í‹± ë¹„í™œì„±í™” ë° ì •ì§€
                gameState.joystick.active = false;
                gameState.joystick.vecX = 0;
                gameState.joystick.vecY = 0;
            }, { passive: false });



            // [CDSO ì¶”ê°€] í–…í‹± í”¼ë“œë°± ì‹œìŠ¤í…œ (ì§„ë™ íš¨ê³¼)
            function triggerHaptic(duration) {
                // 1. ì§„ë™ API ì§€ì› ì—¬ë¶€ í™•ì¸
                // 2. ëª¨ë°”ì¼ ê¸°ê¸°ì¸ì§€ í™•ì¸
                // 3. ì§„ë™ì´ ì¼œì ¸ ìˆëŠ”ì§€ í™•ì¸ (ë³´í†µ ë¸Œë¼ìš°ì € ì„¤ì • ë”°ë¦„)
                if (navigator.vibrate && isMobileDevice()) {
                    try {
                        navigator.vibrate(duration);
                    } catch (e) {
                        console.log("Vibration blocked by system");
                    }
                }
            }


            // ìë™ ì¼ì‹œì •ì§€ (ì „í™”/í™ˆ í™”ë©´ ì „í™˜ ì‹œ)
            document.addEventListener('visibilitychange', function () {
                if (document.hidden && gameState.isRunning) {
                    gameState.isRunning = false;
                    document.getElementById('start-screen').style.display = 'flex';
                    document.querySelector('#start-screen h1').textContent = 'PAUSED';
                    document.querySelector('#start-screen button').textContent = 'RESUME';
                }
            });

            // [CDSO Strategy] 2-Step Launch Protocol
            function goToNameInput() {
                // [CDSO FIX] ì €ì¥ëœ ë‹‰ë„¤ì„ì´ ìˆìœ¼ë©´ ì…ë ¥ ë‹¨ê³„ ê±´ë„ˆë›°ê¸°
                const savedName = localStorage.getItem('lastPilotName');
                const inputEl = document.getElementById('pilot-name-input');
                
                // 1. ì €ì¥ëœ ì´ë¦„ì´ ìˆê³ , ì…ë ¥ì°½ì—ë„ ê·¸ ê°’ì´ ì˜ ë“¤ì–´ê°€ ìˆë‹¤ë©´?
                if (savedName && inputEl && inputEl.value === savedName) {
                    startGame(); // ì…ë ¥ í™”ë©´ ì—†ì´ ë°”ë¡œ ê²Œì„ ì‹œì‘!
                    return;
                }

                // 2. ì €ì¥ëœ ê²Œ ì—†ìœ¼ë©´ ì›ë˜ëŒ€ë¡œ ì…ë ¥ í™”ë©´ ë³´ì—¬ì¤Œ
                document.getElementById('step-1-ranking').style.display = 'none';
                document.getElementById('step-2-input').style.display = 'flex';

                // í¬ì»¤ìŠ¤
                if (inputEl) inputEl.focus();
            }

            function backToRanking() {
                document.getElementById('step-2-input').style.display = 'none';
                document.getElementById('step-1-ranking').style.display = 'flex';
            }

            function startGame() {
                // [CDSO FIX] ê²Œì„ ì‹œì‘ ì‹œ UI íŒ¨ë„ ë³´ì´ê¸°
                const uiLayer = document.getElementById('ui-layer-v2');
                if (uiLayer) uiLayer.style.display = 'flex';


                const nameInput = document.getElementById('pilot-name-input');
                if (!nameInput) return;

                // 1. ì›ë³¸ ì…ë ¥ê°’ ê°€ì ¸ì˜¤ê¸° (ëŒ€ë¬¸ì ë³€í™˜)
                let rawInput = nameInput.value.trim().toUpperCase();

                // â–¼â–¼â–¼ [CDSO ë°±ë„ì–´: ìŠ¤í…Œì´ì§€ ì›Œí”„ ë¡œì§] â–¼â–¼â–¼
                // íŒ¨í„´ ê°ì§€: "ìˆ«ì" + "ADMIN" (ì˜ˆ: 3ADMIN, 10ADMIN)
                if (rawInput.endsWith("ADMIN")) {
                    // "ADMIN"ì„ ì œê±°í•˜ê³  ìˆ«ìë§Œ ì¶”ì¶œ
                    const stageStr = rawInput.replace("ADMIN", "");
                    const targetStage = parseInt(stageStr);

                    // ìœ íš¨í•œ ìŠ¤í…Œì´ì§€ì¸ì§€ ê²€ì¦ (1 ~ 11)
                    if (!isNaN(targetStage) && targetStage >= 1 && targetStage <= 11) {
                        console.warn(`ğŸš€ ADMIN WARP: JUMPING TO STAGE ${targetStage}`);

                        // A. ê´€ë¦¬ì ëª¨ë“œ í™œì„±í™”
                        gameState.isAdminMode = true;
                        gameState.playerName = "ADMIN";

                        // B. UI ìˆ¨ê¸°ê¸°
                        document.getElementById('start-screen').style.display = 'none';
                        const myRankList = document.getElementById('my-rank-list');
                        if (myRankList) myRankList.style.display = 'none';

                        // C. ê²Œì„ ìƒíƒœ ë¦¬ì…‹ ë° ìŠ¤í…Œì´ì§€ ê°•ì œ ì£¼ì…
                        resetState();
                        gameState.currentStage = targetStage;

                        // [íŠ¹ì „] í…ŒìŠ¤íŠ¸ í¸ì˜ë¥¼ ìœ„í•œ ìì› ì§€ê¸‰
                        gameState.lives = 5; // ìƒëª… 5ê°œ
                        gameState.score = (targetStage - 1) * 10000; // ê°€ì§œ ì ìˆ˜ (í…ŒìŠ¤íŠ¸ìš©)
                        gameState.ultGauge = 1.0; // í•„ì‚´ê¸° ì™„ì¶©

                        // D. ìŠ¤í…Œì´ì§€ë³„ ë°ì´í„° ë¡œë“œ (ì¤‘ìš”!)
                        // 11ìŠ¤í…Œì´ì§€(ë¬´í•œ)ì™€ ì¼ë°˜ ìŠ¤í…Œì´ì§€ êµ¬ë¶„
                        if (targetStage === 11) {
                            gameState.stageTimer = 99999;
                            gameState.infiniteDifficulty = 1.0;
                            document.getElementById('stage-info').style.color = "#f00";
                        } else {
                            // levels ë°°ì—´ì—ì„œ í•´ë‹¹ ìŠ¤í…Œì´ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì¸ë±ìŠ¤ëŠ” stage-1)
                            // ë§Œì•½ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì•ˆì „í•˜ê²Œ 1ìŠ¤í…Œì´ì§€ ë°ì´í„° ì‚¬ìš©
                            const lvl = levels[targetStage - 1] || levels[0];
                            gameState.stageTimer = lvl.duration;
                            gameState.bossPhase = 'MINION'; // ë³´ìŠ¤ì „ ì´ˆê¸°í™”
                        }

                        // E. ê²Œì„ ë£¨í”„ ì‹œì‘
                        updateLivesUI();
                        gameState.isRunning = true;
                        requestAnimationFrame(gameLoop);
                        return; // â˜… ì—¬ê¸°ì„œ í•¨ìˆ˜ë¥¼ ì¢…ë£Œì‹œì¼œ ì•„ë˜ì˜ ì¼ë°˜ ë¡œì§(3ê¸€ì ì œí•œ ë“±)ì„ ë¬´ì‹œí•¨
                    }
                }
                // â–²â–²â–² [ë°±ë„ì–´ ì¢…ë£Œ] â–²â–²â–²


                // 2. ì¼ë°˜ ì‚¬ìš©ì ë¡œì§ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
                // 3ê¸€ì ê°•ì œ ì ˆì‚­
                let processedName = rawInput;
                if (processedName.length > 3) {
                    processedName = processedName.substring(0, 3);
                }

                // íŠ¹ìˆ˜ë¬¸ì ë°©ì§€ (ì„ íƒì‚¬í•­)
                const regex = /^[ã„±-ã…|ê°€-í£|a-z|A-Z|0-9\s]+$/;
                if (processedName.length > 0 && !regex.test(processedName)) {
                    alert("âš  ERROR âš \níŠ¹ìˆ˜ë¬¸ìëŠ” ê¸ˆì§€ë¿…!");
                    nameInput.value = "";
                    nameInput.focus();
                    return;
                }

                // ë¹ˆ ê°’ ì²´í¬
                if (processedName.length === 0) {
                    alert("âš  IDENTIFICATION REQUIRED âš \nì´ë¦„ì„ ì…ë ¥í•˜ìˆ‘ìˆ‘");
                    nameInput.focus();
                    nameInput.style.borderColor = '#f00';
                    return;
                }

                // ì •ìƒ ê²Œì„ ì‹œì‘
                nameInput.style.borderColor = '#0ff';
                gameState.playerName = processedName;
                localStorage.setItem('lastPilotName', gameState.playerName);
                localStorage.removeItem('myBestRecord');

                const myRankList = document.getElementById('my-rank-list');
                if (myRankList) myRankList.style.display = 'none';

                document.getElementById('start-screen').style.display = 'none';
                resetState();
                gameState.isRunning = true;
                requestAnimationFrame(gameLoop);
            }

            function resetState() {
                // 1. ê³¼ê±° ê¸°ë¡ ì¡°íšŒ ë° ë£¨í‚¤ íŒë³„
                const savedRecord = localStorage.getItem('myBestRecord');
                let bestScore = 0;
                if (savedRecord) {
                    try { bestScore = JSON.parse(savedRecord).score; }
                    catch (e) { bestScore = 0; }
                }

                // ê´€ë¦¬ì ëª¨ë“œ í”Œë˜ê·¸
                gameState.isAdminMode = false;

                // ë£¨í‚¤ ëª¨ë“œ íŒë³„
                const isRookie = (savedRecord && bestScore < 5000 && window.isVeteranServer);

                // 2. ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (ëŒ€ëŸ‰ ëŒ€ì…)
                Object.assign(gameState, {
                    score: 0, enemies: [], items: [], bullets: [],
                    // âœ… í”Œë ˆì´ì–´/ì…ë ¥ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™” (í•„ìˆ˜)
                    player: { x: 215, y: 720, w: 20, h: 20, speed: 500 },
                    keys: {},

                    skillMode: 'NORMAL', skillTimer: 0, spawnTimer: 0, itemSpawnTimer: 0,
                    lives: 3, isInvincible: false, invincibilityTimer: 0, drones: [],
                    isTransformed: false, isLaserMode: false, laserTimer: 0, isLunarMode: false,
                    currentStage: 1, stageTimer: 30, boss: null,
                    stageClearing: false, stageClearTimer: 0, survivalMode: false,
                    bossPhase: 'MINION', bossTimer: 0, bossResurrected: false,
                    downgradeFlash: 0, progressDisplay: 0, survivalStartCount: 0,
                    spawnDelay: 1.0,
                    stageTimerEnded: false, survivalTimer: 0, pendingBoss: null,

                    // ê¸°ëŠ¥ ì´ˆê¸°í™”
                    ultGauge: 0, autoFireTimer: 0,
                    isHomingMode: false, homingTimer: 0,
                    rainbowWave: null, dangerWarning: 0, timeBonusDisplay: null,

                    // ë¯¸ìŠ¤í„°ë¦¬ ë°•ìŠ¤ ë³€ìˆ˜
                    timeScale: 1.0, slowTimer: 0,

                    // [ìˆ˜ì • ì™„ë£Œ] ë¯¸ìŠ¤í„°ë¦¬ ë°•ìŠ¤ ë³€ìˆ˜ ì¬ì •ì˜
                    isVoidActive: false, voidTimer: 0, voidRadius: 0,
                    isGhostActive: false, ghostTimer: 0,
                    ghostHistory: [], // {x, y, isFiring} ìƒíƒœë¥¼ ì €ì¥í•  ë°°ì—´
                    boxSpawnedInStage: false, // ì´ë²ˆ ìŠ¤í…Œì´ì§€ ë°•ìŠ¤ ìŠ¤í° ì—¬ë¶€

                    // isMirrorActive ê´€ë ¨ ë³€ìˆ˜ëŠ” ì‚­ì œë¨
                    isGlitchActive: false, glitchTimer: 0,

                    // ì¶”ê°€ ì‹œìŠ¤í…œ ë³€ìˆ˜
                    currentStageScore: 0,
                    campingTimer: 0,
                    droneOverload: 0,
                    isSideMissileActive: false,

                    // ë¶„ì„ìš© ë°ì´í„°
                    startTime: Date.now(),
                    totalItemsSpawned: 0,
                    itemsCollected: 0,
                    lastHitBy: 'UNKNOWN',
                    deathCoords: { x: 0, y: 0 },

                    isRookieMode: isRookie,
                    boostActive: false
                }); // â˜… ì—¬ê¸°ì„œ Object.assignì´ ëë‚©ë‹ˆë‹¤. (ì¤‘ìš”!)

                // âœ… í˜¹ì‹œ NaN/ë¹„ì •ìƒ ê°’ ë‚¨ì•˜ì„ ë•Œ ê°•ì œ ë³µêµ¬
                if (!Number.isFinite(gameState.player.x) || !Number.isFinite(gameState.player.y)) {
                    gameState.player.x = 215;
                    gameState.player.y = 720;
                }
                lastTime = performance.now(); // âœ… í”„ë ˆì„ dt íŠ ë°©ì§€
                gridOffset = 0; // âœ… ë°°ê²½ ê·¸ë¦¬ë“œ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                gameState.infiniteDifficulty = 1.0; // âœ… ë¬´í•œëª¨ë“œ ë‚œì´ë„ ì´ˆê¸°í™”

                // 3. [CDSO Patch] ì¡°ì´ìŠ¤í‹± ë°ì´í„° ì´ˆê¸°í™” (ê°ì²´ ë°–ì—ì„œ ì‹¤í–‰í•´ì•¼ í•¨)
                gameState.joystick = {
                    active: false,
                    baseX: 0, baseY: 0,
                    stickX: 0, stickY: 0,
                    vecX: 0, vecY: 0
                };

                // í”Œë ˆì´ì–´ ìœ„ì¹˜ ë° UI ë¦¬ì…‹
                gameState.player.x = 215;
                gameState.player.y = 720; // Yì¢Œí‘œ ì´ˆê¸°í™” (canvas 90% ì§€ì )

                updateLivesUI();

                const myRankList = document.getElementById('my-rank-list');
                if (myRankList) myRankList.style.display = 'none';
            }


            // [CDSO ì „ëµ ìˆ˜ì •] ì ìˆ˜ íšë“ ë¡œì§ (Rookie Boost vs Infinite Penalty)
            function addScore(amount) {
                let finalAmount = amount;

                // [CDSO ì „ëµ ìˆ˜ì •] ìš°ì„ ìˆœìœ„ ë³€ê²½: ì§€ì˜¥ í˜ë„í‹° > ë£¨í‚¤ ë¶€ìŠ¤íŠ¸

                // 1. [Absolute Rule] Stage 11(íˆë“  ë£¨íŠ¸) ì§„ì… ì‹œ -> ë¬´ì¡°ê±´ 20%ë§Œ ë°˜ì˜
                if (gameState.currentStage >= 11) {
                    // ë£¨í‚¤ ëª¨ë“œì—¬ë„ ìƒê´€ì—†ìŒ. ì§€ì˜¥ì€ ì§€ì˜¥ì„.
                    finalAmount = Math.floor(amount * 0.2);
                    gameState.boostActive = false;
                }
                // 2. [Conditional Rule] ë£¨í‚¤ ëª¨ë“œì´ê³  5000ì  ë¯¸ë§Œì¼ ë•Œ -> 3ë°° ì ìš©
                else if (gameState.isRookieMode && gameState.score < 5000) {
                    finalAmount = amount * 3;
                    gameState.boostActive = true;
                }
                else {
                    gameState.boostActive = false;
                }

                // [CDSO Strategy] ìŠ¤í…Œì´ì§€ë³„ ì°¨ë“± ì œí•œ (Dynamic Cap)
                // Stage 1~9: ê¸°ë³¸ 3,000ì  + ìŠ¤í…Œì´ì§€ë‹¹ 1,000ì  ì¦ê°€ (ì˜ˆ: 1íƒ„ 4000, 9íƒ„ 12000)
                // Stage 10(ë³´ìŠ¤): 20,000ì  (ëŒ€í­ í—ˆìš©)
                // Stage 11(ë¬´í•œ): ì œí•œ ì—†ìŒ (Infinity)

                let stageMaxScore;
                if (gameState.currentStage >= 11) {
                    stageMaxScore = Infinity; // ë¬´í•œ ëª¨ë“œëŠ” ì œí•œ í•´ì œ
                } else if (gameState.currentStage === 10) {
                    stageMaxScore = 20000;    // ìµœì¢… ë³´ìŠ¤ì „ì€ ë„‰ë„‰í•˜ê²Œ
                } else {
                    // ì¼ë°˜ ìŠ¤í…Œì´ì§€ëŠ” ë³´ìˆ˜ì ìœ¼ë¡œ ì¡ìŒ
                    stageMaxScore = 3000 + (gameState.currentStage * 1000);
                }

                // í˜„ì¬ ìŠ¤í…Œì´ì§€ì—ì„œ íšë“í•œ ëˆ„ì  ì ìˆ˜ ì¶”ì  í•„ìš” (gameStateì— currentStageScore ë³€ìˆ˜ ì¶”ê°€ ì „ì œ)
                if (gameState.currentStageScore > stageMaxScore) {
                    finalAmount = Math.floor(amount * 0.1); // 10%ë§Œ ë°˜ì˜

                    // UI í”¼ë“œë°± (ì„ íƒì‚¬í•­): ì ìˆ˜ ìƒ‰ìƒì„ íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ 'íš¨ìœ¨ ê°ì†Œ' ì•Œë¦¼
                    const scoreEl = document.getElementById('current-score');
                    if (scoreEl) scoreEl.style.color = '#888';
                }



                // ì ìˆ˜ ë°˜ì˜
                if (finalAmount > 0) {
                    gameState.score += finalAmount;
                    // [CDSO ì¶”ê°€] ìŠ¤í…Œì´ì§€ë³„ ëˆ„ì  ì ìˆ˜ë¥¼ ê¸°ë¡í•˜ì—¬ 'ìˆ˜í™• ì²´ê°ì˜ ë²•ì¹™' ë¡œì§ ì‹¤ì²´í™”
                    gameState.currentStageScore = (gameState.currentStageScore || 0) + finalAmount;
                }

                // [UI í”¼ë“œë°±] ì ìˆ˜íŒ ìƒ‰ìƒ ìƒíƒœ í‘œì‹œ
                const scoreEl = document.getElementById('current-score');
                if (scoreEl) {
                    if (gameState.currentStage >= 11) {
                        scoreEl.style.color = '#f88'; // Hell Color
                        scoreEl.style.textShadow = '0 0 5px #f00';
                    } else if (gameState.boostActive) {
                        scoreEl.style.color = '#0f0'; // Boost Color
                        scoreEl.style.textShadow = '0 0 15px #0f0';
                    } else {
                        scoreEl.style.color = '#fff'; // Normal
                        scoreEl.style.textShadow = '0 0 10px #fff';
                    }
                }

            }




            function spawnEntities(dt) {
                if (gameState.spawnDelay > 0) {
                    gameState.spawnDelay -= dt;
                    return;
                }

                // â–¼â–¼â–¼ [ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”] â–¼â–¼â–¼
                const lvl = levels[gameState.currentStage - 1] || levels[0];


                // [CDSO ì „ëµ] Stage 11 ì´ìƒ: ë¬´í•œ ì„œë°”ì´ë²Œ ë¡œì§
                if (gameState.currentStage >= 11) {
                    gameState.infiniteDifficulty += dt * 0.01;
                    // [CDSO Hardening] infiniteDifficulty Hard Cap (NaN/Infinity ë°œì‚° ë°©ì§€)
                    gameState.infiniteDifficulty = Math.min(gameState.infiniteDifficulty, 10.0);
                    gameState.spawnTimer += dt;

                    const currentSpawnRate = Math.max(0.1, 0.5 / gameState.infiniteDifficulty);

                    if (gameState.spawnTimer > currentSpawnRate) {
                        const types = ['NORMAL', 'ZIGZAG', 'HOMING', 'SHOOTER', 'BOMBER', 'LASER_ENEMY'];
                        const type = types[Math.floor(Math.random() * types.length)];

                        let speedMult = gameState.infiniteDifficulty * 1.5;
                        if (speedMult > 5.0) speedMult = 5.0;

                        gameState.enemies.push({
                            x: Math.random() * (canvas.width - 24),
                            y: -32,
                            // [CDSO ìˆ˜ì •] ë¬´í•œ ëª¨ë“œ: UFO í¬ê¸° 40px ì ìš© (í™•ì¸ë¨)
                            w: (type === 'HOMING' ? 40 : 24),
                            h: (type === 'HOMING' ? 40 : 24),

                            speed: (200 + Math.random() * 100) * speedMult,
                            type: type,
                            amplitude: Math.random() * 2 + 1,
                            turnRate: 120 * speedMult,
                            time: 0,
                            exploded: false, locked: false, fired: false, chargeTimer: 0,
                            phase: 'ENTER', strafeDir: Math.random() < 0.5 ? 1 : -1
                        });
                        gameState.spawnTimer = 0;
                    }

                    // ë¬´í•œ ëª¨ë“œ ì•„ì´í…œ ìŠ¤í°
                    gameState.itemSpawnTimer += dt;
                    if (gameState.itemSpawnTimer > 10) {
                        const rand = Math.random();
                        let itemType = rand < 0.3 ? 'LIFE' : (rand < 0.6 ? 'SHIELD' : 'BLASTER');
                        gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type: itemType });
                        gameState.itemSpawnTimer = 0;
                    }
                    return;
                }


                // ë³´ìŠ¤ì „ ì«„ëª¹ ì†Œí™˜
                if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) {
                    gameState.spawnTimer += dt;

                    let spawnInterval = 2.5;
                    let eliteTypes = [];

                    if (gameState.boss.type === 'LUNAR') {
                        spawnInterval = 1.2; eliteTypes = ['HOMING', 'ZIGZAG'];
                    } else if (gameState.boss.type === 'SUN') {
                        spawnInterval = 1.5; eliteTypes = ['SHOOTER', 'BOMBER', 'LASER_ENEMY'];
                    }

                    if (gameState.bossResurrected) spawnInterval *= 0.7;

                    if (gameState.spawnTimer > spawnInterval) {
                        const type = eliteTypes[Math.floor(Math.random() * eliteTypes.length)];

                        // [CDSO ìˆ˜ì •] ë³´ìŠ¤ì „ ì«„ëª¹ì—ì„œë„ UFO í¬ê¸° 40px ì ìš©
                        const size = (type === 'HOMING') ? 40 : 25;

                        gameState.enemies.push({
                            x: Math.random() * (canvas.width - 30), y: -35,
                            w: size, h: size,
                            speed: 200 + Math.random() * 50, type: type,
                            amplitude: 1, turnRate: 100, time: 0,
                            exploded: false, locked: false, fired: false, chargeTimer: 0,
                            phase: 'ENTER', strafeDir: Math.random() < 0.5 ? 1 : -1
                        });
                        gameState.spawnTimer = 0;
                    }

                    // ë³´ìŠ¤ì „ ì•„ì´í…œ
                    gameState.itemSpawnTimer += dt;
                    if (gameState.itemSpawnTimer > 6) {
                        const rand = Math.random();
                        let itemType = rand < 0.5 ? 'BLASTER' : (rand < 0.9 ? 'SHIELD' : 'LIFE');
                        gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type: itemType });
                        gameState.totalItemsSpawned++;
                        gameState.itemSpawnTimer = 0;
                    }
                    return;
                }

                // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì¤‘ì´ë©´ ìŠ¤í° ì¤‘ë‹¨
                if (gameState.stageClearing || gameState.survivalMode || gameState.stageTimerEnded) return;

                // [CDSO ì „ëµ] ì¼ë°˜ ìŠ¤í…Œì´ì§€ ì  ì†Œí™˜ (ì—¬ê¸°ê°€ ë¬¸ì œì˜€ìŒ)
                gameState.spawnTimer += dt;
                if (gameState.spawnTimer > lvl.spawnRate && lvl.types.length > 0) {
                    const type = lvl.types[Math.floor(Math.random() * lvl.types.length)];

                    // [CDSO Fix] UFO í¬ê¸° ë³€ìˆ˜(size)ë¥¼ ì„ ì–¸í•˜ê³ ...
                    const size = (type === 'HOMING') ? 40 : 24;

                    gameState.enemies.push({
                        x: Math.random() * (canvas.width - 24), y: -32,
                        // [CDSO Fix] ...ì—¬ê¸°ì„œ ë³€ìˆ˜(size)ë¥¼ í™•ì‹¤íˆ ì‚¬ìš©í•©ë‹ˆë‹¤!
                        w: size, h: size,

                        speed: (200 + Math.random() * 100) * lvl.speedMult, type,
                        amplitude: Math.random() * 2 + 1, turnRate: 120 + Math.random() * 60, time: 0
                    });
                    gameState.spawnTimer = 0;
                }

                // ì•„ì´í…œ ì†Œí™˜
                gameState.itemSpawnTimer += dt;
                if (gameState.itemSpawnTimer > 8) {
                    const rand = Math.random();
                    let type = rand < 0.25 ? 'DRONE' : (rand < 0.5 ? 'SHIELD' : 'BLASTER');

                    if (gameState.currentStage === 6 || gameState.currentStage === 9) {
                        if (Math.random() < 0.3) type = 'LIFE';
                    }

                    // [ìˆ˜ì • ì™„ë£Œ] ë¯¸ìŠ¤í„°ë¦¬ ë°•ìŠ¤ ë³´ì¦ ìŠ¤í° (ìŠ¤í…Œì´ì§€ ì‹œê°„ ì ˆë°˜ ì§€ë‚¬ëŠ”ë° ì•ˆ ë‚˜ì™”ìœ¼ë©´ ê°•ì œ ìŠ¤í°)
                    const lvl = levels[gameState.currentStage - 1] || levels[0];
                    const halfTime = (gameState.stageTimer < lvl.duration / 2);
                    const forceSpawn = halfTime && !gameState.boxSpawnedInStage && !lvl.isBoss;

                    if (Math.random() < 0.30 || forceSpawn) {
                        type = 'MYSTERY_BOX';
                        gameState.boxSpawnedInStage = true; // ìŠ¤í° ì²´í¬

                    }

                    gameState.items.push({ x: Math.random() * (canvas.width - 25), y: -35, w: 25, h: 25, speed: 150, type });
                    gameState.totalItemsSpawned++;
                    gameState.itemSpawnTimer = 0;
                }
            }



            function spawnBoss(hp, type) {
                const isLunar = type === 'LUNAR';
                const w = isLunar ? 115 : 100;  // ë£¨ë‚˜ 15% í¬ê¸° ì¦ê°€
                const h = isLunar ? 92 : 80;
                gameState.boss = {
                    x: canvas.width / 2 - w / 2, y: 50, w, h,
                    hp, maxHp: hp, moveDir: 1, shootTimer: 0, type: type || 'LUNAR',
                    isSupernova: false, shockwaveTimer: 0
                };
                // gameState.enemies = [];
                gameState.bossTimer = 0;
                gameState.spawnTimer = 0;
            }

            function triggerBigBang() {
                const boss = gameState.boss;
                const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
                for (let i = 0; i < 24; i++) {
                    const rad = (i * 15) * Math.PI / 180;
                    const speed = 200 + Math.random() * 100;
                    gameState.enemies.push({
                        x: cx - 6, y: cy,
                        w: 12, h: 12, speed: 0, type: 'BULLET',
                        vx: Math.cos(rad) * speed, vy: Math.sin(rad) * speed,
                        amplitude: 0, turnRate: 0, time: 0
                    });
                }
            }

            function updateBoss(dt) {
                const boss = gameState.boss;
                if (!boss) return;

                gameState.bossTimer += dt;

                // [Patch B] 90ì´ˆ(1ë¶„ 30ì´ˆ) ì´ˆê³¼ ì‹œ ê´‘í­í™” ëª¨ë“œ ë°œë™ (Hard Cap)
                if (gameState.bossTimer > 90) {
                    // ê²½ê³  ë©”ì‹œì§€ 1íšŒ ì¶œë ¥ (UX ê³ ë ¤)
                    if (!boss.enraged) {
                        boss.enraged = true;
                        document.getElementById('res-title').textContent = "âš  SYSTEM CRITICAL: ENRAGE âš ";
                        // ê´‘í­í™” íš¨ê³¼: ê³µê²© ì†ë„ 5ë°°, ì´ë™ ì†ë„ 3ë°°
                        boss.shootTimer = 100; // ì¦‰ì‹œ ë°œì‚¬ ìœ ë„
                    }

                    // ê°•ì œ ë°ë¯¸ì§€ ë¡œì§ (í”Œë ˆì´ì–´ë¥¼ ì¦‰ì‚¬ì‹œí‚¤ê±°ë‚˜ ë³´ìŠ¤ê°€ ìí­í•˜ê±°ë‚˜)
                    // ì—¬ê¸°ì„œëŠ” ë‚œì´ë„ë¥¼ ê·¹ë„ë¡œ ë†’ì—¬ 'ìì—°ìŠ¤ëŸ¬ìš´ ì£½ìŒ' ìœ ë„
                    dt *= 5.0; // ì‹œê°„ ê°€ì†
                }



                boss.x += boss.moveDir * 120 * dt;
                if (boss.x <= 0 || boss.x >= canvas.width - boss.w) boss.moveDir *= -1;
                boss.shootTimer += dt;

                if (boss.type === 'LUNAR') {
                    // 1. ì˜¤ë¹„íƒˆ ë¹„íŠ¸ (ìœ„ì„±) ì‹œìŠ¤í…œ
                    // ìœ„ì„± íšŒì „ ê°ë„ ì—…ë°ì´íŠ¸ (ê³„ì† ë±…ê¸€ë±…ê¸€ ë”)
                    boss.orbitAngle = (boss.orbitAngle || 0) + dt * 1.5; 
                    
                    // ìœ„ì„± ê³µê²© íƒ€ì´ë¨¸
                    boss.satelliteTimer = (boss.satelliteTimer || 0) + dt;
                    
                    // 0.8ì´ˆë§ˆë‹¤ ìœ„ì„± 2ê°œì—ì„œ ì´ì•Œ ë°œì‚¬
                    if (boss.satelliteTimer > 0.8) {
                        const bx = boss.x + boss.w / 2;
                        const by = boss.y + boss.h / 2;
                        
                        for(let i=0; i<2; i++) {
                            // ìœ„ì„± í˜„ì¬ ìœ„ì¹˜ ê³„ì‚°
                            const angle = boss.orbitAngle + (i * Math.PI); // 180ë„ ê°„ê²© (ì„œë¡œ ë°˜ëŒ€í¸)
                            const satX = bx + Math.cos(angle) * 90; // ë³¸ì²´ë¡œë¶€í„° ê±°ë¦¬ 90
                            const satY = by + Math.sin(angle) * 90;
                            
                            // ìœ„ì„± íƒ„í™˜ ë°œì‚¬ (ì§ì„ ìœ¼ë¡œ ì•„ë˜ë¡œ ê½‚ìŒ)
                            gameState.enemies.push({
                                x: satX - 5, y: satY, 
                                w: 10, h: 10, 
                                speed: 0, type: 'ENEMY_BULLET',
                                vx: 0, vy: 450, // ì†ë„ ë¹ ë¦„
                                color: '#fff'   // í°ìƒ‰ íƒ„í™˜
                            });
                        }
                        boss.satelliteTimer = 0;
                    }


                    // ìœ ì„± ê³µê²© (METEOR)
                    if (boss.shootTimer > 1.0) {
                        for (let angle = -30; angle <= 30; angle += 30) {
                            const rad = (90 + angle) * Math.PI / 180;
                            gameState.enemies.push({
                                x: boss.x + boss.w / 2 - 14, y: boss.y + boss.h,
                                w: 28, h: 28, speed: 0, type: 'METEOR',
                                vx: Math.cos(rad) * 200,
                                vy: Math.sin(rad) * 200,
                                amplitude: 0, turnRate: 0, time: 0
                            });
                        }
                        boss.shootTimer = 0;
                    }
                    // ì›”ê´‘ ì¶©ê²©íŒŒ (3ì´ˆë§ˆë‹¤) + DANGER ê²½ê³ 
                    boss.shockwaveTimer += dt;

                    // ì¶©ê²©íŒŒ ë°œì‚¬ 0.5ì´ˆ ì „ DANGER ê²½ê³  ì‹œì‘
                    if (boss.shockwaveTimer > 2.5 && boss.shockwaveTimer <= 3) {
                        gameState.dangerWarning = 0.5 - (3 - boss.shockwaveTimer);
                    }

                    if (boss.shockwaveTimer > 3) {
                        const px = gameState.player.x + gameState.player.w / 2;
                        const bx = boss.x + boss.w / 2, by = boss.y + boss.h;
                        const dx = px - bx, dy = gameState.player.y - by;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        gameState.enemies.push({
                            x: bx - 10, y: by,
                            w: 20, h: 20, speed: 0, type: 'SHOCKWAVE',
                            vx: (dx / dist) * 350, vy: (dy / dist) * 350,
                            amplitude: 0, turnRate: 0, time: 0
                        });
                        boss.shockwaveTimer = 0;
                        gameState.dangerWarning = 0;  // ê²½ê³  ì¢…ë£Œ
                    }
                } else if (boss.type === 'SUN') {
                    // [CDSO ì „ëµ ìˆ˜ì •] ë‚œì´ë„ ëŒ€í­ ìƒí–¥: Spinning Inferno íŒ¨í„´
                    // 1. ë°œì‚¬ ì†ë„: 2í˜ì´ì¦ˆ(Supernova)ì—ì„œëŠ” 0.7ì´ˆë§ˆë‹¤ ë‚œì‚¬ (ê¸°ì¡´ 1.5ì´ˆ)
                    const fireRate = boss.isSupernova ? 0.7 : 1.6;

                    // 2. íƒ„ë§‰ ë°€ë„: 2í˜ì´ì¦ˆì—ì„œëŠ” 24ë°œ (ê¸°ì¡´ 16ë°œ)
                    const bulletCount = boss.isSupernova ? 24 : 14;

                    if (boss.shootTimer > fireRate) {
                        // 3. íšŒì „ ë¡œì§: ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë°œì‚¬ ê°ë„ê°€ ëŒì•„ê° (ë‚˜ì„ í˜• íŒ¨í„´)
                        // Supernova ìƒíƒœì¼ ë•ŒëŠ” íšŒì „ ì†ë„ 3ë°° ì¦ê°€
                        const spinSpeed = boss.isSupernova ? 150 : 40;
                        const baseAngle = (Date.now() / 1000) * spinSpeed;

                        for (let i = 0; i < bulletCount; i++) {
                            // ê¸°ë³¸ ê°ë„ + íšŒì „ ê°ë„ ì ìš©
                            const angle = baseAngle + (i * (360 / bulletCount));
                            const rad = angle * Math.PI / 180;

                            // 4. ë³€ì¹™ ì†ë„ (Variable Velocity): 
                            // 2í˜ì´ì¦ˆì—ì„œëŠ” ì§ìˆ˜/í™€ìˆ˜ ë²ˆì§¸ íƒ„í™˜ì˜ ì†ë„ë¥¼ ë‹¤ë¥´ê²Œ í•˜ì—¬ 'íƒ„ë§‰ ë²½'ì„ í˜•ì„±
                            let bSpeed = boss.isSupernova ? 240 : 190;
                            if (boss.isSupernova && i % 2 === 0) {
                                bSpeed += 120; // ì§ìˆ˜ íƒ„í™˜ì€ í›¨ì”¬ ë¹ ë¥´ê²Œ ë°œì‚¬ (360) -> ì—‡ë°•ì ìœ ë°œ
                            }

                            gameState.enemies.push({
                                x: boss.x + boss.w / 2 - 6, y: boss.y + boss.h / 2,
                                w: 12, h: 12, speed: 0, type: 'BULLET',
                                vx: Math.cos(rad) * bSpeed,
                                vy: Math.sin(rad) * bSpeed,
                                amplitude: 0, turnRate: 0, time: 0
                            });
                        }
                        boss.shootTimer = 0;
                    }
                }

                if (gameState.isLaserMode) {
                    const laserL = gameState.player.x + gameState.player.w / 2 - 20;
                    const laserR = gameState.player.x + gameState.player.w / 2 + 20;
                    if (boss.x + boss.w > laserL && boss.x < laserR) {
                        boss.hp -= dt * 8;
                        addScore(Math.floor(dt * 10));
                    }
                }

                for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                    if (checkRectCollision(gameState.bullets[bi], boss)) {
                        boss.hp--; gameState.bullets.splice(bi, 1); addScore(5);
                    }
                }

                if (boss.hp <= 0) {
                    if (boss.type === 'SUN' && !gameState.bossResurrected) {
                        triggerBigBang();
                        boss.hp = boss.maxHp * 0.5;
                        boss.isSupernova = true;
                        gameState.bossResurrected = true;
                    } else {
                        // [CDSO ì „ëµ ìˆ˜ì •] ë³´ìŠ¤ ë“±ê¸‰ë³„ ì°¨ë“± ë³´ìƒ ì‹œìŠ¤í…œ (Tiered Scoring)

                        let baseClearScore = 0;
                        let timeBonus = 0;
                        let perfectBonus = 0;
                        let timeLimitS = 0; // Së“±ê¸‰ ê¸°ì¤€ ì‹œê°„
                        let timeLimitA = 0; // Aë“±ê¸‰ ê¸°ì¤€ ì‹œê°„

                        // 1. ë³´ìŠ¤ íƒ€ì…ë³„ ê¸°ì¤€ ì„¤ì • (Configuration)
                        if (boss.type === 'LUNAR') {
                            // [Stage 5] ì¤‘ê°„ ë³´ìŠ¤: íƒ€ì´íŠ¸í•œ ì‹œê°„ ì œí•œ, ì ë‹¹í•œ ë³´ìƒ
                            baseClearScore = 200;
                            timeLimitS = 10; // 25ì´ˆ ì»· (Speed)
                            timeLimitA = 20;

                            if (gameState.bossTimer <= timeLimitS) timeBonus = 300;
                            else if (gameState.bossTimer <= timeLimitA) timeBonus = 200;
                            else timeBonus = 100;

                        } else {
                            // [Stage 10] ìµœì¢… ë³´ìŠ¤: ë„‰ë„‰í•œ ì‹œê°„ ì œí•œ, ì••ë„ì ì¸ ë³´ìƒ
                            baseClearScore = 300; // ì—”ë”© ë³´ìƒ ìƒí–¥
                            timeLimitS = 30; // 50ì´ˆ ì»· (Endurance)
                            timeLimitA = 50;

                            if (gameState.bossTimer <= timeLimitS) timeBonus = 700; // Legendary
                            else if (gameState.bossTimer <= timeLimitA) timeBonus = 400;
                            else timeBonus = 200;
                        }

                        // 2. ë…¸ë¯¸ìŠ¤ ë³´ë„ˆìŠ¤ (ê³µí†µ ë¡œì§)
                        // ìµœì¢… ë³´ìŠ¤ëŠ” ì–´ë µê¸° ë•Œë¬¸ì— ë…¸ë¯¸ìŠ¤ ê°€ì‚°ì ì„ ë” ë†’ê²Œ ì±…ì •
                        if (gameState.lives >= gameState.maxLives) { // ë§Œí”¼ì¼ ë•Œ
                            perfectBonus = (boss.type === 'SUN') ? 1000 : 500;
                        }

                        // 3. ìµœì¢… í•©ì‚°
                        const totalBonus = baseClearScore + timeBonus + perfectBonus;
                        addScore(totalBonus);

                        // 4. ê²°ê³¼ í‘œì‹œ (UI Feedback)
                        // ë“±ê¸‰ í‘œì‹œ (S, A, B)
                        let rankText = gameState.bossTimer <= timeLimitS ? "RANK S" : (gameState.bossTimer <= timeLimitA ? "RANK A" : "RANK B");

                        // ë³´ë„ˆìŠ¤ ì •ë³´ë¥¼ í™”ë©´ì— ë³´ì—¬ì£¼ê¸° ìœ„í•´ ê°ì²´ì— ì €ì¥
                        gameState.timeBonusDisplay = {
                            amount: totalBonus,
                            text: `${rankText} BONUS`, // í™”ë©´ì— S, A, B ë“±ê¸‰ë„ ê°™ì´ í‘œì‹œ
                            timer: 3.0
                        };

                        // ë£¨ë‚˜ ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ ë£¨ë‚˜ ëª¨ë“œ í™œì„±í™” (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                        if (boss.type === 'LUNAR') {
                            gameState.isLunarMode = true;
                        }
                        triggerStageClear();
                    }


                    return;
                }

                if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, boss)) {
                    gameState.lastHitBy = boss.type + '_BODY'; // [ì¶”ê°€] ë³´ìŠ¤ ëª¸í†µ ì¶©ëŒ ê¸°ë¡
                    takeDamage();
                }
            }

            function triggerStageClear() {
                gameState.stageClearing = true;
                gameState.stageClearTimer = 1.0;  // ìŠ¤í…Œì´ì§€ ë¬¸êµ¬ 1ì´ˆ
                gameState.boss = null;
                gameState.survivalMode = false;
                gameState.bossPhase = 'MINION';
                gameState.bossResurrected = false;
                // Phase 3: pendingBoss ë¡œì§ ì œê±° - spawnBoss ì§ì ‘ í˜¸ì¶œ ë°©ì‹ ì‚¬ìš©
            }

            // Phase 5: ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ í†µí•© í•¨ìˆ˜
            function handleStageTransition(dt) {
                const lvl = levels[gameState.currentStage - 1];

                // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì²˜ë¦¬
                if (gameState.stageClearing) {
                    gameState.stageClearTimer -= dt;
                    if (gameState.stageClearTimer <= 0) {
                        gameState.enemies = [];
                        advanceStage();
                    }
                    return;
                }

                // ë³´ìŠ¤ ìŠ¤í…Œì´ì§€
                if (lvl.isBoss) {
                    if (gameState.bossPhase === 'MINION') {
                        gameState.stageTimer -= dt;
                        if (gameState.stageTimer <= 0) {
                            gameState.bossPhase = 'BOSS';
                            gameState.stageTimerEnded = true;
                            spawnBoss(lvl.bossHP, lvl.bossType);
                        }
                    } else if (gameState.bossPhase === 'BOSS') {
                        updateBoss(dt);
                    }
                    return;
                }

                // ì¼ë°˜ ìŠ¤í…Œì´ì§€
                if (!gameState.stageTimerEnded) {
                    gameState.stageTimer -= dt;
                    if (gameState.stageTimer <= 0) {
                        gameState.stageTimerEnded = true;
                    }
                }

                if (gameState.stageTimerEnded && !gameState.survivalMode && getActiveEnemyCount() === 0) {
                    gameState.survivalMode = true;
                    gameState.survivalTimer = 0.7;
                    gameState.enemies = [];
                }

                if (gameState.survivalMode) {
                    gameState.survivalTimer -= dt;
                    if (gameState.survivalTimer <= 0) {
                        triggerStageClear();
                    }
                }
            }


            function advanceStage() {
                // [CDSO ìˆ˜ì •] ìŠ¤í…Œì´ì§€ ì „ì´ ë¡œì§ ì •ìƒí™”

                // 1. [End Game Check] 10ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ì‹œ ë¶„ê¸° ì²˜ë¦¬
                if (gameState.currentStage >= 10) {
                    // íŒë‹¨ ê¸°ì¤€ ë°ì´í„°
                    const isTopRanker = gameState.score > (gameState.rank3Score || 0);
                    const isPerfectCondition = gameState.lives >= 3;

                    // [Scenario A] ë­ì»¤ ë“±ê·¹ (Top 3) -> ëª…ì˜ˆë¡œìš´ ì¡¸ì—…
                    if (isTopRanker) {
                        gameComplete();
                        return;
                    }

                    // [Scenario B] ë­í‚¹ ì‹¤íŒ¨ BUT ì™„ë²½í•œ ìƒíƒœ -> íˆë“  ë£¨íŠ¸ ê°œë°©
                    if (isPerfectCondition) {
                        console.log("ğŸ”“ Hidden Stage Unlocked");

                        gameState.currentStage = 11;

                        // â–¼â–¼â–¼ [CDSO Patch: ì—¬ê¸°ì—ë„ ë°˜ë“œì‹œ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤!] â–¼â–¼â–¼
                        gameState.currentStageScore = 0;

                        gameState.stageTimer = 99999;
                        gameState.stageClearing = false;
                        gameState.survivalMode = false;
                        gameState.spawnTimer = 0;
                        gameState.infiniteDifficulty = 1.0;

                        // UX í”¼ë“œë°±
                        const stageInfo = document.getElementById('stage-info');
                        if (stageInfo) {
                            stageInfo.textContent = "âš  HIDDEN ROUTE: OVERDRIVE âš ";
                            stageInfo.style.color = "#f00";
                            stageInfo.animate([
                                { opacity: 0, transform: 'scale(1.5)' },
                                { opacity: 1, transform: 'scale(1.0)' }
                            ], { duration: 1000, easing: 'ease-out' });
                        }
                        return;
                    }

                    // [Scenario C] ì¼ë°˜ ì—”ë”©
                    gameComplete();
                    return;
                }

                // 2. [Normal Progression] 1~9 ìŠ¤í…Œì´ì§€ ì§„í–‰ (ì—¬ê¸°ê°€ else ë¸”ë¡ì´ ë˜ë©´ ì•ˆ ë¨!)
                gameState.currentStage++;

                // ë§Œì•½ 11ìŠ¤í…Œì´ì§€ì¸ë° ë°ì´í„°ê°€ ì—†ë‹¤ë©´ ê¸´ê¸‰ ë³µêµ¬
                if (gameState.currentStage === 11 && !levels[10]) {
                    levels.push({
                        stage: 11, duration: 99999, theme: '#050505',
                        speedMult: 2.0, spawnRate: 0.1, types: [], isBoss: false
                    });
                    console.warn("âš  Stage 11 Data Restored by Fail-Safe System");
                }


                // â–¼â–¼â–¼ [CDSO Patch: ìˆ˜í™• ì²´ê° ë²•ì¹™ì„ ìœ„í•œ ì´ˆê¸°í™”] â–¼â–¼â–¼
                gameState.currentStageScore = 0;


                // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ ì •ë³´ ë¡œë“œ
                const lvl = levels[gameState.currentStage - 1];
                gameState.stageTimer = lvl.duration;
                gameState.stageClearing = false;
                gameState.survivalMode = false;
                gameState.stageTimerEnded = false;
                gameState.survivalTimer = 0;
                gameState.spawnTimer = 0;
                gameState.itemSpawnTimer = 0;

                gameState.bossPhase = 'MINION';
                gameState.bossResurrected = false;
                gameState.progressDisplay = 0;
                gameState.enemies = [];
                gameState.items = [];
                gameState.spawnDelay = 0.8;

                console.log(`âœ… Advanced to Stage ${gameState.currentStage}`);
            }


            async function autoSaveProcess(title) {
                // 1. ê²°ê³¼ í™”ë©´ ê¸°ë³¸ ì„¸íŒ…
                const finalScore = Math.round(gameState.score);
                document.getElementById('res-title').textContent = title;
                document.getElementById('res-stage').textContent = gameState.currentStage;
                document.getElementById('res-score').textContent = finalScore;

                const screen = document.getElementById('rank-input-screen');
                const statusMsg = document.getElementById('save-status');
                const actionBtns = document.getElementById('action-buttons');
                const resultList = document.getElementById('result-rank-list');

                // í™”ë©´ í‘œì‹œ
                screen.style.display = 'flex';
                screen.classList.add('show');

                // UI ì´ˆê¸°í™” (ì´ì „ ê²Œì„ ì”ì—¬ë¬¼ ì œê±°)
                statusMsg.style.display = 'block';
                statusMsg.textContent = "â³ UPLOADING DATA...";
                actionBtns.style.display = 'none';
                resultList.style.display = 'none';

                // 2. ê´€ë¦¬ì ëª¨ë“œ ì²´í¬ (ì €ì¥ ì•ˆí•¨)
                if (gameState.isAdminMode) {
                    statusMsg.textContent = "ğŸš« ADMIN MODE (NO SAVE)";
                    statusMsg.style.color = "#888";
                    actionBtns.style.display = 'flex';
                    return;
                }

                // 3. ìë™ ì €ì¥ ì‹¤í–‰ (Zero-Click)
                const name = gameState.playerName || "UNKNOWN";

                // Firebase ì „ì†¡
                const myRank = await saveToFirebase(name, finalScore, gameState.currentStage);

                // ë­í‚¹ ì¬ì¡°íšŒ
                await initFirebaseRanking();
                gameState.finalRank = myRank;

                // 4. ì €ì¥ ì™„ë£Œ í›„ UI ì—…ë°ì´íŠ¸
                statusMsg.style.display = 'none'; // 'ì €ì¥ì¤‘' ë©”ì‹œì§€ ìˆ¨ê¹€

                // // ë­í‚¹ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
                // if (myRank) {
                //     const top5Content = document.getElementById('leaderboard').innerHTML;
                //     const myRankHTML = `
                //     <li class="rank-me">
                //         <span class="rank-badge">${myRank}</span>
                //         <span class="player-name">${name}</span>
                //         <span class="player-score">${finalScore.toLocaleString()}</span>
                //         <span class="player-stage">ST.${gameState.currentStage}</span>
                //     </li>
                // `;
                //     resultList.innerHTML = top5Content + myRankHTML;
                //     resultList.style.display = 'block';
                // } else {
                //     // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì‹œ
                //     resultList.innerHTML = '<li style="color:#f00; text-align:center;">Network Error<br>Save Failed</li>';
                //     resultList.style.display = 'block';
                // }

                // 5. ë²„íŠ¼ ë³´ì´ê¸° (ì¬ì‹œì‘/ê³µìœ )
                actionBtns.style.display = 'flex';
            }






            function gameComplete() {
                gameState.isRunning = false;
                // [CDSO Patch] ê²Œì„ í´ë¦¬ì–´ ì‹œì—ë„ ìë™ ì €ì¥
                autoSaveProcess('ğŸ‰ MISSION COMPLETE');
            }

            // ë¬´ì§€ê°œ íŒŒë™ ë°œë™
            function activateRainbowWave() {
                gameState.rainbowWave = { active: true, y: canvas.height };
                gameState.ultGauge = 0;
            }

            // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ìœ ë„íƒ„ìš©)
            function findNearestEnemy() {
                const px = gameState.player.x + gameState.player.w / 2;
                const py = gameState.player.y;
                let nearest = null;
                let minDist = Infinity;

                // [ì¶”ê°€ëœ ë¡œì§] ë³´ìŠ¤ê°€ ì¡´ì¬í•˜ë©´ ì¼ë‹¨ ê°€ì¥ ê°€ê¹Œìš´ ì ìœ¼ë¡œ ì„¤ì •
                if (gameState.boss) {
                    const bx = gameState.boss.x + gameState.boss.w / 2;
                    const by = gameState.boss.y + gameState.boss.h / 2;
                    // í”Œë ˆì´ì–´ì™€ ë³´ìŠ¤ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                    const dist = Math.sqrt(Math.pow(px - bx, 2) + Math.pow(py - by, 2));
                    minDist = dist;
                    nearest = gameState.boss;
                }

                // ê¸°ì¡´ ì ë“¤ê³¼ ê±°ë¦¬ ë¹„êµ (ë³´ìŠ¤ë³´ë‹¤ ë” ê°€ê¹Œìš´ ì ì´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ë³€ê²½)
                for (const en of gameState.enemies) {
                    if (en.y < py && en.type !== 'BULLET' && en.type !== 'ENEMY_BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'METEOR') {
                        const ex = en.x + en.w / 2;
                        const ey = en.y + en.h / 2;
                        const dist = Math.sqrt(Math.pow(px - ex, 2) + Math.pow(py - ey, 2));
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = en;
                        }
                    }
                }
                return nearest;
            }

            function update(dt) {
                if (!gameState.isRunning) return;

                const lvl = levels[gameState.currentStage - 1] || levels[0];

                // 1. ë¯¸ìŠ¤í„°ë¦¬ ë°•ìŠ¤ ë° ìƒíƒœ íƒ€ì´ë¨¸ ì²˜ë¦¬
                if (gameState.slowTimer > 0) {
                    gameState.slowTimer -= dt;
                    if (gameState.slowTimer <= 0) gameState.timeScale = 1.0;
                } else {
                    gameState.timeScale = 1.0;
                }

                if (gameState.isGlitchActive) {
                    gameState.glitchTimer -= dt;
                    if (gameState.glitchTimer <= 0) gameState.isGlitchActive = false;
                    if (Math.random() < 0.3) canvas.style.transform = `translate(${Math.random() * 4 - 2}px, ${Math.random() * 4 - 2}px)`;
                    else canvas.style.transform = 'none';
                } else {
                    canvas.style.transform = 'none';
                }

                if (gameState.isGhostActive) {
                    gameState.ghostTimer -= dt;
                    if (gameState.ghostTimer <= 0) {
                        gameState.isGhostActive = false;
                        gameState.ghostHistory = [];
                    }
                    
                    // 1. í˜„ì¬ ìƒíƒœ ê¸°ë¡ (ìœ„ì¹˜ + ì‚¬ê²©ì—¬ë¶€)
                    gameState.ghostHistory.push({ 
                        x: gameState.player.x, 
                        y: gameState.player.y,
                        isFiring: (gameState.autoFireTimer === 0)
                    });
                    if (gameState.ghostHistory.length > 90) gameState.ghostHistory.shift();

                    // 2. 1.5ì´ˆ ì „(90í”„ë ˆì„) ë°ì´í„°ë¡œ í–‰ë™ ì¬í˜„
                    if (gameState.ghostHistory.length >= 2) {
                        const ghostAction = gameState.ghostHistory[0];
                        
                        // [ìˆ˜ì •] í™•ë¥  ì²´í¬(Math.random) ì‚­ì œ -> ê¸°ë¡ëœ ëŒ€ë¡œ ë¬´ì¡°ê±´ ë°œì‚¬
                        if (ghostAction.isFiring) {
                            gameState.bullets.push({
                                x: ghostAction.x + 5, 
                                y: ghostAction.y, 
                                w: 10, h: 15, 
                                speed: 550,
                                color: '#0f0',      // ê³ ìŠ¤íŠ¸ ì „ìš© ë…¹ìƒ‰ íƒ„í™˜
                                isGhostBullet: true // ê²Œì´ì§€ ì¶©ì „ ë°©ì§€ìš© íƒœê·¸
                            });
                        }

                        // ê³ ìŠ¤íŠ¸ ëª¸í†µ ë°•ì¹˜ê¸° (ì  ì‚­ì œ)
                        const ghostBox = { x: ghostAction.x, y: ghostAction.y, w: 20, h: 20 };
                        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                            if (checkRectCollision(ghostBox, gameState.enemies[i])) {
                                addScore(10);
                                gameState.enemies.splice(i, 1);
                                // íƒ€ê²©ê° íš¨ê³¼ (ì„ íƒì‚¬í•­)
                                triggerHaptic(20);
                            }
                        }
                    }
                }

                // [ìˆ˜ì • ì™„ë£Œ] ë³´ì´ë“œ í™€ (ë¸”ë™í™€) ì—…ê·¸ë ˆì´ë“œ ë¡œì§
                if (gameState.isVoidActive) {
                    gameState.voidTimer -= dt;
                    if (gameState.voidRadius < 180) gameState.voidRadius += dt * 300;

                    if (gameState.voidTimer <= 0) {
                        gameState.isVoidActive = false;
                        gameState.voidRadius = 0;
                    }

                    const cx = gameState.player.x + gameState.player.w / 2;
                    const cy = gameState.player.y + gameState.player.h / 2;

                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {                      
                        const en = gameState.enemies[i];
                        const dx = cx - (en.x + en.w / 2);
                        const dy = cy - (en.y + en.h / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < gameState.voidRadius) {
                            // ë¹¨ë ¤ë“¤ì–´ê°€ëŠ” ì—°ì¶œ (í¬ê¸° ê°ì†Œ + ìœ„ì¹˜ ì´ë™)
                            en.x += dx * dt * 5;
                            en.y += dy * dt * 5;
                            en.w *= 0.95; en.h *= 0.95; 

                            // ì¤‘ì‹¬ì— ë„ë‹¬í•˜ê±°ë‚˜ ë„ˆë¬´ ì‘ì•„ì§€ë©´ ì†Œë©¸
                            if (dist < 30 || en.w < 5) { 
                                gameState.enemies.splice(i, 1);
                                addScore(20);
                            }
                        }
                    }
                }
                


                if (gameState.ultGauge < 1 && !gameState.rainbowWave) {
                    gameState.ultGauge = Math.min(1, gameState.ultGauge + dt * 0.05);
                }

                // ìë™ ê³µê²© ë¡œì§
                gameState.autoFireTimer += dt;
                if (gameState.autoFireTimer >= 0.2) {
                    const cx = gameState.player.x + gameState.player.w / 2;
                    const cy = gameState.player.y;
                    const sharedTarget = findNearestEnemy();

                    if (gameState.isHomingMode) {
                        [-0.25, 0.25].forEach(angle => {
                            let vx = 0, vy = -550;
                            if (sharedTarget) {
                                const tx = sharedTarget.x + sharedTarget.w / 2;
                                const ty = sharedTarget.y + sharedTarget.h / 2;
                                const dx = tx - cx, dy = ty - cy;
                                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                                let dirX = dx / dist, dirY = dy / dist;
                                const cos = Math.cos(angle), sin = Math.sin(angle);
                                vx = (dirX * cos - dirY * sin) * 550;
                                vy = (dirX * sin + dirY * cos) * 550;
                            } else {
                                vx = Math.sin(angle) * 550; vy = -Math.cos(angle) * 550;
                            }
                            gameState.bullets.push({
                                x: cx - 5, y: cy, w: 10, h: 15, speed: 550,
                                isHoming: true, target: sharedTarget, vx: vx, vy: vy, turnRate: 8.0
                            });
                        });
                    } else {
                        gameState.bullets.push({ x: cx - 5, y: cy, w: 10, h: 15, speed: 550 });
                    }
                    gameState.autoFireTimer = 0;

                    if (gameState.isTransformed && gameState.isSideMissileActive) {
                        [-35, 35].forEach(offset => {
                            gameState.bullets.push({
                                x: cx + offset - 4, y: cy, w: 8, h: 12, speed: 500,
                                isHoming: true, target: sharedTarget, vx: 0, vy: -500, turnRate: 6.0, color: '#0ff'
                            });
                        });
                    }
                }

                if (gameState.isHomingMode) {
                    gameState.homingTimer -= dt;
                    if (gameState.homingTimer <= 0) gameState.isHomingMode = false;
                }

                if (gameState.rainbowWave) {
                    gameState.rainbowWave.y -= 500 * dt;
                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                        const en = gameState.enemies[i];
                        if (en.y + en.h > gameState.rainbowWave.y) {
                            addScore(getEnemyScore(en.type) * 20);
                            gameState.enemies.splice(i, 1);
                        }
                    }
                    if (gameState.rainbowWave.y < -50) gameState.rainbowWave = null;
                }

                // [CDSO Sync] ì ìˆ˜ DOM ì—…ë°ì´íŠ¸ëŠ” update() ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™ë¨ (ì•„ë˜ ì°¸ì¡°)

                if (gameState.isInvincible) {
                    gameState.invincibilityTimer -= dt;
                    if (gameState.invincibilityTimer <= 0) gameState.isInvincible = false;
                }
                if (gameState.downgradeFlash > 0) gameState.downgradeFlash -= dt;

                if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                    gameState.timeBonusDisplay.timer -= dt;
                    if (gameState.timeBonusDisplay.timer <= 0) gameState.timeBonusDisplay = null;
                }

                if (gameState.isLaserMode) {
                    gameState.laserTimer -= dt;
                    if (gameState.laserTimer <= 0) gameState.isLaserMode = false;
                }

                handleStageTransition(dt * gameState.timeScale);

                // -----------------------------------------------------------
                // [CDSO ìˆ˜ì •êµ¬ì—­] ì…ë ¥ ë° ì´ë™ ë¡œì§ (ì™„ë²½ ì •ë¦¬ë¨)
                // -----------------------------------------------------------

                let leftKey = (gameState.keys['ArrowLeft'] || gameState.keys['a']);
                let rightKey = (gameState.keys['ArrowRight'] || gameState.keys['d']);
                let upKey = (gameState.keys['ArrowUp'] || gameState.keys['w']);
                let downKey = (gameState.keys['ArrowDown'] || gameState.keys['s']);

                if (gameState.isGlitchActive) {
                    let tempX = leftKey; leftKey = rightKey; rightKey = tempX;
                    let tempY = upKey; upKey = downKey; downKey = tempY;
                }

                // 1. PC í‚¤ë³´ë“œ ì´ë™
                if (leftKey && gameState.player.x > 0)
                    gameState.player.x -= gameState.player.speed * dt;
                if (rightKey && gameState.player.x < canvas.width - gameState.player.w)
                    gameState.player.x += gameState.player.speed * dt;

                // ìƒí•˜ ì´ë™ (ìŠ¤í°í‚¬ ë°©ì§€ ì œí•œ ì ìš©)
                const topLimit = canvas.height * 0.2;
                // â˜… í•µì‹¬ ìˆ˜ì •: í•˜ë‹¨ì— 20px ì—¬ìœ  ê³µê°„ì„ ë‘ì–´ ìˆ¨ìŒ ë°©ì§€
                const bottomLimit = canvas.height - gameState.player.h - 10;

                if (upKey && gameState.player.y > topLimit)
                    gameState.player.y -= gameState.player.speed * dt;
                if (downKey && gameState.player.y < bottomLimit)
                    gameState.player.y += gameState.player.speed * dt;

                // 2. ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± ì´ë™ (ì‹ ê·œ ë¡œì§)
                if (gameState.joystick && gameState.joystick.active) {
                    const dir = gameState.isGlitchActive ? -1 : 1;

                    if (gameState.controlMode === 'JOYSTICK') {
                        // [A] ê°€ìƒ ì¡°ì´ìŠ¤í‹± ë°©ì‹ (í˜„ì¬ ë°©ì‹)
                        gameState.player.x += gameState.joystick.vecX * gameState.player.speed * dt * dir;
                        const nextY = gameState.player.y + gameState.joystick.vecY * gameState.player.speed * dt * dir;
                        if (nextY > topLimit && nextY < bottomLimit) {
                            gameState.player.y = nextY;
                        }
                    } else {
                        // [B] ì¢Œìš° í„°ì¹˜ ë°©ì‹ (í´ë˜ì‹)
                        const touchX = gameState.joystick.baseX; // í„°ì¹˜ ì‹œì‘ì  ê¸°ì¤€
                        const deadZone = 10; // ì¤‘ì•™ ê¸°ì¤€ ì¢Œìš° 10pxì”© ì´ 20px
                        if (Math.abs(touchX - canvas.width / 2) < deadZone) return; // ì¤‘ì•™ í„°ì¹˜ ì‹œ ì´ë™ ì¤‘ë‹¨


                        if (touchX < canvas.width / 2) {
                            gameState.player.x -= gameState.player.speed * dt * dir; // ì™¼ìª½ ì´ë™
                        } else {
                            gameState.player.x += gameState.player.speed * dt * dir; // ì˜¤ë¥¸ìª½ ì´ë™
                        }
                        // í´ë˜ì‹ ë°©ì‹ì€ ë³´í†µ ìƒí•˜ ì´ë™ì„ ì œì™¸í•˜ê±°ë‚˜ ì œí•œì ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
                    }
                }


                // 3. ìº í•‘ ë°©ì§€ ë¡œì§
                // í•˜ë“œ ìº¡(Hard Cap) ë°ì´í„° ê²€ì¦ ë¡œì§ ì¶”ê°€
                gameState.player.x = Math.max(0, Math.min(canvas.width - gameState.player.w, gameState.player.x));
                gameState.player.y = Math.max(topLimit, Math.min(bottomLimit, gameState.player.y));


                const edgeThreshold = 60;
                const isCamping = (gameState.player.x < edgeThreshold || gameState.player.x > canvas.width - gameState.player.w - edgeThreshold);
                if (isCamping && !gameState.isTransformed && gameState.currentStage <= 5) {
                    gameState.campingTimer = (gameState.campingTimer || 0) + dt;
                    if (gameState.campingTimer > 5.0) {
                        gameState.enemies.push({
                            x: gameState.player.x, y: -32, w: 20, h: 20, speed: 300, type: 'HOMING', turnRate: 150, time: 0
                        });
                        gameState.campingTimer = 0;
                    }
                } else {
                    gameState.campingTimer = 0;
                }

                // -----------------------------------------------------------
                // [CDSO Design] ì‹ ê·œ HUD ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ ë¡œì§
                // -----------------------------------------------------------
                
                // 1. ìŠ¤í‚¬ íƒ€ì´ë¨¸ ê°ì†Œ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                if (gameState.skillTimer > 0) {
                    gameState.skillTimer -= dt;
                    if (gameState.skillTimer <= 0) gameState.skillMode = 'NORMAL';
                } else {
                    gameState.skillMode = 'NORMAL';
                }

                // 2. HUD ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
                const hudPanel = document.getElementById('hud-panel');
                const hudMode = document.getElementById('hud-mode');
                const hudTimer = document.getElementById('hud-timer');
                const hudProgress = document.getElementById('hud-progress');
                const hudLabel = document.getElementById('hud-label');

                // HUDê°€ HTMLì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸ (ì•ˆì „ì¥ì¹˜)
                if (hudPanel && hudMode) {
                    let currentMode = "NORMAL";
                    let currentTime = 0;
                    let maxTime = 1; // 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
                    let hudColor = "#0ff"; // ê¸°ë³¸ ì²­ë¡ìƒ‰

                    // 3. ìƒíƒœ ìš°ì„ ìˆœìœ„ íŒë³„ ë° ë°ì´í„° ì„¤ì •
                    if (gameState.skillTimer > 0) {
                        // ì•„ì´í…œ ìŠ¤í‚¬ (ë°•ìŠ¤)
                        currentMode = gameState.skillMode;
                        currentTime = gameState.skillTimer;
                        maxTime = (currentMode.includes("ERROR")) ? 5.0 : 10.0; 
                        
                        // ìƒ‰ìƒ ê²°ì •
                        if (currentMode.includes("VOID")) hudColor = "#a0f"; // ë³´ë¼
                        else if (currentMode.includes("REFLECT")) hudColor = "#ff0"; // ë…¸ë‘
                        else if (currentMode.includes("GHOST")) hudColor = "#0f0"; // ë…¹ìƒ‰
                        else if (currentMode.includes("ERROR")) hudColor = "#f00"; // ë¹¨ê°•
                        else hudColor = "#0ff";
                        
                        hudLabel.textContent = "ACTIVE SKILL";

                    } else if (gameState.isTransformed) {
                        // ë³€ì‹  ìƒíƒœ
                        if (gameState.isLaserMode) {
                            currentMode = "LASER CANNON";
                            currentTime = gameState.laserTimer;
                            maxTime = 3.0;
                            hudColor = "#ff0";
                            hudLabel.textContent = "WEAPON SYSTEM";
                        } else if (gameState.isSideMissileActive) {
                            currentMode = "GOLDEN WING";
                            currentTime = 1; maxTime = 1; 
                            hudColor = "#ffd700";
                            hudLabel.textContent = "FLIGHT MODE";
                        } else {
                            currentMode = "GOLDEN WING";
                            currentTime = 1; maxTime = 1;
                            hudColor = "#ffd700";
                            hudLabel.textContent = "FLIGHT MODE";
                        }

                    } else if (gameState.isHomingMode) {
                        // ìœ ë„íƒ„ ëª¨ë“œ
                        currentMode = "HOMING MISSILE";
                        currentTime = gameState.homingTimer;
                        maxTime = 7.0;
                        hudColor = "#c4f";
                        hudLabel.textContent = "WEAPON SYSTEM";

                    } else if (gameState.isLunarMode) {
                        // ë£¨ë‚˜ ëª¨ë“œ
                        currentMode = "LUNAR BIT";
                        currentTime = 1; maxTime = 1;
                        hudColor = "#88f";
                        hudLabel.textContent = "SUPPORT UNIT";

                    } else {
                        // ê¸°ë³¸ ìƒíƒœ
                        currentMode = "SYSTEM NORMAL";
                        currentTime = 0;
                        maxTime = 1;
                        hudColor = "#0ff";
                        hudLabel.textContent = "STANDBY";
                    }

                    // 4. í™”ë©´ ì—…ë°ì´íŠ¸
                    hudMode.textContent = currentMode;
                    hudPanel.style.borderLeftColor = hudColor;
                    
                    if (hudProgress) {
                        hudProgress.style.background = `linear-gradient(90deg, ${hudColor}, #fff)`;
                        hudProgress.style.boxShadow = `0 0 10px ${hudColor}`;
                        
                        // íƒ€ì´ë¨¸ë°” ì›€ì§ì„
                        if (currentTime > 0 && currentMode !== "SYSTEM NORMAL" && currentTime !== 1) {
                            hudTimer.textContent = currentTime.toFixed(1) + "s";
                            const percent = Math.max(0, (currentTime / maxTime) * 100);
                            hudProgress.style.width = percent + "%";
                        } else {
                            hudTimer.textContent = "";
                            // ë¬´í•œ ì§€ì† ìƒíƒœë©´ ê½‰ ì±„ìš°ê³ , ì•„ë‹ˆë©´ ë¹„ì›€
                            hudProgress.style.width = (currentMode === "SYSTEM NORMAL") ? "0%" : "100%"; 
                        }
                    }
                }

                if (gameState.isTransformed && !gameState.isLaserMode && Math.random() < 0.06) {
                    const cx = gameState.player.x + gameState.player.w / 2;
                    const cy = gameState.player.y;
                    [-15, 0, 15].forEach(ox => gameState.bullets.push({ x: cx + ox - 4, y: cy - 10, w: 8, h: 18, speed: 620 }));
                }

                updateDrones(dt);

                if (gameState.isLaserMode) {
                    const cx = gameState.player.x + gameState.player.w / 2;
                    const cy = gameState.player.y;
                    const laserL = cx - 20, laserR = cx + 20;
                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                        const en = gameState.enemies[i];
                        if (en.type !== 'BULLET' && en.type !== 'METEOR' && en.type !== 'SHOCKWAVE' && en.x + en.w > laserL && en.x < laserR && en.y < cy) {
                            gameState.enemies.splice(i, 1);
                            gameState.score += 3;
                        }
                    }
                }

                // ì  ì²˜ë¦¬ ë£¨í”„
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const en = gameState.enemies[i];
                    const currentDt = dt * gameState.timeScale;

                    if (en.type === 'BULLET' || en.type === 'SHOCKWAVE' || en.type === 'METEOR' || en.type === 'ENEMY_BULLET') {
                        en.x += (en.vx || 0) * currentDt;
                        en.y += (en.vy || 0) * currentDt;
                    } else if (en.type === 'MINION') {
                        en.y += en.speed * currentDt;
                        en.time += currentDt * 3;
                        en.x += Math.sin(en.time) * 1.5;
                    } else if (en.type === 'SHOOTER') {
                        en.phase = en.phase || 'ENTER';
                        en.strafeDir = en.strafeDir || 1;
                        en.shotsFired = en.shotsFired || 0;
                        en.setsFired = en.setsFired || 0;
                        en.shootTimer = en.shootTimer || 0;

                        if (en.phase === 'ENTER') {
                            en.y += en.speed * currentDt * 0.8;
                            if (en.y >= 80) { en.phase = 'STRAFE'; en.y = 80; }
                        } else if (en.phase === 'STRAFE') {
                            en.x += en.strafeDir * 200 * currentDt;
                            if (en.x <= 20) en.strafeDir = 1;
                            if (en.x >= canvas.width - en.w - 20) en.strafeDir = -1;
                            en.shootTimer += currentDt;
                            if (en.shootTimer >= 0.1 && en.shotsFired < 5) {
                                gameState.enemies.push({
                                    x: en.x + en.w / 2 - 5, y: en.y + en.h, w: 10, h: 10, speed: 0, type: 'ENEMY_BULLET',
                                    vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                                });
                                en.shotsFired++;
                                en.shootTimer = 0;
                            }
                            if (en.shotsFired >= 5) {
                                en.setsFired++; en.shotsFired = 0; en.shootTimer = -0.5;
                                if (en.setsFired >= 3) en.phase = 'EXIT';
                            }
                        } else if (en.phase === 'EXIT') {
                            en.y += en.speed * currentDt * 2.5;
                        }
                    } else if (en.type === 'BOMBER') {
                        en.y += en.speed * currentDt * 0.6;
                        if (en.y > 200 && !en.exploded) {
                            en.exploded = true;
                            for (let a = 0; a < 6; a++) {
                                const rad = (a * 60) * Math.PI / 180;
                                gameState.enemies.push({
                                    x: en.x + en.w / 2 - 4, y: en.y + en.h / 2 - 4, w: 8, h: 8, speed: 0, type: 'ENEMY_BULLET',
                                    vx: Math.cos(rad) * 200, vy: Math.sin(rad) * 200, amplitude: 0, turnRate: 0, time: 0
                                });
                            }
                            gameState.enemies.splice(i, 1);
                            continue;
                        }
                    } else if (en.type === 'LASER_ENEMY') {
                        if (!en.locked) {
                            en.y += en.speed * currentDt * 0.5;
                            if (en.y > 80) { en.locked = true; en.chargeTimer = 0; }
                        } else {
                            en.chargeTimer = (en.chargeTimer || 0) + currentDt;
                            if (en.chargeTimer > 1.0 && !en.fired) {
                                en.fired = true;
                                for (let ly = en.y + en.h; ly < canvas.height; ly += 30) {
                                    gameState.enemies.push({
                                        x: en.x + en.w / 2 - 8, y: ly, w: 16, h: 25, speed: 0, type: 'ENEMY_BULLET',
                                        vx: 0, vy: 350, amplitude: 0, turnRate: 0, time: 0
                                    });
                                }
                            }
                            if (en.chargeTimer > 1.5) { gameState.enemies.splice(i, 1); continue; }
                        }
                        if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, en)) {
                            gameState.enemies.splice(i, 1);
                            if (gameState.isLunarMode) gameState.isLunarMode = false;
                            else { gameState.lastHitBy = en.type; takeDamage(); }
                            continue;
                        }
                    } else {
                        en.y += en.speed * currentDt;
                        if (en.type === 'ZIGZAG') { en.time += currentDt * 5; en.x += Math.sin(en.time) * en.amplitude; }
                        if (en.type === 'HOMING') { en.x += Math.sign(gameState.player.x + 10 - en.x - 15) * en.turnRate * currentDt; }
                    }

                    en.x = Math.max(-20, Math.min(canvas.width + 20, en.x));

                    if (!gameState.isInvincible && gameState.skillMode !== 'SHIELD' && checkRectCollision(gameState.player, en)) {
                        gameState.enemies.splice(i, 1);
                        if (gameState.isLunarMode) gameState.isLunarMode = false;
                        else { gameState.lastHitBy = en.type; takeDamage(); }
                        continue;
                    }

                    if (en.y > canvas.height + 50 || en.y < -100 || en.x < -80 || en.x > canvas.width + 80) {
                        gameState.enemies.splice(i, 1);
                        if (en.type !== 'BULLET' && en.type !== 'SHOCKWAVE' && en.type !== 'ENEMY_BULLET' && en.type !== 'METEOR') {
                            addScore(getEnemyScore(en.type));
                        }
                    }
                }

                for (let i = gameState.items.length - 1; i >= 0; i--) {
                    const it = gameState.items[i];
                    it.y += it.speed * dt;
                    if (checkItemCollision(gameState.player, it, 20)) {
                        gameState.itemsCollected++;
                        if (it.type === 'DRONE') {
                            if (!gameState.isTransformed) {
                                // ë“œë¡  ìˆ˜ì§‘ ë° ë³€ì‹  ë¡œì§
                                gameState.drones.push({ offsetX: (gameState.drones.length === 0 ? -1 : 1) * 35, shootTimer: 0 });
                                
                                // 3ê°œ ëª¨ìœ¼ë©´ ë³€ì‹ !
                                if (gameState.drones.length >= 3) {
                                    gameState.isTransformed = true; 
                                    gameState.drones = [];
                                    gameState.droneOverload = 0; 
                                    gameState.isSideMissileActive = false;
                                    
                                    // [ìˆ˜ì • ì™„ë£Œ] ì—ëŸ¬ë¥¼ ìœ ë°œí•˜ë˜ í…ìŠ¤íŠ¸ ì½”ë“œ ì‚­ì œí•¨
                                    // (ìƒˆë¡œìš´ HUDê°€ ì•Œì•„ì„œ 'GOLDEN WING'ì´ë¼ê³  ë„ì›Œì¤ë‹ˆë‹¤)
                                    
                                    gameState.skillTimer = 2.0;
                                }
                            } else {
                                // ì´ë¯¸ ë³€ì‹  ìƒíƒœë¼ë©´? -> ì¶”ê°€ ë¬´ì¥ ì¥ì°©
                                gameState.droneOverload = (gameState.droneOverload || 0) + 1;
                                
                                if (gameState.droneOverload === 1) {
                                    gameState.isSideMissileActive = true;
                                    gameState.skillTimer = 2.0; 
                                    addScore(500);
                                } else if (gameState.droneOverload >= 2) {
                                    gameState.ultGauge = 1.0;
                                    gameState.skillTimer = 1.5; 
                                    addScore(500); 
                                    triggerHaptic(50);
                                }
                            }
                        } else if (it.type === 'BLASTER') {
                            if (gameState.isTransformed) { gameState.isLaserMode = true; gameState.laserTimer = 3.0; }
                            else { gameState.isHomingMode = true; gameState.homingTimer = 7.0; }
                        } else if (it.type === 'LUNAR_ITEM') {
                            gameState.isLunarMode = true;
                        } else if (it.type === 'LIFE') {
                            if (gameState.lives < gameState.maxLives) { gameState.lives++; updateLivesUI(); addScore(500); triggerHaptic(100); }
                            else { addScore(300); triggerHaptic(50); }
                        } else if (it.type === 'MYSTERY_BOX') {
                            // ê¸°ì¡´ íš¨ê³¼ ì´ˆê¸°í™”
                            gameState.timeScale = 1.0;
                            gameState.isGlitchActive = false;
                            gameState.isVoidActive = false;
                            gameState.isGhostActive = false; // ê¸°ì¡´ ê³ ìŠ¤íŠ¸ ì´ˆê¸°í™”

                            const chance = Math.random() * 100;
                            let msg = "", color = "#fff";
                            const duration = 10.0;

                            // REFLECT ì œê±° í›„ í™•ë¥  ì¬ë¶„ë°° (ê° 25%)
                            if (chance < 25) {
                                // â–¼â–¼â–¼ [ìˆ˜ì •] ì—¬ê¸°ë¥¼ ì›í•˜ëŠ” ì‹œê°„(ì´ˆ)ìœ¼ë¡œ ë°”ê¾¸ì„¸ìš”! â–¼â–¼â–¼
                                gameState.slowTimer = 5.0; // ì˜ˆ: 5ì´ˆë¡œ ì¤„ì´ê¸° (ê¸°ì¡´ duration ëŒ€ì‹  ìˆ«ì ì…ë ¥)
                                gameState.timeScale = 0.2;
                                msg = "â³ TIME SLOW"; color = "#0ff";
                            }
                            else if (chance < 50) {
                                gameState.isVoidActive = true;
                                gameState.voidTimer = duration;
                                gameState.voidRadius = 0;
                                msg = "âš« VOID HOLE"; color = "#a0f";
                            }
                            else if (chance < 75) {
                                gameState.isGhostActive = true;
                                gameState.ghostTimer = duration;
                                gameState.ghostHistory = [];
                                msg = "ğŸ‘» GHOST"; color = "#0f0";
                            }
                            else {
                                gameState.isGlitchActive = true;
                                gameState.glitchTimer = 5.0;
                                msg = "ğŸ’€ ERROR ğŸ’€"; color = "#f00";
                            }

                            // const skillDisplay = document.getElementById('skill-display');
                            // if (skillDisplay) skillDisplay.style.color = color;

                            gameState.skillMode = msg;
                            gameState.skillTimer = (msg.includes("ERROR")) ? 5.0 : duration;

                            triggerHaptic(100);
                            addScore(500);
                        } else {
                            // ë‹¤ë¥¸ ì•„ì´í…œ íƒ€ì… (ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì…)
                            gameState.skillMode = it.type; gameState.skillTimer = 5.0;
                        }
                        gameState.items.splice(i, 1);
                    }
                    if (it.y > canvas.height) gameState.items.splice(i, 1);
                }

                if (gameState.isLunarMode) {
                    gameState.lunarAngle += dt * 550;
                    const rad = gameState.lunarAngle * Math.PI / 180;
                    const guardian = { x: gameState.player.x + gameState.player.w / 2 + Math.cos(rad) * 40 - 10, y: gameState.player.y + gameState.player.h / 2 - 15 + Math.sin(rad) * 40 - 10, w: 20, h: 20 };
                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                        if (checkRectCollision(guardian, gameState.enemies[i])) {
                            gameState.enemies.splice(i, 1); addScore(30); break;
                        }
                    }
                }

                for (let bi = gameState.bullets.length - 1; bi >= 0; bi--) {
                    const b = gameState.bullets[bi];

                    // â”€â”€â”€ íƒ„í™˜ ì´ë™ (íƒ€ì…ë³„ ë¶„ê¸°) â”€â”€â”€
                    if (b.type === 'DRONE_MISSILE') {
                        b.y -= b.speed * dt;
                        if (b.life) { b.life -= dt; if (b.life <= 0) { gameState.bullets.splice(bi, 1); continue; } }
                    } else if (b.isLunar) {
                        b.x += (b.vx || 0) * dt; b.y += (b.vy || 0) * dt;
                    // â–¼â–¼â–¼ [ìˆ˜ì • ì½”ë“œ: ê´€ì„± ìœ ì§€ ë¡œì§ ì ìš©] â–¼â–¼â–¼
                    } else if (b.isHoming) {
                        // 1. íƒ€ê²Ÿ ìƒì¡´ ì—¬ë¶€ í™•ì¸
                        const targetAlive = b.target && (gameState.enemies.includes(b.target) || b.target === gameState.boss) && (b.target.hp === undefined || b.target.hp > 0);

                        // 2. íƒ€ê²Ÿì´ ì‚´ì•„ìˆì„ ë•Œë§Œ ë°©í–¥(Vector)ì„ êº¾ìŒ
                        if (targetAlive) {
                            const tx = b.target.x + b.target.w / 2, ty = b.target.y + b.target.h / 2;
                            const bx = b.x + b.w / 2, by = b.y + b.h / 2;
                            const dx = tx - bx, dy = ty - by, dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            const turn = (b.turnRate || 8.0) * dt;

                            // í˜„ì¬ ì†ë„ ë²¡í„° ê³„ì‚° (ì—†ìœ¼ë©´ ì´ˆê¸°í™”)
                            const currentSpeed = Math.sqrt((b.vx||0)**2 + (b.vy||0)**2) || b.speed;
                            
                            // í˜„ì¬ ë°©í–¥ vs íƒ€ê²Ÿ ë°©í–¥ ë²¡í„° ë³´ê°„
                            const currentDirX = (b.vx || 0) / currentSpeed || 0;
                            const currentDirY = (b.vy || -1) / currentSpeed || -1; // ê¸°ë³¸ê°’ ìœ„ìª½
                            const targetDirX = dx / dist;
                            const targetDirY = dy / dist;

                            // íšŒì „ìœ¨ë§Œí¼ ë°©í–¥ ì „í™˜
                            const newDirX = currentDirX + (targetDirX - currentDirX) * turn;
                            const newDirY = currentDirY + (targetDirY - currentDirY) * turn;
                            const newLen = Math.sqrt(newDirX * newDirX + newDirY * newDirY) || 1;

                            // ìƒˆë¡œìš´ ì†ë„ ë²¡í„° ì ìš©
                            b.vx = (newDirX / newLen) * b.speed;
                            b.vy = (newDirY / newLen) * b.speed;
                        } 
                        
                        // 3. ê³µí†µ ì´ë™ (ê´€ì„± ë¹„í–‰) - íƒ€ê²Ÿì´ ì—†ì–´ë„ ë§ˆì§€ë§‰ ë²¡í„° ìœ ì§€
                        if (b.vx === undefined) b.vx = 0;
                        if (b.vy === undefined) b.vy = -b.speed;

                        b.x += b.vx * dt;
                        b.y += b.vy * dt;

                        // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì‚­ì œ (ë©”ëª¨ë¦¬ ê´€ë¦¬)
                        if (b.y < -20 || b.y > canvas.height + 20 || b.x < -20 || b.x > canvas.width + 20) {
                            gameState.bullets.splice(bi, 1); continue;
                        }

                        // ì¶©ëŒ ì²˜ë¦¬ ë¡œì§ ì—°ê²°
                        for (let ei = gameState.enemies.length - 1; ei >= 0; ei--) {
                            const en = gameState.enemies[ei];
                            if (en.type === 'SHOCKWAVE' || en.type === 'METEOR') continue;
                            if (checkRectCollision(b, en)) {
                                gameState.enemies.splice(ei, 1);
                                const unitScore = getEnemyScore(en.type);
                                if (unitScore > 0) addScore(unitScore * 10);

                                if (!b.isPenetrating) {
                                    gameState.bullets.splice(bi, 1);
                                    break;
                                }
                            }
                        }
                    // â–²â–²â–² [ìˆ˜ì • ì™„ë£Œ] â–²â–²â–²
                    } else {
                        // â˜… ì¼ë°˜ íƒ„í™˜ ê¸°ë³¸ ì´ë™ (ì§ì§„ ìƒìŠ¹)
                        b.y -= b.speed * dt;
                    }

                    // â”€â”€â”€ í™”ë©´ ë°– ì´íƒˆ ì²´í¬ (ëª¨ë“  íƒ„í™˜ ê³µí†µ) â”€â”€â”€
                    if (b.y < -20 || b.y > canvas.height + 20 || b.x < -20 || b.x > canvas.width + 20) {
                        gameState.bullets.splice(bi, 1); continue;
                    }

                    // â”€â”€â”€ ì -íƒ„í™˜ ì¶©ëŒ íŒì • (ëª¨ë“  íƒ„í™˜ ê³µí†µ) â”€â”€â”€
                    for (let ei = gameState.enemies.length - 1; ei >= 0; ei--) {
                        const en = gameState.enemies[ei];
                        if (en.type === 'SHOCKWAVE' || en.type === 'METEOR') continue;
                        if (checkRectCollision(b, en)) {
                            gameState.enemies.splice(ei, 1);
                            const unitScore = getEnemyScore(en.type);
                            if (unitScore > 0) addScore(unitScore * 10);

                            if (!b.isPenetrating) {
                                gameState.bullets.splice(bi, 1);
                                break;
                            }
                        }
                    }
                }

                let targetProgress = 0;
                if (lvl.isBoss && gameState.bossPhase === 'BOSS' && gameState.boss) targetProgress = 1 - (gameState.boss.hp / gameState.boss.maxHp);
                else if (gameState.survivalMode) targetProgress = 1 - (gameState.enemies.length / Math.max(1, gameState.survivalStartCount));
                else targetProgress = (30 - gameState.stageTimer) / 30;
                gameState.progressDisplay += (targetProgress - gameState.progressDisplay) * dt * 5;

                let stageText = '';
                if (gameState.currentStage >= 11) stageText = `STAGE âˆ | OVERDRIVE x${gameState.infiniteDifficulty.toFixed(2)}`;
                else {
                    // ë³´ìŠ¤ì „ì¼ ë•Œë§Œ 'BOSS!' í‘œì‹œ ìœ ì§€
                    let stageDisplay = lvl.isBoss && gameState.bossPhase === 'BOSS' ? 'BOSS!' : '';
                    
                    stageText = `STAGE ${gameState.currentStage}${stageDisplay ? ' | ' + stageDisplay : ''}`;
                }
                document.getElementById('stage-info').textContent = stageText;

                // [CDSO Sync] ì ìˆ˜ DOM ì—…ë°ì´íŠ¸: update()ì˜ ìµœì¢… ë‹¨ê³„ì—ì„œ ì‹¤í–‰ (1í”„ë ˆì„ ì˜¤ì°¨ ì œê±°)
                document.getElementById('current-score').textContent = Math.round(gameState.score);

                // [CDSO Decoupling] ë°°ê²½ ê·¸ë¦¬ë“œ ì˜¤í”„ì…‹ ì—…ë°ì´íŠ¸ (drawì—ì„œ ë¶„ë¦¬)
                gridOffset = (gridOffset + dt * gameState.timeScale * 100) % 50;

                // [CDSO FIX] ë§¤ í”„ë ˆì„ HUD ê°±ì‹  í˜¸ì¶œ (ì´ê²Œ ì—†ìœ¼ë©´ ì•ˆ ì›€ì§ì…ë‹ˆë‹¤!)
                updateHUD();


            } // â† update(dt) í•¨ìˆ˜ ì¢…ë£Œ




            function checkRectCollision(r1, r2) {
                return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
            }

            // [CDSO Logic] ì•„ì´í…œ ì „ìš© íŒì •: ê¸°ì¡´ íŒì •ë³´ë‹¤ ì‚¬ë°©ìœ¼ë¡œ 15px ë” ë„“ê²Œ ì¸ì •
            function checkItemCollision(player, item, margin = 15) {
                return player.x < item.x + item.w + margin &&
                    player.x + player.w > item.x - margin &&
                    player.y < item.y + item.h + margin &&
                    player.y + player.h > item.y - margin;
            }



            function drawProgressBar() {
                const lvl = levels[gameState.currentStage - 1];
                const barWidth = canvas.width * 0.8;
                const barHeight = 8;  // ë” ë‘ê»ê²Œ
                const barX = (canvas.width - barWidth) / 2;
                const barY = canvas.height - 16;

                // ë°°ê²½
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // í•„ì‚´ê¸° ê²Œì´ì§€ í‘œì‹œ
                const ultProgress = Math.min(gameState.ultGauge, 1);

                if (ultProgress >= 1) {
                    // ì™„ì¶© ì‹œ ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜ + ê¹œë¹¡ì„
                    const grad = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    const offset = (Date.now() / 20) % 360;
                    for (let i = 0; i <= 6; i++) {
                        const hue = (offset + i * 60) % 360;
                        grad.addColorStop(i / 6, `hsl(${hue}, 100%, 60%)`);
                    }
                    const pulse = 0.7 + Math.sin(Date.now() / 100) * 0.3;
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = '#fff';
                    ctx.fillStyle = grad;
                } else {
                    // ì¶©ì „ ì¤‘: ë³´ë¼ìƒ‰ ê²Œì´ì§€
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#a0f';
                    ctx.fillStyle = '#c4f';
                }

                ctx.fillRect(barX, barY, barWidth * ultProgress, barHeight);

                // ULT í…ìŠ¤íŠ¸ í‘œì‹œ
                ctx.shadowBlur = 0;
                ctx.fillStyle = ultProgress >= 1 ? '#fff' : '#aaa';
                ctx.font = 'bold 10px Orbitron';
                ctx.textAlign = 'center';

                // â–¼â–¼â–¼ [CDSO Patch: ì»¨íŠ¸ë¡¤ ëª¨ë“œë³„ í…ìŠ¤íŠ¸ ìë™ ë³€ê²½] â–¼â–¼â–¼
                let actionText = 'ğŸŒˆ PRESS SPACE ğŸŒˆ'; // ê¸°ë³¸ê°’ (PC)

                if (typeof controlMode !== 'undefined') {
                    if (controlMode === 'TRACKING') {
                        // í„°ì¹˜ ì¶”ì  ëª¨ë“œ -> ë”ë¸” íƒ­ìœ¼ë¡œ ë°œë™
                        actionText = 'ğŸŒˆ DOUBLE TAP ğŸŒˆ';
                    } else if (controlMode === 'BUTTON') {
                        // ê°€ìƒ ë²„íŠ¼ ëª¨ë“œ -> í™”ë©´ì˜ ìŠ¤í‚¬ ë²„íŠ¼ ëˆ„ë¥´ê¸°
                        actionText = 'ğŸŒˆ PRESS BUTTON ğŸŒˆ';
                    }
                }

                ctx.fillText(ultProgress >= 1 ? actionText : `ULT: ${Math.floor(ultProgress * 100)}%`, canvas.width / 2, barY - 4);

                ctx.shadowBlur = 0;
            }

            function drawGiftBox(it) {
                const x = it.x, y = it.y, w = it.w, h = it.h;

                // â–¼â–¼â–¼ [CDSO Patch: ë¯¸ìŠ¤í„°ë¦¬ ë°•ìŠ¤ ë””ìì¸ - ê³¨ë“œ ì—ë””ì…˜] â–¼â–¼â–¼
                if (it.type === 'MYSTERY_BOX') {
                    const pulse = 1 + Math.sin(Date.now() / 100) * 0.1;

                    // 1. ë„¤ì˜¨ ê´‘ì› (Glow): ìˆœê¸ˆìƒ‰
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#FFD700';

                    // 2. ìƒì ë³¸ì²´ (ë©”íƒˆë¦­ ê³¨ë“œ ê·¸ë¼ë°ì´ì…˜)
                    const grad = ctx.createLinearGradient(x, y, x, y + h);
                    grad.addColorStop(0, '#FFD700');  // ìƒë‹¨: ë°ì€ ê³¨ë“œ
                    grad.addColorStop(1, '#B8860B');  // í•˜ë‹¨: ë‹¤í¬ ê³¨ë“œ (ì…ì²´ê°)
                    ctx.fillStyle = grad;
                    ctx.fillRect(x, y, w, h);

                    // 3. í…Œë‘ë¦¬ (ì•„ì£¼ ë°ì€ ë ˆëª¬ìƒ‰)
                    ctx.strokeStyle = '#FFFACD';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);

                    // 4. ë¬¼ìŒí‘œ (?)
                    // ê³¨ë“œ ë°°ê²½ ìœ„ì—ëŠ” í°ìƒ‰ ê¸€ì”¨ì— ì–´ë‘ìš´ ê·¸ë¦¼ìë¥¼ ì¤˜ì•¼ ê°€ë…ì„±ì´ ì¢‹ìŠµë‹ˆë‹¤.
                    ctx.shadowBlur = 0; // í…ìŠ¤íŠ¸ ìì²´ ë¸”ëŸ¬ ì œê±°
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 20px Orbitron';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

                    // ë¬¼ìŒí‘œê°€ ë‘ê·¼ê±°ë¦¬ëŠ” ì—°ì¶œ
                    ctx.save();
                    ctx.translate(x + w / 2, y + h / 2);
                    ctx.scale(pulse, pulse);

                    // í…ìŠ¤íŠ¸ ì™¸ê³½ì„  (ê°€ë…ì„± í™•ë³´ìš©)
                    ctx.strokeStyle = '#8B4500'; // ì§„í•œ ê°ˆìƒ‰ í…Œë‘ë¦¬
                    ctx.lineWidth = 1;
                    ctx.strokeText('?', 0, 1);
                    ctx.fillText('?', 0, 1);

                    ctx.restore();

                    ctx.shadowBlur = 0;
                    return;
                }



                // [CDSO ìˆ˜ì •] LIFE ì•„ì´í…œ: í•˜íŠ¸ ë Œë”ë§
                if (it.type === 'LIFE') {
                    const cx = x + w / 2;
                    const cy = y + h / 2;
                    const pulse = 1 + Math.sin(Date.now() / 150) * 0.15;

                    ctx.save();
                    ctx.translate(cx, cy);
                    // [CDSO ìˆ˜ì •] í•˜íŠ¸ í¬ê¸° 2.3ë°° í™•ëŒ€ (pulse * 2.5)
                    ctx.scale(pulse * 2.3, pulse * 2.3);

                    ctx.shadowBlur = 25; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.moveTo(0, -5);
                    ctx.bezierCurveTo(5, -12, 12, -5, 0, 8);
                    ctx.bezierCurveTo(-12, -5, -5, -12, 0, -5);
                    ctx.fill();

                    ctx.shadowBlur = 0; ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(-3, -3, 2, 0, Math.PI * 2); ctx.fill();

                    ctx.restore();
                    return;
                }

                // [ë³µêµ¬ë¨] LUNAR_ITEM ì²´í¬ ì¡°ê±´ë¬¸ì´ ë¹ ì ¸ìˆì—ˆìŒ!
                if (it.type === 'LUNAR_ITEM') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(x + w / 2, y + h / 2, 14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(x + w / 2 + 6, y + h / 2 - 4, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    return;
                }

                // ì¼ë°˜ ì•„ì´í…œ ë°•ìŠ¤
                const boxColor = it.type === 'DRONE' ? '#0ff' : (it.type === 'SHIELD' ? '#0f0' : '#f0f');
                ctx.shadowBlur = 12; ctx.shadowColor = boxColor;
                ctx.fillStyle = boxColor; ctx.fillRect(x + 2, y + 6, w - 4, h - 6);
                ctx.fillStyle = '#fff'; ctx.fillRect(x + w / 2 - 2, y + 6, 4, h - 6); ctx.fillRect(x + 2, y + h / 2 + 2, w - 4, 4);
                ctx.fillStyle = boxColor; ctx.fillRect(x, y + 4, w, 6);
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(x + w / 2 - 5, y + 4, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + w / 2 + 5, y + 4, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + w / 2, y + 2, 3, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
            }



            function drawAlien(en, stage) {
                // [ì•ˆì „ ì¥ì¹˜] ìƒíƒœ ì €ì¥ (í•¨ìˆ˜ ì‹œì‘)
                ctx.save();

                const cx = en.x + en.w / 2, cy = en.y + en.h / 2;
                const isCold = stage <= 5;

                // 1. ENEMY_BULLET (íšŒì „í•˜ëŠ” í”Œë¼ì¦ˆë§ˆ)
                if (en.type === 'ENEMY_BULLET') {
                    ctx.translate(cx, cy);
                    ctx.rotate(Date.now() / 150);

                    ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.lineTo(-4, 0); ctx.fill();
                    
                    ctx.strokeStyle = '#f44'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 0); ctx.lineTo(0, 8); ctx.lineTo(-6, 0); ctx.closePath(); ctx.stroke();
                    
                    ctx.restore(); return; // [í•„ìˆ˜] ë³µêµ¬ í›„ ì¢…ë£Œ
                }

                // 2. SHOOTER (í—¥ìŠ¤ ìºë…¼)
                if (en.type === 'SHOOTER') {
                    ctx.translate(cx, cy);
                    ctx.shadowBlur = 15; ctx.shadowColor = '#d00';
                    const size = en.w / 2;

                    // ìœ¡ê°í˜• ë³¸ì²´
                    ctx.fillStyle = '#c22';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const hx = Math.cos(angle) * size; 
                        const hy = Math.sin(angle) * size;
                        i === 0 ? ctx.moveTo(hx, hy) : ctx.lineTo(hx, hy);
                    }
                    ctx.closePath(); ctx.fill();

                    // ì¤‘ì•™ í¬ì‹  & ì½”ì–´
                    ctx.fillStyle = '#500'; ctx.fillRect(-6, -5, 12, 15);
                    ctx.fillStyle = en.shotsFired > 0 ? '#ff0' : '#f00';
                    ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();

                    // ì¥ê°‘ ë””í…Œì¼
                    ctx.strokeStyle = '#f88'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(-size / 2, -size / 1.5); ctx.lineTo(size / 2, -size / 1.5); ctx.stroke();

                    ctx.restore(); return;
                }

                // 3. BOMBER (í”Œë¼ì¦ˆë§ˆ ê¸°ë¢°)
                if (en.type === 'BOMBER') {
                    const pulse = 1 + Math.sin(Date.now() / 80) * 0.2;
                    ctx.shadowBlur = 30; ctx.shadowColor = '#f80';
                    ctx.translate(cx, cy);
                    ctx.rotate(Date.now() / 800);

                    // ê°€ì‹œ
                    ctx.fillStyle = '#f60';
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 4) * i;
                        ctx.save(); ctx.rotate(angle);
                        const sx = Math.cos(angle) * (en.w / 1.5 * pulse); // ë§¥ë™ ë³´ì •
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(5, -(en.w / 1.4 * pulse)); ctx.lineTo(-5, -(en.w / 1.4 * pulse)); 
                        ctx.strokeStyle = '#f80'; ctx.lineWidth = 3; ctx.stroke();
                        ctx.restore();
                    }
                    // í•µ
                    ctx.fillStyle = '#fa0'; ctx.beginPath(); ctx.arc(0, 0, en.w / 2.5, 0, Math.PI * 2); ctx.fill();
                    // ì ë©¸
                    if (Math.floor(Date.now() / 100) % 2 === 0) { ctx.fillStyle = '#510'; ctx.beginPath(); ctx.arc(0, 0, en.w / 5, 0, Math.PI * 2); ctx.fill(); }

                    ctx.restore(); return;
                }

                // 4. LASER_ENEMY (ì˜¤ì§•ì–´) - [ì˜¤ë¥˜ ìˆ˜ì •ë¨] restore ì¶”ê°€!
                if (en.type === 'LASER_ENEMY') {
                    ctx.shadowBlur = 15; ctx.shadowColor = '#a0f'; ctx.fillStyle = '#c4f';
                    const squidHeadR = en.w / 2; const legLen = en.h * 0.5;

                    // ë¨¸ë¦¬
                    ctx.beginPath(); ctx.arc(cx, en.y + squidHeadR, squidHeadR, Math.PI, 0); 
                    ctx.lineTo(en.x + en.w, en.y + en.h - legLen); ctx.lineTo(en.x, en.y + en.h - legLen); ctx.closePath(); ctx.fill();

                    // ë‹¤ë¦¬
                    ctx.strokeStyle = '#c4f'; ctx.lineWidth = 3; ctx.lineCap = 'round';
                    const wiggle = Math.sin(Date.now() / 100) * 3;
                    for (let i = 0; i < 4; i++) {
                        const legX = en.x + (en.w / 4) * i + (en.w / 8); const legStartY = en.y + en.h - legLen;
                        ctx.beginPath(); ctx.moveTo(legX, legStartY); 
                        ctx.bezierCurveTo(legX + wiggle, legStartY + legLen / 2, legX - wiggle, legStartY + legLen, legX, legStartY + legLen); ctx.stroke();
                    }
                    // ëˆˆ
                    ctx.fillStyle = '#fff'; const eyeY = en.y + squidHeadR + 2;
                    ctx.beginPath(); ctx.arc(cx - 5, eyeY, 3, 0, Math.PI * 2); ctx.fill(); 
                    ctx.beginPath(); ctx.arc(cx + 5, eyeY, 3, 0, Math.PI * 2); ctx.fill();

                    // ì°¨ì§• ì´í™íŠ¸
                    if (en.locked && !en.fired) {
                        const chargeProgress = Math.min((en.chargeTimer || 0) / 1.0, 1);
                        ctx.fillStyle = '#f0f'; ctx.fillRect(en.x, en.y + en.h, en.w * chargeProgress, 3);
                        ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(cx - 5, eyeY, 2, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(cx + 5, eyeY, 2, 0, Math.PI * 2); ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore(); return; // [í•„ìˆ˜] ë³µêµ¬ í›„ ì¢…ë£Œ
                }

                // 5. NORMAL (ë°ì´í„° í¬ë¦¬ìŠ¤íƒˆ)
                if (en.type === 'NORMAL') {
                    ctx.shadowBlur = 15; ctx.shadowColor = en.color || '#0ff';
                    const coreSize = en.w / 4;
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(cx, en.y + en.h / 2 - coreSize); ctx.lineTo(cx + coreSize, en.y + en.h / 2); ctx.lineTo(cx, en.y + en.h / 2 + coreSize); ctx.lineTo(cx - coreSize, en.y + en.h / 2); ctx.fill();
                    
                    ctx.strokeStyle = en.color || '#0ff'; ctx.lineWidth = 2; 
                    const angleOffset = Date.now() / 1000;
                    for (let i = 0; i < 4; i++) {
                        const angle = angleOffset + (Math.PI / 2 * i); const dist = en.w / 2.2; 
                        const px = cx + Math.cos(angle) * dist; const py = cy + Math.sin(angle) * dist;
                        ctx.beginPath(); ctx.moveTo(px, py - 5); ctx.lineTo(px + 5, py); ctx.lineTo(px, py + 5); ctx.lineTo(px - 5, py); ctx.closePath(); ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                    ctx.restore(); return;
                }

                // 6. ZIGZAG (ìŠ¤íŒŒí¬ ìœ™)
                if (en.type === 'ZIGZAG') {
                    ctx.shadowBlur = 20; ctx.shadowColor = en.color || '#ff0'; ctx.strokeStyle = en.color || '#ff0'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.beginPath(); ctx.moveTo(en.x, en.y); ctx.lineTo(cx, en.y + en.h); ctx.lineTo(en.x + en.w, en.y); ctx.stroke();
                    
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, en.y + en.h * 0.3, 4, 0, Math.PI * 2); ctx.fill();
                    
                    ctx.lineWidth = 1; ctx.globalAlpha = 0.6; const glitchY = Math.sin(Date.now() / 50) * 3;
                    ctx.beginPath(); ctx.moveTo(en.x + 5, en.y - 10 + glitchY); ctx.lineTo(cx, en.y + en.h - 10 + glitchY); ctx.lineTo(en.x + en.w - 5, en.y - 10 + glitchY); ctx.stroke();
                    ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
                    ctx.restore(); return;
                }

                // 7. HOMING (UFO)
                if (en.type === 'HOMING') {
                    const spin = Date.now() / 150; const hover = Math.sin(Date.now() / 300) * 3;
                    ctx.translate(cx, cy + hover);
                    
                    // ì—”ì§„ ê¸€ë¡œìš°
                    ctx.shadowBlur = 20; ctx.shadowColor = '#00ffcc'; ctx.fillStyle = 'rgba(0, 255, 204, 0.3)'; 
                    ctx.beginPath(); ctx.ellipse(0, 5, en.w / 2, en.h / 4, 0, 0, Math.PI * 2); ctx.fill();
                    
                    // ë³¸ì²´
                    ctx.shadowBlur = 10; ctx.fillStyle = '#2F4F4F'; 
                    ctx.beginPath(); ctx.ellipse(0, 0, en.w / 2, en.h / 3.5, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 1.5; ctx.stroke();
                    
                    // ì½•í•
                    ctx.fillStyle = '#00ffcc'; ctx.shadowBlur = 15; 
                    ctx.beginPath(); ctx.arc(0, -3, en.w / 5, Math.PI, 0); ctx.bezierCurveTo(en.w / 5, 0, -en.w / 5, 0, -en.w / 5, -3); ctx.fill();
                    
                    // ë¼ì´íŠ¸
                    const lightCount = 4; const radius = en.w / 2.5;
                    for (let i = 0; i < lightCount; i++) {
                        const angle = spin + (i * (Math.PI * 2 / lightCount));
                        const lx = Math.cos(angle) * radius; const ly = Math.sin(angle) * (radius * 0.4); 
                        const isBack = Math.sin(angle) < 0;
                        ctx.fillStyle = isBack ? '#005544' : '#ccffff'; ctx.beginPath(); ctx.arc(lx, ly, isBack ? 1.5 : 2.5, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore(); return;
                }

                // 8. MINION (ë³´ìŠ¤ ì«„ëª¹)
                if (en.type === 'MINION') {
                    ctx.shadowBlur = 12; ctx.shadowColor = '#f0f'; ctx.fillStyle = '#f0f';
                    ctx.fillRect(en.x + 4, en.y + 4, en.w - 8, en.h - 8);
                    ctx.restore(); return; // [í•„ìˆ˜] ë³µêµ¬ í›„ ì¢…ë£Œ
                }

                // [ì•ˆì „ ì¥ì¹˜] ìœ„ì—ì„œ ì²˜ë¦¬ë˜ì§€ ì•Šì€ íƒ€ì…ì´ ìˆì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ë³µêµ¬
                ctx.restore(); 
            }

            function drawLunarBoss(boss) {
                const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;

                // [ì‹ ê·œ] ì˜¤ë¹„íƒˆ ë¹„íŠ¸ (ìœ„ì„±) ê·¸ë¦¬ê¸°
                const orbitAngle = boss.orbitAngle || 0;
                
                // ê¶¤ë„ ë¼ì¸ (ì„ íƒ ì‚¬í•­: ê¶¤ì ì´ íë¦¿í•˜ê²Œ ë³´ì„)
                ctx.beginPath();
                ctx.arc(cx, cy, 90, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();

                for(let i=0; i<2; i++) {
                    const angle = orbitAngle + (i * Math.PI);
                    const satX = cx + Math.cos(angle) * 90;
                    const satY = cy + Math.sin(angle) * 90;
                    
                    // ìœ„ì„± ë³¸ì²´ (ì‘ê³  ë¹›ë‚˜ëŠ” êµ¬ì²´)
                    ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
                    ctx.fillStyle = '#ccf';
                    ctx.beginPath(); ctx.arc(satX, satY, 8, 0, Math.PI*2); ctx.fill();
                    
                    // ìœ„ì„±ê³¼ ë³´ìŠ¤ë¥¼ ì´ì–´ì£¼ëŠ” ì—ë„ˆì§€ ë¼ì¸
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = 'rgba(200, 200, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(satX, satY); ctx.stroke();
                }


                ctx.shadowBlur = 40; ctx.shadowColor = '#88f';
                ctx.fillStyle = '#aaf';
                ctx.beginPath(); ctx.arc(cx, cy, 45, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#669';
                [[20, -12, 9], [35, 15, 7], [-15, 8, 8], [-25, -5, 5]].forEach(([ox, oy, r]) => {
                    ctx.beginPath(); ctx.arc(cx + ox, cy + oy, r, 0, Math.PI * 2); ctx.fill();
                });
                ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
                ctx.fillStyle = '#4af'; ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
                ctx.fillText('LUNAR', cx, boss.y - 7);
            }

            function drawSunBoss(boss) {
                const cx = boss.x + boss.w / 2, cy = boss.y + boss.h / 2;
                ctx.shadowBlur = boss.isSupernova ? 80 : 60;
                ctx.shadowColor = boss.isSupernova ? '#f0f' : '#f80';
                const grad = ctx.createRadialGradient(cx, cy, 15, cx, cy, 50);
                if (boss.isSupernova) {
                    grad.addColorStop(0, '#fff'); grad.addColorStop(0.5, '#f0f'); grad.addColorStop(1, '#80f');
                } else {
                    grad.addColorStop(0, '#ff0'); grad.addColorStop(0.6, '#f80'); grad.addColorStop(1, '#f00');
                }
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(cx, cy, 48, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = boss.isSupernova ? '#f8f' : '#fa0'; ctx.lineWidth = 4;
                for (let i = 0; i < 12; i++) {
                    const a = (i * 30 + Date.now() / 25) * Math.PI / 180;
                    ctx.beginPath(); ctx.moveTo(cx + Math.cos(a) * 48, cy + Math.sin(a) * 48);
                    ctx.lineTo(cx + Math.cos(a) * 72, cy + Math.sin(a) * 72); ctx.stroke();
                }
                ctx.fillStyle = '#333'; ctx.fillRect(boss.x, boss.y - 20, boss.w, 12);
                ctx.fillStyle = boss.isSupernova ? '#f0f' : '#f40';
                ctx.fillRect(boss.x, boss.y - 20, boss.w * (boss.hp / boss.maxHp), 12);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Orbitron'; ctx.textAlign = 'center';
                ctx.fillText(boss.isSupernova ? 'SUPERNOVA' : 'SUN', cx, boss.y - 7);
            }

            function drawLaser() {
                if (!gameState.isLaserMode) return;
                const cx = gameState.player.x + gameState.player.w / 2;
                const laserWidth = 40;

                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ff0';
                const grad = ctx.createLinearGradient(cx - laserWidth / 2, 0, cx + laserWidth / 2, 0);
                grad.addColorStop(0, 'rgba(255,255,0,0.3)');
                grad.addColorStop(0.5, 'rgba(255,255,0,0.9)');
                grad.addColorStop(1, 'rgba(255,255,0,0.3)');
                ctx.fillStyle = grad;
                ctx.fillRect(cx - laserWidth / 2, 0, laserWidth, gameState.player.y);

                ctx.fillStyle = '#fff';
                ctx.fillRect(cx - 5, 0, 10, gameState.player.y);
                ctx.shadowBlur = 0;
            }


            // â–¼â–¼â–¼ [CDSO Patch: ì‚¬ì´ë²„ ê·¸ë¦¬ë“œ ë°°ê²½ í•¨ìˆ˜ ì •ì˜] â–¼â–¼â–¼
            function drawBackground(dt) {
                // 1. ì‹¬ì—°ì˜ ë°°ê²½ìƒ‰ (Stage 11ì€ ì™„ì „ ê²€ì •, ê·¸ ì™¸ì—” ë”¥ ë‹¤í¬ ë„¤ì´ë¹„)
                if (gameState.currentStage >= 11) {
                    ctx.fillStyle = '#050505';
                } else {
                    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGrad.addColorStop(0, '#000510');
                    bgGrad.addColorStop(1, '#001020');
                    ctx.fillStyle = bgGrad;
                }
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 2. ì›€ì§ì´ëŠ” ê·¸ë¦¬ë“œ (Perspective Effect)
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)'; // ì•„ì£¼ ì—°í•œ ì²­ë¡ìƒ‰

                // gridOffsetì€ update()ì—ì„œ ê°±ì‹ ë¨ (Physics/Render Decoupling)

                ctx.beginPath();

                // ê°€ë¡œì„  (ì•„ë˜ë¡œ íë¦„)
                for (let y = gridOffset; y < canvas.height; y += 50) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                }

                // ì„¸ë¡œì„  (ì›ê·¼ê°)
                for (let x = 0; x <= canvas.width; x += 50) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                }

                ctx.stroke();

                // 3. ë¨¼ì§€ ì…ì (ì†ë„ê° ê°•í™”)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                const time = Date.now() / 1000;
                for (let i = 0; i < 20; i++) {
                    const px = (Math.sin(i * 132 + time) * 0.5 + 0.5) * canvas.width;
                    const py = (Math.cos(i * 54 + time * 2) * 0.5 + 0.5) * canvas.height;
                    ctx.fillRect(px, py, 2, 2);
                }
            }


            function draw(dt) {
                // [CDSO Absolute Fix] ìº”ë²„ìŠ¤ ì¢Œí‘œê³„ ê°•ì œ ì´ˆê¸°í™” (í™”ë©´ ê¸°ìš¸ì–´ì§ ì˜êµ¬ ë°©ì§€)
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                const lvl = levels[gameState.currentStage - 1];
                // ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
                // ctx.fillRect(0, 0, canvas.width, canvas.height);

                // [CDSO Patch] ë°°ê²½ ì†ë„ì—ë„ ì‹œê°„ ì™œê³¡ ì ìš© (dtê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ 0.016)
                const currentDt = (dt || 0.016) * gameState.timeScale;
                drawBackground(currentDt);

                // stageClearing ì¤‘ì—ë„ ì•„ë˜ ë Œë”ë§ ê³„ì† ì‹¤í–‰ (ì•„ì´í…œ íšë“ ìœ„í•´)
                if (gameState.stageClearing) {
                    const nextStage = gameState.currentStage + 1;
                    ctx.fillStyle = lvl.theme; ctx.font = 'bold 36px Orbitron'; ctx.textAlign = 'center';
                    ctx.shadowBlur = 20; ctx.shadowColor = lvl.theme;
                    ctx.fillText(nextStage <= 10 ? `NEXT: STAGE ${nextStage}` : 'ğŸ‰ VICTORY!', canvas.width / 2, canvas.height / 2);
                    ctx.shadowBlur = 0;
                    // return ì œê±° - ì•„ë˜ ë Œë”ë§ ê³„ì†
                }

                // SURVIVE ë¬¸êµ¬ í‘œì‹œ (ì¼ë°˜ ìŠ¤í…Œì´ì§€ë§Œ)
                if (gameState.survivalMode && !lvl.isBoss) {
                    ctx.fillStyle = '#f55'; ctx.font = 'bold 28px Orbitron'; ctx.textAlign = 'center';
                    ctx.shadowBlur = 15; ctx.shadowColor = '#f55';
                    ctx.fillText('SURVIVE!', canvas.width / 2, canvas.height / 2); ctx.shadowBlur = 0;
                    // ë‹¤ë¥¸ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° ì˜í–¥ì„ ë°›ì§€ ì•Šë„ë¡ ë² ì´ìŠ¤ë¼ì¸ ì´ˆê¸°í™”
                    ctx.textBaseline = 'alphabetic';
                }

                // [ì‚½ì… ì½”ë“œ]
                if (gameState.isGhostActive && gameState.ghostHistory.length > 0) {
                    const ghostAction = gameState.ghostHistory[0]; // ê³¼ê±° ìœ„ì¹˜
                    ctx.save();
                    ctx.globalAlpha = 0.5; // ë°˜íˆ¬ëª…í•˜ê²Œ
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0f0'; // ë…¹ìƒ‰ ë„¤ì˜¨
                    
                    // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° ë¡œì§ê³¼ ìœ ì‚¬í•˜ê²Œ ë³¸ì²´ë§Œ ê·¸ë¦¼
                    ctx.translate(ghostAction.x + 10, ghostAction.y + 10);
                    ctx.fillStyle = '#0f0';
                    ctx.beginPath();
                    ctx.moveTo(0, -15); ctx.lineTo(10, 10); ctx.lineTo(-10, 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }


                drawLaser();
                drawDrones(); 
                drawPlayer();

                // ë£¨ë‚˜ ê°€ë””ì–¸ ë Œë”ë§
                if (gameState.isLunarMode) {
                    const px = gameState.player.x + gameState.player.w / 2;
                    const py = gameState.player.y;
                    const rad = gameState.lunarAngle * Math.PI / 180;
                    const gx = px + Math.cos(rad) * 40;
                    const gy = py - 15 + Math.sin(rad) * 40;

                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#88f';
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    ctx.arc(gx, gy, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(gx + 5, gy - 3, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                if (gameState.boss) {
                    if (gameState.boss.type === 'LUNAR') drawLunarBoss(gameState.boss);
                    else if (gameState.boss.type === 'SUN') drawSunBoss(gameState.boss);

                    // DANGER ê²½ê³  í‘œì‹œ (LUNAR ë³´ìŠ¤)
                    if (gameState.dangerWarning > 0 && gameState.boss.type === 'LUNAR') {
                        const blink = Math.floor(Date.now() / 100) % 2 === 0;
                        if (blink) {
                            ctx.fillStyle = '#f00';
                            ctx.font = 'bold 16px Orbitron';
                            ctx.textAlign = 'center';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#f00';
                            ctx.fillText('âš  DANGER âš ', gameState.boss.x + gameState.boss.w / 2, gameState.boss.y - 35);
                            ctx.shadowBlur = 0;
                        }
                    }
                }

                gameState.enemies.forEach(en => {
                    // [CDSO Safety] ì  í•˜ë‚˜ ê·¸ë¦´ ë•Œë§ˆë‹¤ ê²©ë¦¬ êµ¬ì—­(Sandbox) ìƒì„±
                    ctx.save();


                    if (en.type === 'BULLET') {
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = gameState.currentStage <= 5 ? '#8af' : '#f84';
                        ctx.fillStyle = ctx.shadowColor;
                        ctx.beginPath(); ctx.arc(en.x + en.w / 2, en.y + en.h / 2, en.w / 2, 0, Math.PI * 2); ctx.fill();
                    } else if (en.type === 'SHOCKWAVE') {
                        // ì›”ê´‘ ì¶©ê²©íŒŒ ë Œë”ë§ + ë°˜ì§ì„ íš¨ê³¼ (ìƒì‡„ ë¶ˆê°€ í‘œì‹œ)
                        const shimmer = 1 + Math.sin(Date.now() / 50) * 0.3;
                        ctx.shadowBlur = 15 * shimmer;
                        ctx.shadowColor = '#88f';
                        ctx.fillStyle = '#aaf';
                        ctx.beginPath();
                        ctx.arc(en.x + en.w / 2, en.y + en.h / 2, (en.w / 2 + 2) * shimmer, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#111';
                        ctx.beginPath();
                        ctx.arc(en.x + en.w / 2 + 5, en.y + en.h / 2 - 3, en.w / 2 - 2, 0, Math.PI * 2);
                        ctx.fill();
                        // ë°˜ì§ì„ í‘œì‹œ
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px sans-serif';
                        ctx.fillText('âœ¨', en.x + en.w - 5, en.y + 5);
                    } else if (en.type === 'METEOR') {
                        // ìœ ì„± ë Œë”ë§ - ë¶ˆíƒ€ëŠ” ê¼¬ë¦¬ íš¨ê³¼ + ë°˜ì§ì„ (ìƒì‡„ ë¶ˆê°€)
                        const mx = en.x + en.w / 2, my = en.y + en.h / 2;
                        const shimmer = 1 + Math.sin(Date.now() / 50) * 0.2;
                        // ê¼¬ë¦¬
                        ctx.shadowBlur = 20 * shimmer;
                        ctx.shadowColor = '#f80';
                        const grad = ctx.createLinearGradient(mx, my - 15, mx, my + 25);
                        grad.addColorStop(0, 'rgba(255,100,50,0.8)');
                        grad.addColorStop(1, 'rgba(255,200,100,0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(mx - 10, my);
                        ctx.lineTo(mx, my - 20);
                        ctx.lineTo(mx + 10, my);
                        ctx.fill();
                        // ë³¸ì²´
                        ctx.fillStyle = '#88f';
                        ctx.beginPath();
                        ctx.arc(mx, my, 14 * shimmer, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#aaf';
                        ctx.beginPath();
                        ctx.arc(mx - 3, my - 3, 6, 0, Math.PI * 2);
                        ctx.fill();
                        // ë°˜ì§ì„ í‘œì‹œ
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px sans-serif';
                        ctx.fillText('âœ¨', mx + 10, my - 10);
                        ctx.shadowBlur = 0;
                    } else {
                        drawAlien(en, gameState.currentStage);
                    }

                    // [CDSO Safety] ê²©ë¦¬ í•´ì œ (ìƒíƒœ ë³µêµ¬)
                    ctx.restore();
                });

                gameState.items.forEach(it => drawGiftBox(it));

                ctx.shadowBlur = 5; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
                gameState.bullets.forEach(b => {

                    // â–¼â–¼â–¼ [CDSO Patch] ë“œë¡  ìí­ ë¯¸ì‚¬ì¼ ë Œë”ë§ â–¼â–¼â–¼
                    if (b.type === 'DRONE_MISSILE') {
                        const flicker = Math.random() * 0.5 + 0.5;
                        ctx.save();
                        ctx.translate(b.x + b.w / 2, b.y + b.h / 2);

                        // ê´‘ë€ì˜ ì—ë„ˆì§€ (Overload)
                        ctx.shadowBlur = 30 * flicker;
                        ctx.shadowColor = b.color || '#0ff';
                        ctx.fillStyle = '#fff';

                        // ë³¸ì²´: ê¸¸ê²Œ ë»—ì€ ì—ë„ˆì§€ ì°½
                        ctx.beginPath();
                        ctx.moveTo(0, -b.h / 2);
                        ctx.lineTo(b.w / 2, b.h / 2);
                        ctx.lineTo(0, b.h / 4); // ë’¤ìª½ì€ íŒŒì¸ í˜•íƒœ (ì¶”ì§„ë ¥)
                        ctx.lineTo(-b.w / 2, b.h / 2);
                        ctx.closePath();
                        ctx.fill();

                        // ì¶©ê²©íŒŒ ë§ (Shockwave Ring) - ë¯¸ì‚¬ì¼ ì£¼ë³€ì„ ê°ì‹¸ëŠ” ê³ ë¦¬
                        ctx.strokeStyle = b.color || '#0ff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(0, b.h / 4, b.w / 1.5, b.h / 6, 0, 0, Math.PI * 2);
                        ctx.stroke();

                        ctx.restore();
                        return; // ê·¸ë¦¬ê¸° ì¢…ë£Œ
                    }


                    if (b.isLunar) {
                        // í¬ë ˆì„¼íŠ¸ ë°˜ë‹¬ íƒ„í™˜
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#88f';
                        ctx.fillStyle = '#aaf';
                        ctx.beginPath();
                        ctx.arc(b.x + 6, b.y + 6, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#111';
                        ctx.beginPath();
                        ctx.arc(b.x + 9, b.y + 4, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (b.isHoming) {
                        ctx.save();
                        ctx.translate(b.x + b.w / 2, b.y + b.h / 2);

                        // ìœ ë„íƒ„ì˜ í˜„ì¬ ì´ë™ ë°©í–¥ìœ¼ë¡œ íšŒì „ (vx, vy ê¸°ë°˜ ê°ë„ ê³„ì‚°)
                        const angle = Math.atan2(b.vy, b.vx) + Math.PI / 2;
                        ctx.rotate(angle);

                        // 1. ì´ì˜¨ ì¶”ì§„ ì—”ì§„ ì”ìƒ (Trailing Effect)
                        const flicker = Math.random() * 5;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#a0f'; // ìœ ë„íƒ„ ì‹œê·¸ë‹ˆì²˜ ì»¬ëŸ¬ (ë³´ë¼)

                        const trailGrad = ctx.createLinearGradient(0, 0, 0, 15);
                        trailGrad.addColorStop(0, 'rgba(160, 0, 255, 0.8)');
                        trailGrad.addColorStop(1, 'rgba(160, 0, 255, 0)');
                        ctx.fillStyle = trailGrad;
                        ctx.fillRect(-2, 5, 4, 10 + flicker);

                        // 2. ë¯¸ì‚¬ì¼ ë°”ë”” (Aerodynamic Body)
                        ctx.fillStyle = '#fff'; // íƒ„ë‘ ì½”ì–´ëŠ” í™”ì´íŠ¸
                        ctx.beginPath();
                        ctx.moveTo(0, -b.h); // ë¾°ì¡±í•œ íƒ„ë‘
                        ctx.lineTo(4, 2);
                        ctx.lineTo(-4, 2);
                        ctx.closePath();
                        ctx.fill();

                        // 3. ì•ˆì • ë‚ ê°œ (Stabilizers)
                        ctx.strokeStyle = '#c4f';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(-4, -2); ctx.lineTo(-7, 4);
                        ctx.moveTo(4, -2); ctx.lineTo(7, 4);
                        ctx.stroke();

                        ctx.restore();


                    } else {
                        // â–¼â–¼â–¼ [CDSO Patch] ë„¤ì˜¨ í„ìŠ¤ ë””ìì¸ ì ìš© (PLAYER_PULSE) â–¼â–¼â–¼
                        ctx.save();
                        ctx.translate(b.x + b.w / 2, b.y + b.h / 2);

                        // 1. ë„¤ì˜¨ ê´‘ì› (ì²­ë¡ìƒ‰)
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#0ff';

                        // 2. ì½”ì–´ (í•˜ì–€ìƒ‰ ì—ë„ˆì§€)
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        // ë‘¥ê·¼ ìº¡ìŠ í˜•íƒœ + ì•ìª½ ë¾°ì¡±í•˜ê²Œ
                        ctx.moveTo(-b.w / 2, -b.h / 2 + 2);
                        ctx.lineTo(0, -b.h / 2 - 4);
                        ctx.lineTo(b.w / 2, -b.h / 2 + 2);
                        ctx.lineTo(b.w / 2, b.h / 2);
                        ctx.lineTo(-b.w / 2, b.h / 2);
                        ctx.closePath();
                        ctx.fill();

                        // 3. ê¼¬ë¦¬ (ì”ìƒ íš¨ê³¼)
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; // ë°˜íˆ¬ëª… ì²­ë¡
                        ctx.beginPath();
                        ctx.moveTo(-b.w / 3, b.h / 2);
                        ctx.lineTo(0, b.h / 2 + 8); // ë’¤ë¡œ ê¸¸ê²Œ ë»—ìŒ
                        ctx.lineTo(b.w / 3, b.h / 2);
                        ctx.fill();

                        ctx.restore();
                    }
                });
                ctx.shadowBlur = 0;

                // ë¬´ì§€ê°œ íŒŒë™ ë Œë”ë§
                if (gameState.rainbowWave) {
                    const waveY = gameState.rainbowWave.y;
                    const waveHeight = 30;

                    // ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜
                    const grad = ctx.createLinearGradient(0, waveY - waveHeight / 2, 0, waveY + waveHeight / 2);
                    const offset = (Date.now() / 10) % 360;
                    for (let i = 0; i <= 6; i++) {
                        const hue = (offset + i * 60) % 360;
                        grad.addColorStop(i / 6, `hsla(${hue}, 100%, 60%, 0.9)`);
                    }

                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#fff';
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, waveY - waveHeight / 2, canvas.width, waveHeight);

                    // ì¤‘ì•™ ë°ì€ ë¼ì¸
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.fillRect(0, waveY - 2, canvas.width, 4);
                    ctx.shadowBlur = 0;
                }

                // ì‹œê°„ ë³´ë„ˆìŠ¤ í‘œì‹œ
                if (gameState.timeBonusDisplay && gameState.timeBonusDisplay.timer > 0) {
                    const alpha = Math.min(1, gameState.timeBonusDisplay.timer);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#ff0';
                    ctx.font = 'bold 24px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0';
                    ctx.fillText(`TIME BONUS: +${gameState.timeBonusDisplay.amount}`, canvas.width / 2, 130);
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }

                // [CDSO Patch] ê°€ìƒ ì¡°ì´ìŠ¤í‹± UI ë Œë”ë§
                if (gameState.joystick && gameState.joystick.active && gameState.controlMode === 'JOYSTICK') { // <--- ì—¬ê¸°ì— ì¡°ê±´ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
                    ctx.save();

                    // 1. ë² ì´ìŠ¤ (ëª¸ì²´)
                    ctx.beginPath();
                    ctx.arc(gameState.joystick.baseX, gameState.joystick.baseY, 50, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.fill();
                    ctx.stroke();

                    // 2. ìŠ¤í‹± (í—¤ë“œ)
                    ctx.beginPath();
                    ctx.arc(gameState.joystick.stickX, gameState.joystick.stickY, 20, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0ff';
                    ctx.fill();

                    ctx.restore();
                }

                drawProgressBar();
            }

            function drawPlayer() {
                const p = gameState.player, cx = p.x + p.w / 2, cy = p.y + p.h / 2;

                // [ì¶”ê°€] ì¡°ì´ìŠ¤í‹± ë°©í–¥ì— ë”°ë¥¸ ê¸°ìš¸ê¸° ê°’ ê³„ì‚° (ë³´í¸ì  ìˆ˜ì¹˜: 0.2~0.3)
                let tilt = 0;
                if (gameState.joystick && gameState.joystick.active) {
                    tilt = gameState.joystick.vecX * 0.25; 
                }


                // â–¼â–¼â–¼ [CDSO Fix] ëˆ„ë½ëœ í€€í…€ ê³ ìŠ¤íŠ¸(ì”ìƒ) ë Œë”ë§ ë³µêµ¬ â–¼â–¼â–¼
                if (gameState.isGhostActive && gameState.ghostHistory.length > 0) {
                    ctx.save();
                    gameState.ghostHistory.forEach((pos, i) => {
                        // ê³¼ê±°ì¼ìˆ˜ë¡ íˆ¬ëª…í•˜ê³  ì‘ê²Œ (ê¼¬ë¦¬ íš¨ê³¼)
                        const alpha = i / gameState.ghostHistory.length;
                        const scale = 0.5 + (alpha * 0.5);

                        ctx.globalAlpha = alpha * 0.5; // ë°˜íˆ¬ëª…
                        ctx.translate(pos.x + p.w / 2, pos.y + p.h / 2);
                        ctx.scale(scale, scale);

                        // ë…¹ìƒ‰ í™€ë¡œê·¸ë¨ ì”ìƒ
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#0f0';
                        ctx.fillStyle = '#0f0';

                        // ê¸°ì²´ í˜•ìƒ (ê°„ì†Œí™”)
                        ctx.beginPath();
                        ctx.moveTo(0, -15);
                        ctx.lineTo(10, 10);
                        ctx.lineTo(-10, 10);
                        ctx.fill();

                        // ì¢Œí‘œê³„ ë³µêµ¬ (ë£¨í”„ ë‚´ì—ì„œ translate í–ˆìœ¼ë¯€ë¡œ ë§¤ë²ˆ ë¦¬ì…‹ í•„ìš”)
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                    });
                    ctx.restore();
                }




                // [CDSO Patch: ì‹¤ë“œ ì‹œê°í™” ì—”ì§„]
                if (gameState.skillMode === 'SHIELD') {
                    ctx.save();
                    ctx.translate(cx, cy);

                    // 1. ì—ë„ˆì§€ ë§¥ë™ ë° ì¢…ë£Œ ì„ë°• ê²½ê³  ë¡œì§
                    const isExpiring = gameState.skillTimer < 1.5;
                    const pulse = 1 + Math.sin(Date.now() / (isExpiring ? 50 : 150)) * 0.1;
                    const shieldAlpha = isExpiring ? (Math.floor(Date.now() / 100) % 2 === 0 ? 0.6 : 0.2) : 0.4;

                    // 2. ì™¸ë¶€ ì—ë„ˆì§€ ë§‰ (Outer Shell)
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = '#0f0';
                    ctx.strokeStyle = `rgba(0, 255, 100, ${shieldAlpha})`;
                    ctx.lineWidth = 3;

                    ctx.beginPath();
                    ctx.arc(0, 0, 35 * pulse, 0, Math.PI * 2);
                    ctx.stroke();

                    // 3. ë‚´ë¶€ ì—ë„ˆì§€ í•µ (Inner Glow)
                    const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 35);
                    grad.addColorStop(0, 'rgba(0, 255, 0, 0)');
                    grad.addColorStop(1, `rgba(0, 255, 100, ${shieldAlpha * 0.5})`);
                    ctx.fillStyle = grad;
                    ctx.fill();

                    // 4. íšŒì „í•˜ëŠ” ìœ„ì„± ë¹„íŠ¸ (Orbital Bits) - ì‹¤ë“œ í™œì„± ì‹œ ì‹œê°ì  ë°€ë„ ê°•í™”
                    ctx.rotate(Date.now() / 500);
                    ctx.fillStyle = '#0f0';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i * Math.PI * 2) / 3;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * 35, Math.sin(angle) * 35, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }

                // í”¼ê²©/ë¬´ì  ìƒíƒœ ê¹œë¹¡ì„ ì²˜ë¦¬
                if (gameState.isInvincible && Math.floor(gameState.invincibilityTimer * 10) % 2 === 0) ctx.globalAlpha = 0.4;
                if (gameState.downgradeFlash > 0) ctx.globalAlpha = 0.5 + Math.sin(gameState.downgradeFlash * 20) * 0.5;


                // â–¼â–¼â–¼ [CDSO Design: NEO-VECTOR Fuselage] â–¼â–¼â–¼

                // 1. ìƒ‰ìƒ ë° ë„¤ì˜¨ ê´‘ì› ì„¤ì •
                let primaryColor, coreColor;

                if (gameState.ultGauge >= 1 && !gameState.rainbowWave) {
                    // í•„ì‚´ê¸° ì™„ì¶© ì‹œ: ë¬´ì§€ê°œ ì˜¤ë²„ë“œë¼ì´ë¸Œ
                    const hue = (Date.now() / 5) % 360;
                    primaryColor = `hsl(${hue}, 100%, 70%)`;
                    coreColor = '#fff';
                    ctx.shadowBlur = 30 + Math.sin(Date.now() / 50) * 10;
                } else {
                    // ì¼ë°˜/ë³€ì‹  ìƒíƒœ
                    if (gameState.isTransformed) {
                        primaryColor = '#FFD700'; // ê³¨ë“œ
                        coreColor = gameState.isLaserMode ? '#f00' : '#fff'; // ë ˆì´ì € ëª¨ë“œë©´ ì½”ì–´ê°€ ë¶‰ê²Œ
                        ctx.shadowBlur = 25;
                    } else {
                        // ê¸°ë³¸ ìƒíƒœ: ì„¸ë ¨ëœ ì‹¤ë²„/í™”ì´íŠ¸ ë°”ë”” + ìŠ¤í‚¬ë³„ ì»¬ëŸ¬
                        primaryColor = '#e0e0e0';
                        // ìŠ¤í‚¬ ìƒíƒœì— ë”°ë¼ ì½”ì–´ ìƒ‰ìƒ ë³€ê²½ (ì§ê´€ì„± í™•ë³´)
                        if (gameState.isHomingMode) coreColor = '#c4f';      // ìœ ë„: ë³´ë¼
                        else if (gameState.skillMode === 'SHIELD') coreColor = '#0f0'; // ì‰´ë“œ: ë…¹ìƒ‰
                        else if (gameState.isLaserMode) coreColor = '#ff0';  // ë ˆì´ì €: ë…¸ë‘
                        else coreColor = '#0ff';                             // ê¸°ë³¸: ì²­ë¡

                        ctx.shadowBlur = 15;
                    }
                }

                ctx.shadowColor = primaryColor;


                // 2. ê¸°ì²´ ë³¸ì²´ ê·¸ë¦¬ê¸° (Main Body)
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(tilt); // <--- ì´ ë¼ì¸ì„ ì—¬ê¸°ì— ì¶”ê°€í•˜ì„¸ìš”!

                // ë³€ì‹  ì—¬ë¶€ì— ë”°ë¼ ë‚ ê°œ í¼ì¹¨ ì •ë„ê°€ ë‹¤ë¦„
                const wingSpread = gameState.isTransformed ? 28 : 22;

                ctx.fillStyle = primaryColor;
                ctx.strokeStyle = primaryColor;
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';

                ctx.beginPath();
                // (1) ê¸°ìˆ˜ (Nose) - ë‚ ë µí•˜ê²Œ
                ctx.moveTo(0, -28);

                // (2) ë‚ ê°œ ì•ì„  (Leading Edge)
                ctx.lineTo(-8, -5);
                ctx.lineTo(-wingSpread, 12); // ë‚ ê°œ ë

                // (3) ë‚ ê°œ ë’·ì„  (Trailing Edge) - ì „ì§„ìµ ìŠ¤íƒ€ì¼
                ctx.lineTo(-12, 18);
                ctx.lineTo(-6, 12);  // ì—”ì§„ë£¸ ì—°ê²°ë¶€

                // (4) ì—”ì§„ë£¸ í•˜ë‹¨
                ctx.lineTo(-4, 20);
                ctx.lineTo(4, 20);

                // (5) ë°˜ëŒ€ìª½ ëŒ€ì¹­
                ctx.lineTo(6, 12);
                ctx.lineTo(12, 18);
                ctx.lineTo(wingSpread, 12);
                ctx.lineTo(8, -5);
                ctx.closePath();

                // ë‚´ë¶€ ì±„ìš°ê¸° (ë°˜íˆ¬ëª… ëŠë‚Œì„ ìœ„í•´ alpha ì¡°ì ˆ ê°€ëŠ¥í•˜ë‚˜ ì—¬ê¸°ì„  solid)
                ctx.fill();
                // ì™¸ê³½ì„  ê°•ì¡°
                ctx.stroke();


                // 3. ì½•í• & ì—ë„ˆì§€ ì½”ì–´ (Cockpit & Core)
                // ì–´ë‘ìš´ ë¶€ë¶„ì„ ê·¸ë ¤ì„œ ì…ì²´ê° ë¶€ì—¬
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(-3, -5);
                ctx.lineTo(0, 2);
                ctx.lineTo(3, -5);
                ctx.fill();

                // ë¹›ë‚˜ëŠ” ì½”ì–´ (ìƒíƒœ í‘œì‹œë“± ì—­í• )
                ctx.shadowColor = coreColor;
                ctx.shadowBlur = 20;
                ctx.fillStyle = coreColor;

                ctx.beginPath();
                // ë‹¤ì´ì•„ëª¬ë“œ í˜•íƒœ ì½”ì–´
                ctx.moveTo(0, -8);
                ctx.lineTo(-2, -2);
                ctx.lineTo(0, 4);
                ctx.lineTo(2, -2);
                ctx.fill();


                // 4. ì´ì˜¨ ìŠ¤ëŸ¬ìŠ¤í„° (Ion Thrusters) - ë¶ˆê½ƒ ëŒ€ì‹  ì—ë„ˆì§€ ë¶„ì‚¬
                // ì¢Œìš° ì—”ì§„ì—ì„œ ë¶„ì‚¬
                const thrustColor = gameState.isTransformed ? '#fb0' : '#0ff';
                ctx.fillStyle = thrustColor;
                ctx.shadowColor = thrustColor;

                // ëœë¤ í”Œë¦¬ì»¤ íš¨ê³¼ (ì—”ì§„ ë–¨ë¦¼)
                const flicker = Math.random() * 8;
                const thrustLen = (gameState.isTransformed ? 25 : 15) + flicker;

                // ì¢Œì¸¡ ì—”ì§„
                ctx.beginPath();
                ctx.moveTo(-5, 20);
                ctx.lineTo(-8, 20 + thrustLen);
                ctx.lineTo(-2, 20 + thrustLen * 0.7);
                ctx.fill();

                // ìš°ì¸¡ ì—”ì§„
                ctx.beginPath();
                ctx.moveTo(5, 20);
                ctx.lineTo(8, 20 + thrustLen);
                ctx.lineTo(2, 20 + thrustLen * 0.7);
                ctx.fill();

                ctx.restore();


                // â–¼â–¼â–¼ [CDSO Patch 4-4B: ë¯¸ëŸ¬ ì½”íŠ¸ ë°°ë¦¬ì–´] â–¼â–¼â–¼
                if (gameState.isMirrorActive) {
                    // ë°°ë¦¬ì–´ë„ ìœ¡ê°í˜• ë²Œì§‘ êµ¬ì¡°(Honeycomb)ë¡œ ë³€ê²½í•˜ì—¬ SF ëŠë‚Œ ê°•í™”
                    ctx.strokeStyle = `rgba(100, 255, 255, ${0.5 + Math.sin(Date.now() / 100) * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0ff';

                    ctx.beginPath();
                    const r = 40; // ë°°ë¦¬ì–´ í¬ê¸°
                    for (let i = 0; i < 6; i++) {
                        const angle = (Date.now() / 1000) + (i * Math.PI / 3); // ë°°ë¦¬ì–´ íšŒì „
                        const px = cx + Math.cos(angle) * r;
                        const py = cy + Math.sin(angle) * r;
                        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }

                ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
            }


            function drawDrones() {
                if (gameState.isTransformed) return; // ë³€ì‹  ì‹œ ë“œë¡ ì€ ë³¸ì²´ì— í¡ìˆ˜ë¨

                gameState.drones.forEach(drone => {
                    // ë“œë¡ ì˜ ê¸°ì¤€ ì¢Œí‘œ (í”Œë ˆì´ì–´ ì–‘ì˜†)
                    const dx = gameState.player.x + 10 + drone.offsetX;
                    const dy = gameState.player.y + 15;

                    ctx.save();
                    ctx.translate(dx, dy);

                    // [Micro-Animation] ë¶€ìœ ê°(Floating) ì—°ì¶œ
                    // ë¯¸ì‚¬ì¼ì´ ë‹¨ìˆœíˆ ë¶™ì–´ìˆëŠ” ê²Œ ì•„ë‹ˆë¼, ê³µì¤‘ì—ì„œ ëŒ€ê¸° ì¤‘ì¸ ëŠë‚Œì„ ì¤Œ
                    const hover = Math.sin(Date.now() / 150) * 2;
                    ctx.translate(0, hover);

                    // 1. ë„¤ì˜¨ ê´‘ì› (Glow) - ì•„êµ°ì„ì„ ì‹ë³„í•˜ëŠ” ì²­ë¡ìƒ‰
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0ff';

                    // 2. íƒ„ë‘ (Warhead) - ì˜ˆë¦¬í•œ ì‚¼ê°í˜•
                    // ì ì„ ê¿°ëš«ì„ ë“¯í•œ ë‚ ì¹´ë¡œì›€ ê°•ì¡°
                    ctx.fillStyle = '#0ff'; // í•µì‹¬ ì»¬ëŸ¬
                    ctx.beginPath();
                    ctx.moveTo(0, -14); // ë¾°ì¡±í•œ ë
                    ctx.lineTo(4, -6);
                    ctx.lineTo(-4, -6);
                    ctx.fill();

                    // 3. ë™ì²´ (Fuselage) - ë©”íƒˆë¦­ ì‹¤ë¦°ë”
                    ctx.fillStyle = '#e0ffff'; // ë°ì€ ê¸ˆì†ì„±
                    ctx.beginPath();
                    ctx.fillRect(-4, -6, 8, 14); // ëª¸í†µ

                    // ë™ì²´ ë””í…Œì¼ ë¼ì¸ (íŒ¨ë„ ë¼ì¸)
                    ctx.fillStyle = '#008b8b';
                    ctx.fillRect(-2, -2, 4, 6);

                    // 4. ì•ˆì • ë‚ ê°œ (Stabilizer Fins) - ì—­ë™ì ì¸ í›„í‡´ìµ
                    ctx.fillStyle = '#00ced1'; // ì¤‘ê°„ í†¤ ì²­ë¡
                    ctx.beginPath();

                    // ì¢Œì¸¡ ë‚ ê°œ
                    ctx.moveTo(-4, 0);
                    ctx.lineTo(-9, 8); // ë‚ ê°œ ë
                    ctx.lineTo(-4, 8);

                    // ìš°ì¸¡ ë‚ ê°œ
                    ctx.moveTo(4, 0);
                    ctx.lineTo(9, 8); // ë‚ ê°œ ë
                    ctx.lineTo(4, 8);
                    ctx.fill();

                    // 5. ì´ì˜¨ ì¶”ì§„ì²´ (Ion Thruster)
                    // ì—”ì§„ì´ ê°€ë™ ì¤‘ì„ì„ ë³´ì—¬ì£¼ëŠ” ì‹œê°ì  í”¼ë“œë°±
                    const flicker = Math.random() * 3; // ë¶ˆê½ƒì´ íŒŒë¥´ë¥´ ë–¨ë¦¼
                    ctx.fillStyle = '#0ff';
                    ctx.beginPath();
                    ctx.moveTo(-2, 8);
                    ctx.lineTo(0, 14 + flicker); // ê¸¸ê²Œ ë»—ëŠ” ë¶ˆê½ƒ
                    ctx.lineTo(2, 8);
                    ctx.fill();

                    ctx.restore();
                });
                ctx.shadowBlur = 0;
            }


            function gameOver() {
                gameState.isRunning = false;
                // [CDSO Patch] ê²Œì„ ì¢…ë£Œ ì¦‰ì‹œ 'ìë™ ì €ì¥ ë° ê²°ê³¼ í™”ë©´' í”„ë¡œì„¸ìŠ¤ ê°€ë™
                // showResultScreen ëŒ€ì‹  autoSaveProcessë¥¼ ë°”ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.
                autoSaveProcess('MISSION FAILED');

            }


            // [CDSO ìµœì¢… ìˆ˜ì •] TOP 5 ì´ë¯¸ì§€ í†µí•© + PC ê³µìœ  ì¶©ëŒ ë°©ì§€ ì‹œìŠ¤í…œ
            async function shareScore() {
                // 1. ë°ì´í„° ì¤€ë¹„
                const myRank = gameState.finalRank || '?';
                const myScore = Math.round(gameState.score);
                // ì…ë ¥ì°½ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ 'PLAYER' ì‚¬ìš©
                const inputEl = document.getElementById('initial-input');
                const myName = inputEl ? inputEl.value.toUpperCase() : (gameState.playerName || 'PLAYER');
                const gameUrl = window.location.href;

                // 2. ë°”ì´ëŸ´ í…ìŠ¤íŠ¸ (ë³µì‚¬ ë° ê³µìœ ìš©)
                const shareTitle = 'Neon Dodge Record';
                const shareText = `[NEON DODGE]\nğŸ‘‘ RANK: ${myRank}\nğŸ‘¾ PLAYER: ${myName}\nğŸš€ SCORE: ${myScore.toLocaleString()}\n\në‚˜ë³´ë‹¤ ëª»í•˜ì¥¬?\nğŸ”— Play: ${gameUrl}`;

                // 3. ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° (ì´ë¯¸ì§€ í•©ì„±)
                ctx.save();

                // ë°°ê²½ & í…Œë‘ë¦¬
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 10;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);

                // A. íƒ€ì´í‹€ (ìƒë‹¨)
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('NEON DODGE', canvas.width / 2, 60);

                // B. ë‚´ ìˆœìœ„ & ì ìˆ˜ (ì¤‘ë‹¨ ê°•ì¡°)
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 30;
                ctx.fillStyle = '#f00';
                ctx.font = 'bold 50px Orbitron';
                ctx.fillText(`RANK ${myRank}`, canvas.width / 2, 130);

                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#fff';
                ctx.font = '20px Orbitron';
                ctx.fillText(`PLAYER: ${myName}`, canvas.width / 2, 170);

                ctx.shadowColor = '#f0f';
                ctx.fillStyle = '#f0f';
                ctx.font = 'bold 36px Orbitron';
                ctx.fillText(myScore.toLocaleString(), canvas.width / 2, 215);

                // êµ¬ë¶„ì„ 
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, 240);
                ctx.lineTo(410, 240);
                ctx.stroke();

                // C. TOP 10 ë¦¬ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° (í•˜ë‹¨ í‘œ)
                ctx.shadowColor = '#ff0';
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 18px Orbitron';

                ctx.fillText('- LEGENDARY TOP 10 -', canvas.width / 2, 255); // Yì¢Œí‘œ 255ë¡œ ì˜¬ë¦¼
                const listItems = document.querySelectorAll('#leaderboard li');

                // [ìˆ˜ì •] ì‹œì‘ ìœ„ì¹˜ë¥¼ 300ìœ¼ë¡œ ëŒ€í­ ì˜¬ë¦¼
                let startY = 300;
                // [ì¶”ê°€] ì´˜ì´˜í•œ ì¤„ ê°„ê²© ë³€ìˆ˜ ìƒì„±
                const lineHeight = 38;
                ctx.font = '14px Orbitron';

                listItems.forEach((li, index) => {
                    if (index >= 10) return; // 10ë“±ê¹Œì§€ë§Œ

                    // [CDSO ìˆ˜ì •] ìˆ¨ê²¨ì§„ ìš”ì†Œ(display:none)ì˜ ê°’ì„ ì½ê¸° ìœ„í•´ textContent ì‚¬ìš©
                    const pName = li.querySelector('.player-name')?.textContent || '???';
                    const pScore = li.querySelector('.player-score')?.textContent || '0';

                    const rank = index + 1;

                    // 1,2,3ë“± ìƒ‰ìƒ êµ¬ë¶„
                    let color = '#aaa';
                    if (rank === 1) color = '#ffd700';
                    else if (rank === 2) color = '#c0c0c0';
                    else if (rank === 3) color = '#cd7f32';
                    else if (rank <= 10) color = '#ddd'; // [ì¶”ê°€] 4~10ë“±ì€ ë°ì€ íšŒìƒ‰

                    // ì¢Œì¸¡ ì •ë ¬(ì´ë¦„) & ìš°ì¸¡ ì •ë ¬(ì ìˆ˜)
                    ctx.textAlign = 'left';
                    ctx.fillStyle = color;
                    ctx.fillText(`${rank}. ${pName}`, 50, startY);

                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(pScore, 400, startY);

                    startY += lineHeight; // [ìˆ˜ì •] 45 -> 38 (lineHeight ë³€ìˆ˜ ì‚¬ìš©)
                });

                // ë‚ ì§œ ë„ì¥
                ctx.textAlign = 'center';
                ctx.fillStyle = '#444';
                ctx.font = '10px Orbitron';
                ctx.fillText(new Date().toLocaleString(), canvas.width / 2, canvas.height - 20);

                // â˜… ì¤‘ìš”: ê·¸ë¦¬ê¸° ëë‚œ í›„ ìƒíƒœ ë³µêµ¬
                ctx.restore();


                // 4. ê³µìœ  ë¡œì§ (PC ì¶©ëŒ ë°©ì§€)
                try {
                    // ëª¨ë°”ì¼ ê¸°ê¸°ì¸ì§€ í™•ì¸ (ì´ë¯¸ ì„ ì–¸ëœ isMobileDevice í•¨ìˆ˜ í™œìš©)
                    const isMobile = (typeof isMobileDevice === 'function') ? isMobileDevice() : /Android|iPhone|iPad/i.test(navigator.userAgent);

                    if (isMobile && navigator.share) {
                        // [ëª¨ë°”ì¼] ì´ë¯¸ì§€ ê³µìœ  ì‹œë„
                        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                        const file = new File([blob], "neon_dodge_ranking.png", { type: "image/png" });

                        if (navigator.canShare && navigator.canShare({ files: [file] })) {
                            await navigator.share({
                                title: shareTitle,
                                text: shareText,
                                files: [file]
                            });
                            return; // ì„±ê³µ ì‹œ ì¢…ë£Œ
                        }
                    }

                    // [PC / ëª¨ë°”ì¼ ê³µìœ  ì‹¤íŒ¨ ì‹œ] í´ë¦½ë³´ë“œ ë³µì‚¬ë¡œ ê°•ì œ ì „í™˜
                    throw new Error("FALLBACK_TO_CLIPBOARD");

                } catch (err) {
                    // 5. í´ë¦½ë³´ë“œ ë³µì‚¬ (Fallback)
                    try {
                        await navigator.clipboard.writeText(shareText);
                        alert("ğŸ“‹ ë­í‚¹ê³¼ ì ìˆ˜ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n(Ctrl+Vë¡œ ê³µìœ í•˜ì„¸ìš”)");
                    } catch (clipboardErr) {
                        prompt("ì•„ë˜ í…ìŠ¤íŠ¸ë¥¼ ë³µì‚¬í•˜ì„¸ìš”:", shareText);
                    }
                }
            } // <--- â˜… [CDSO ê¸´ê¸‰ ìˆ˜ì •] ì—¬ê¸°ì— ë‹«ëŠ” ê´„í˜¸ê°€ ë°˜ë“œì‹œ ìˆì–´ì•¼ í•©ë‹ˆë‹¤!




            function gameLoop(now) {
                let dt = (now - lastTime) / 1000; lastTime = now;

                // [CDSO Hardening] dtë¥¼ ì•ˆì „ ë²”ìœ„ë¡œ í´ë¨í•‘ (0~Infinity ë°©ì§€)
                dt = Math.max(0.001, Math.min(0.1, dt));


                // [CDSO Patch] ìŠ¤í° ì£¼ê¸°ë„ ì‹œê°„ ì™œê³¡ì˜ ì˜í–¥ì„ ë°›ë„ë¡ ìˆ˜ì •
                spawnEntities(dt * gameState.timeScale);

                update(dt); // update ë‚´ë¶€ëŠ” ì´ë¯¸ ë¶€ë¶„ì ìœ¼ë¡œ timeScale ì ìš©ë¨

                // ë°°ê²½ ì†ë„ë¥¼ ìœ„í•´ dt ì „ë‹¬ (draw í•¨ìˆ˜ ìˆ˜ì • í•„ìš”)
                draw(dt);
                if (gameState.isRunning) requestAnimationFrame(gameLoop);
            }

            window.addEventListener('firebase-ready', initFirebaseRanking);
            setTimeout(() => { if (!firebaseReady) initFirebaseRanking(); }, 1000);

            // [CDSO ì „ëµ] ê´€ë¦¬ì ì „ìš© ë°±ë„ì–´ (í‚¤ë³´ë“œ ê°ì§€)
            let cheatBuffer = [];
            const MAX_BUFFER = 20; // ìˆ«ìë¥¼ í¬í•¨í•´ì•¼ í•˜ë¯€ë¡œ ë²„í¼ë¥¼ ë„‰ë„‰í•˜ê²Œ ì¡ìŒ

            window.addEventListener('keydown', e => {
                const startScreen = document.getElementById('start-screen');
                // ì‹œì‘ í™”ë©´ì´ ì•ˆ ë³´ì´ë©´(ê²Œì„ ì¤‘ì´ë©´) ì‘ë™ X
                if (startScreen.style.display === 'none') return;

                // í‚¤ ì…ë ¥ ê¸°ë¡
                cheatBuffer.push(e.key.toUpperCase());
                if (cheatBuffer.length > MAX_BUFFER) cheatBuffer.shift();

                const inputStr = cheatBuffer.join('');

                // "ADMIN" íŒ¨í„´ ê°ì§€
                if (inputStr.endsWith("ADMIN")) {
                    // ì •ê·œì‹ìœ¼ë¡œ ADMIN ì•ì˜ ìˆ«ì ì¶”ì¶œ (ì˜ˆ: "3ADMIN" -> "3")
                    const match = inputStr.match(/(\d+)ADMIN$/);

                    if (match) {
                        // 1. ìˆ«ì+ADMIN ì…ë ¥ ì‹œ (ì˜ˆ: 3ADMIN) -> í•´ë‹¹ ìŠ¤í…Œì´ì§€ë¡œ ì´ë™
                        const stageNum = parseInt(match[1]);
                        // ìœ íš¨ì„± ê²€ì‚¬ (1 ~ 11ìŠ¤í…Œì´ì§€)
                        if (stageNum >= 1 && stageNum <= 11) {
                            activateWormhole(stageNum);
                            cheatBuffer = []; // ë²„í¼ ì´ˆê¸°í™” (ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€)
                        }
                    } else {
                        // 2. ê·¸ëƒ¥ ADMIN ì…ë ¥ ì‹œ -> ê¸°ì¡´ì²˜ëŸ¼ íˆë“  ìŠ¤í…Œì´ì§€(11)ë¡œ ì´ë™
                        activateWormhole(11);
                        cheatBuffer = [];
                    }
                }
            });

            // 2. Mobile: ë¡œê³  í„°ì¹˜ ê°ì§€ (DOM ë¡œë“œ í›„ ì´ë²¤íŠ¸ ì—°ê²°)
            let logoTapCount = 0;
            let logoTapTimer = null;
            window.addEventListener('load', () => {
                const titleLogo = document.querySelector('#start-screen h1');
                if (titleLogo) {
                    titleLogo.addEventListener('click', () => {
                        logoTapCount++;

                        // 2ì´ˆ ì•ˆì— 5ë²ˆ ëª» ëˆ„ë¥´ë©´ ì´ˆê¸°í™”
                        clearTimeout(logoTapTimer);
                        logoTapTimer = setTimeout(() => { logoTapCount = 0; }, 2000);

                        if (logoTapCount >= 5) {
                            activateWormhole(); // ì›Œí”„ ë°œë™!
                            logoTapCount = 0;
                        }
                    });
                }
            });

            // 3. ì›Œí”„ ì‹¤í–‰ í•¨ìˆ˜ (Stage 11 ê°•ì œ ì§„ì…)
            // [CDSO ìˆ˜ì •] ë‹¤ëª©ì  ì›Œí”„ í•¨ìˆ˜ (ê¸°ë³¸ê°’: 11)
            function activateWormhole(targetStage = 11) {
                // [CDSO Hardening] ìŠ¤í…Œì´ì§€ ë°ì´í„° ë¶€ì¬ ì‹œ ê¸°ë³¸ê°’ ì£¼ì… (Fail-safe)
                if (targetStage <= levels.length && !levels[targetStage - 1]) {
                    levels[targetStage - 1] = {
                        stage: targetStage, duration: 30, theme: '#0ff',
                        speedMult: 1.0, spawnRate: 0.5, types: ['NORMAL'], isBoss: false
                    };
                    console.warn(`âš  Stage ${targetStage}: Default data injected by fail-safe`);
                }
                console.warn(`ğŸš€ ADMIN WARP ACTIVATED: TARGET STAGE ${targetStage}`);

                // 1) ê²Œì„ ì‹œì‘ í”„ë¡œì„¸ìŠ¤ ê°•ì œ ê°€ë™
                // ì´ë¦„ì´ ë¹„ì–´ìˆìœ¼ë©´ 'ADMIN' ìë™ ì£¼ì…
                const nameInput = document.getElementById('pilot-name-input');
                if (nameInput && nameInput.value.trim() === "") {
                    nameInput.value = "ADMIN";
                }
                // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
                gameState.playerName = nameInput ? (nameInput.value || "ADMIN") : "ADMIN";
                gameState.isAdminMode = true;

                // UI ìˆ¨ê¸°ê¸°
                document.getElementById('start-screen').style.display = 'none';
                const myRankList = document.getElementById('my-rank-list');
                if (myRankList) myRankList.style.display = 'none';

                // 2) ìƒíƒœ ì´ˆê¸°í™” ë° ìŠ¤í…Œì´ì§€ ì£¼ì…
                resetState();
                gameState.currentStage = targetStage;
                gameState.isRunning = true;

                // 3) ê´€ë¦¬ì íŠ¹ì „ ì§€ê¸‰ (í…ŒìŠ¤íŠ¸ìš©)
                gameState.lives = 5;       // ìƒëª… 5ê°œ
                gameState.ultGauge = 1.0;  // í•„ì‚´ê¸° ì™„ì¶©
                gameState.score = (targetStage - 1) * 5000; // ê°€ì§œ ì ìˆ˜

                // 4) ìŠ¤í…Œì´ì§€ë³„ ë°ì´í„° ë¡œë“œ (í•µì‹¬ ë¡œì§)
                if (targetStage >= 11) {
                    // ë¬´í•œ ëª¨ë“œ ì„¤ì •
                    gameState.stageTimer = 99999;
                    gameState.spawnDelay = 0;
                    gameState.infiniteDifficulty = 1.0;

                    const stageInfo = document.getElementById('stage-info');
                    if (stageInfo) {
                        stageInfo.textContent = "STAGE âˆ | TEST MODE";
                        stageInfo.style.color = "#0f0";
                    }
                } else {
                    // ì¼ë°˜ ìŠ¤í…Œì´ì§€ ì„¤ì • (levels ë°°ì—´ì—ì„œ ë¡œë“œ)
                    const lvl = levels[targetStage - 1] || levels[0];
                    gameState.stageTimer = lvl.duration;
                    gameState.bossPhase = 'MINION'; // ë³´ìŠ¤ì „ ì´ˆê¸°í™”
                    gameState.spawnDelay = 0.5;

                    // ë³´ìŠ¤ ìŠ¤í…Œì´ì§€ë©´ ë³´ìŠ¤ ì¦‰ì‹œ ì†Œí™˜ ì¤€ë¹„ëŠ” í•˜ì§€ ì•ŠìŒ (íƒ€ì´ë¨¸ íë¥¸ ë’¤ ë“±ì¥)
                    // ë§Œì•½ ì¦‰ì‹œ ë³´ìŠ¤ì „ì„ ì›í•˜ë©´ gameState.stageTimer = 0; ìœ¼ë¡œ ì„¤ì •
                }

                requestAnimationFrame(gameLoop);
            }

            // â–¼â–¼â–¼ [CDSO GOLD MASTER: í†µí•© ê´€ì œíƒ‘] â–¼â–¼â–¼

            // 1. ê¸€ë¡œë²Œ í•¨ìˆ˜ ê°•ì œ ì—°ê²°
            window.startGame = startGame;
            window.goToNameInput = goToNameInput;
            window.backToRanking = backToRanking;
            window.shareScore = shareScore;
            window.autoSaveProcess = autoSaveProcess;

            // [í•„ìˆ˜] ê´€ë¦¬ì ì›Œí”„ í•¨ìˆ˜ ì—°ê²°
            window.activateWormhole = activateWormhole;

            // 2. ì‹œìŠ¤í…œ ë¶€íŒ… (ë‹¨ì¼ ì§„ì…ì )
            window.addEventListener('load', async () => {
                console.log("ğŸš€ SYSTEM: Booting Neon Dodge Season 2 (Gold Master)...");

                // A. í™”ë©´ ë° ì»¨íŠ¸ë¡¤ ì´ˆê¸°í™”
                if (typeof resizeGame === 'function') resizeGame();

                // B. íŒŒì¼ëŸ¿ ì´ë¦„ ë³µêµ¬
                const saved = localStorage.getItem('lastPilotName');
                const inp = document.getElementById('pilot-name-input');
                if (saved && inp) {inp.value = saved;}

                // C. [ì´ìŠ¤í„°ì—ê·¸] íƒ€ì´í‹€ ë¡œê³  ì›Œí”„ ì‹œìŠ¤í…œ
                const titleLogo = document.querySelector('#start-screen h1');
                if (titleLogo) {
                    let tapCount = 0;
                    let tapTimer = null;

                    titleLogo.addEventListener('click', () => {
                        tapCount++;
                        if (tapTimer) clearTimeout(tapTimer);
                        tapTimer = setTimeout(() => { tapCount = 0; }, 2000); // 2ì´ˆ ë¦¬ì…‹

                        if (tapCount >= 5) {
                            console.warn("âš  WORMHOLE ACTIVATED âš ");

                            // â–¼â–¼â–¼ [CDSO Fix: ì—¬ê¸°ê°€ í•µì‹¬ì…ë‹ˆë‹¤] â–¼â–¼â–¼
                            // ì›Œí”„ ì‹œë„ ì‹œ, ì´ë¦„ì´ ë¹„ì–´ìˆìœ¼ë©´ 'return'ì— ë§‰íˆì§€ ì•Šê²Œ
                            // ê°•ì œë¡œ "ADMIN"ì´ë¼ëŠ” ì´ë¦„ì„ ì£¼ì…í•©ë‹ˆë‹¤.
                            const nameInput = document.getElementById('pilot-name-input');
                            if (nameInput && nameInput.value.trim() === "") {
                                nameInput.value = "ADMIN";
                                // ì „ì—­ ë³€ìˆ˜ì—ë„ ì¦‰ì‹œ ë°˜ì˜
                                if (typeof gameState !== 'undefined') gameState.playerName = "ADMIN";
                            }
                            // â–²â–²â–² [ìˆ˜ì • ì™„ë£Œ] â–²â–²â–²

                            if (typeof activateWormhole === 'function') activateWormhole();
                            tapCount = 0;
                        }
                    });
                }

                // D. ë­í‚¹ ë¡œë“œ
                try {
                    if (typeof initFirebaseRanking === 'function') {
                        await initFirebaseRanking();
                        console.log("ğŸ† RANKING: Online.");
                    }
                } catch (e) {
                    console.warn("âš  RANKING OFFLINE:", e);
                    const lb = document.getElementById('leaderboard');
                    if (lb) lb.innerHTML = "<li style='color:#666;'>OFFLINE MODE</li>";
                }
            });

            // [CDSO FIX] HUD ìƒíƒœ ë™ê¸°í™” ì‹œìŠ¤í…œ (ì´ê²Œ ìˆì–´ì•¼ ëª¨ë“œê°€ ë°˜ì˜ë©ë‹ˆë‹¤)
            function updateHUD() {
                const hudMode = document.getElementById('hud-mode');
                const hudTimer = document.getElementById('hud-timer');
                const hudProgress = document.getElementById('hud-progress');
                const hudPanel = document.getElementById('hud-panel-v2');
                
                if (!hudMode || !hudPanel) return;

                let modeText = "SYSTEM NORMAL";
                let timer = 0;
                let maxTime = 1;
                let color = "#0ff"; // ê¸°ë³¸ ì²­ë¡ìƒ‰

                // 1. ìƒíƒœ ìš°ì„ ìˆœìœ„ ì²´í¬ (ê°€ì¥ ì¤‘ìš”í•œ ëª¨ë“œë¶€í„° ì²´í¬)
                if (gameState.isGlitchActive) {
                    modeText = "âš  SYSTEM ERROR âš ";
                    timer = gameState.glitchTimer;
                    maxTime = 5.0;
                    color = "#f00"; // ë¹¨ê°•
                } 
                else if (gameState.isGhostActive) {
                    modeText = "ğŸ‘» GHOST PROTOCOL";
                    timer = gameState.ghostTimer;
                    maxTime = 10.0;
                    color = "#0f0"; // ë…¹ìƒ‰
                }
                else if (gameState.isVoidActive) {
                    modeText = "âš« VOID HOLE";
                    timer = gameState.voidTimer;
                    maxTime = 10.0;
                    color = "#a0f"; // ë³´ë¼ìƒ‰
                }
                else if (gameState.timeScale < 1.0) {
                    modeText = "â³ TIME SLOW";
                    timer = gameState.slowTimer;
                    maxTime = 10.0;
                    color = "#0ff"; // ì²­ë¡
                }
                // â–¼â–¼â–¼ [ì¶”ê°€ëœ ë¶€ë¶„] ì‹¤ë“œ ëª¨ë“œ ì²´í¬ â–¼â–¼â–¼
                else if (gameState.skillMode === 'SHIELD') {
                    modeText = "ğŸ›¡ SHIELD";
                    timer = gameState.skillTimer;
                    maxTime = 5.0; // ì‹¤ë“œ ì§€ì†ì‹œê°„ (ê¸°ë³¸ 5ì´ˆ)
                    color = "#0f0"; // ë…¹ìƒ‰
                }
                else if (gameState.isLaserMode) {
                    modeText = "âš¡ LASER CANNON";
                    timer = gameState.laserTimer;
                    maxTime = 3.0;
                    color = "#ff0"; // ë…¸ë‘
                }
                else if (gameState.isHomingMode) {
                    modeText = "ğŸš€ HOMING MISSILE";
                    timer = gameState.homingTimer;
                    maxTime = 7.0;
                    color = "#c4f"; // ì—°ë³´ë¼
                }
                else if (gameState.isTransformed) {
                    modeText = "âœ¨ GOLDEN";
                    timer = 1; maxTime = 1; 
                    color = "#ffd700";
                }


                // 2. DOM ì—…ë°ì´íŠ¸ (í™”ë©´ì— ë°˜ì˜)
                hudMode.textContent = modeText;
                hudMode.style.textShadow = `0 0 5px ${color}`;
                hudPanel.style.borderLeftColor = color;
                
                // 3. íƒ€ì´ë¨¸ & ê²Œì´ì§€ ë°” ì—…ë°ì´íŠ¸
                if (modeText !== "SYSTEM NORMAL") {
                    // íƒ€ì´ë¨¸ í…ìŠ¤íŠ¸
                    hudTimer.textContent = timer > 0 ? timer.toFixed(1) + "s" : "";
                    hudTimer.style.color = color;

                    // ê²Œì´ì§€ ë°” ê¸¸ì´ ë° ìƒ‰ìƒ
                    const percent = Math.max(0, (timer / maxTime) * 100);
                    hudProgress.style.width = percent + "%";
                    hudProgress.style.background = color;
                    hudProgress.style.boxShadow = `0 0 8px ${color}`;
                } else {
                    hudTimer.textContent = "";
                    hudProgress.style.width = "0%";
                }
            }


        </script>
</body>

</html>
