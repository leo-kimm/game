<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>íƒ€ì›Œí˜• ë””íœìŠ¤</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100dvh;
      background: #0f1220;
      color: #e8ecff;
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .wrap.layout {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .canvas-container {
      flex: 8;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      background: #05070a;
      overflow: hidden;
    }

    canvas.game {
      background: #0b0e18;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      touch-action: none;
      max-width: 100%;
      max-height: 100%;
      display: block;
    }

    .panel.ui {
      flex: 2;
      width: 100%;
      background: #121733;
      border-top: 1px solid rgba(255, 255, 255, .12);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      padding: 0 4px;
      color: #ccc;
    }

    .top-bar b {
      color: #fff;
      margin-left: 4px;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr) 0.8fr;
      grid-template-rows: 1fr 1fr;
      gap: 6px;
      height: 100%;
    }

    button {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, .15);
      background: #171f43;
      color: #e8ecff;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.1s;
    }

    button span.cost {
      font-size: 10px;
      opacity: 0.7;
      margin-top: 2px;
    }

    /* [ì‹ ê·œ ì£¼ì…] ì„¤ëª… ë¬¸êµ¬ìš© ë””ìì¸ ìŠ¤í™ */
    button span.desc {
      font-size: 9px;
      color: #aaa;
      font-weight: normal;
      margin-top: 1px;
    }

    button:active {
      transform: scale(0.96);
      background: #222b5e;
    }

    button:disabled {
      opacity: 0.4;
      filter: grayscale(1);
    }

    .btn-on {
      background: #2a3566;
      border-color: #7aa6ff;
      box-shadow: inset 0 0 10px rgba(122, 166, 255, 0.2);
    }

    #startWave {
      grid-column: 4;
      grid-row: 1 / 3;
      background: #1b3a20;
      border-color: #2e5c35;
      font-size: 14px;
      line-height: 1.2;
    }

    #sell {
      grid-column: 1;
      grid-row: 2;
      border-color: #ff7a7a;
      color: #ffd6d6;
    }

    #sell.btn-on {
      background: #4d2020;
    }

    #upgrade {
      grid-column: 2;
      grid-row: 2;
      border-color: #ffd700;
      color: #fff6d6;
    }

    #upgrade.btn-on {
      background: #4d4420;
    }

    #t1 {
      grid-column: 1;
      grid-row: 1;
    }

    #t2 {
      grid-column: 2;
      grid-row: 1;
    }

    #t3 {
      grid-column: 3;
      grid-row: 1;
    }

    #floatLogContainer {
      position: absolute;
      bottom: 22%;
      right: 12px;
      width: 240px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      pointer-events: none;
      z-index: 20;
    }

    .float-log-item {
      background: rgba(0, 0, 0, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(2px);
      padding: 6px 10px;
      border-radius: 6px;
      margin-top: 4px;
      font-size: 12px;
      color: #fff;
      animation: fadeOut 3.5s forwards;
      text-align: right;
    }

    @keyframes fadeOut {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }

      10% {
        opacity: 1;
        transform: translateY(0);
      }

      80% {
        opacity: 1;
      }

      100% {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    #waveProgressBar {
      width: 100%;
      height: 4px;
      background: #1a1f35;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 50;
    }

    #waveProgressFill {
      height: 100%;
      width: 0%;
      background: #7aa6ff;
      transition: width 0.3s ease-out;
    }

    #toast {
      position: absolute;
      left: 50%;
      bottom: 28%;
      transform: translateX(-50%);
      max-width: 92%;
      padding: 8px 16px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 13px;
      text-align: center;
      pointer-events: none;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.3s ease;
      display: none;
    }

    #toast.show {
      display: block;
      opacity: 1;
    }

    /* --- ì‹ ê·œ ê²°ê³¼ í™”ë©´ ëª¨ë‹¬ ë””ìì¸ --- */
    @keyframes slideUpFade {
      0% {
        opacity: 0;
        transform: scale(0.9) translateY(30px);
      }

      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    #resultModal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 12, 20, 0.92);
      backdrop-filter: blur(12px);
      z-index: 9999;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .result-box {
      background: linear-gradient(145deg, #161c33 0%, #0d1120 100%);
      border: 2px solid #3a456e;
      border-radius: 16px;
      padding: 40px 30px;
      width: 320px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), inset 0 2px 10px rgba(255, 255, 255, 0.05);
      animation: slideUpFade 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .result-title {
      font-size: 28px;
      font-weight: 800;
      margin-bottom: 5px;
      text-align: center;
      text-shadow: 0 0 15px currentColor;
    }

    .result-subtitle {
      font-size: 14px;
      color: #8892b0;
      margin-bottom: 25px;
    }

    .rank-badge {
      font-size: 54px;
      font-weight: 900;
      font-style: italic;
      margin-bottom: 20px;
      text-shadow: 0 0 20px currentColor;
    }

    .stat-grid {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 30px;
    }

    .stat-item {
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-item span {
      font-size: 11px;
      color: #aaa;
      margin-bottom: 4px;
    }

    .stat-item b {
      font-size: 16px;
      color: #fff;
    }

    .result-btns {
      display: flex;
      gap: 10px;
      width: 100%;
    }

    .result-btns button {
      flex: 1;
      padding: 14px 0;
      font-size: 14px;
      border-radius: 8px;
    }

    /* --- ë©”ì¸ ë©”ë‰´ ì „ìš© ì „ìˆ  ëª¨ë‹ˆí„° ë°°ê²½ --- */
    .main-menu-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #05070a;
      /* ì „ìˆ  ê·¸ë¦¬ë“œ(ê²©ì)ì™€ ë°©ì‚¬í˜• ê·¸ë¼ë°ì´ì…˜ */
      background-image:
        radial-gradient(circle at 50% 50%, rgba(30, 45, 90, 0.4) 0%, rgba(5, 7, 10, 1) 90%),
        linear-gradient(rgba(122, 166, 255, 0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(122, 166, 255, 0.08) 1px, transparent 1px);
      background-size: 100% 100%, 50px 50px, 50px 50px;
      background-position: center center;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    /* ë ˆì´ì € ìŠ¤ìº”ë¼ì¸ ì• ë‹ˆë©”ì´ì…˜ */
    .main-menu-bg::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(to bottom, transparent, rgba(122, 166, 255, 0.15) 50%, transparent);
      transform: rotate(30deg);
      animation: scanline 7s linear infinite;
      pointer-events: none;
    }

    @keyframes scanline {
      0% {
        transform: translateY(-100%) rotate(30deg);
      }

      100% {
        transform: translateY(100%) rotate(30deg);
      }
    }

    .main-title {
      color: #fff;
      font-size: 56px;
      font-weight: 900;
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 6px;
      text-shadow: 0 0 10px #7aa6ff, 0 0 20px #7aa6ff, 0 0 40px #2a3566;
      z-index: 1;
      text-align: center;
    }

    .main-subtitle {
      color: #8892b0;
      font-size: 14px;
      margin-bottom: 50px;
      letter-spacing: 4px;
      z-index: 1;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="wrap layout">
    <div id="mainMenu" class="main-menu-bg">
      <h1 class="main-title">TOWER<br>DEFENSE</h1>
      <div class="main-subtitle">TACTICAL ENGAGEMENT PROTOCOL</div>

      <div style="display:flex; flex-direction:column; align-items:center; gap:20px; z-index: 1;">
        <button id="btnShowRanking"
          style="width:200px; padding:16px 30px; font-size:16px; font-weight:bold; border-radius:8px; background:rgba(204,153,0,0.8); color:#fff; border:2px solid #ffcc00; box-shadow: 0 0 20px rgba(255,204,0,0.4); backdrop-filter:blur(5px);">
          ğŸ† RANKING
        </button>
        <button id="btnResume"
          style="width:200px; padding:16px 30px; font-size:16px; font-weight:bold; border-radius:8px; background:rgba(42,53,102,0.8); color:#fff; border:2px solid #7aa6ff; box-shadow: 0 0 20px rgba(122,166,255,0.4); display:none; backdrop-filter:blur(5px);">
          RESUME
        </button>
        <button id="btnNewGame"
          style="width:200px; padding:16px 30px; font-size:16px; font-weight:bold; border-radius:8px; background:rgba(74,31,31,0.8); color:#ffcccc; border:2px solid #ff4d4d; box-shadow: 0 0 20px rgba(255,77,77,0.4); backdrop-filter:blur(5px);">
          NEW START
        </button>
      </div>
    </div>

    <!-- Ranking Modal -->
    <div id="rankingModal"
      style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(10,12,20,0.95); backdrop-filter:blur(10px); z-index:9500; display:none; flex-direction:column; justify-content:flex-start; align-items:center; padding-top:40px;">
      <h2
        style="color:#ffcc00; font-size:32px; margin-bottom:20px; text-shadow:0 0 15px rgba(255,204,0,0.4); letter-spacing:2px;">
        ğŸ† HALL OF FAME</h2>
      <div id="rankingList"
        style="width:340px; max-height:60dvh; overflow-y:auto; background:rgba(0,0,0,0.4); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:15px; display:flex; flex-direction:column; gap:8px;">
        <div style="text-align:center; color:#888; padding:20px;">ë­í‚¹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
      </div>
      <button id="btnCloseRanking"
        style="margin-top:25px; padding:12px 30px; font-size:16px; font-weight:bold; border-radius:8px; background:rgba(42,47,76,0.8); color:#fff; border:1px solid #7aa6ff;">
        ë‹«ê¸°
      </button>
    </div>

    <!-- Finisher Modal -->
    <div id="finisherModal"
      style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(15,18,32,0.85); backdrop-filter:blur(10px); z-index:900; display:none; flex-direction:column; justify-content:center; align-items:center; opacity:0; transition: opacity 0.3s ease;">
      <h2 style="color:#ffcc00; font-size:32px; margin-bottom:20px; text-shadow:0 0 15px rgba(255,204,0,0.4);">ğŸ”¥ í•„ì‚´ê¸° ì„ íƒ
      </h2>
      <div id="finisherCards" style="display:flex; gap:20px;">
        <!-- Card A (HP) -->
        <button id="cardFinisherHP"
          style="width:160px; padding:20px; background:#4a1f1f; border:2px solid #ff4d4d; border-radius:12px; color:#ffcccc; display:flex; flex-direction:column; gap:10px; cursor:pointer; align-items:center; transition: transform 0.2s;">
          <b style="font-size:18px; color:#ff4d4d;">HP ìŠ¤íŒ€íŒ©</b>
          <div style="font-size:12px; color:#ff9999; text-align:center;">
            íƒ€ì›Œ ê³µì† 1.35x<br>ì‚¬ê±°ë¦¬ 1.06x<br>(ë³´ìŠ¤ì „ íŒ¨ë„í‹° 70%)
          </div>
          <div style="font-size:14px; color:#ffcc00;">ì§€ì†: 6.0ì´ˆ</div>
          <div style="font-size:14px; color:#ff4d4d; font-weight:bold;">ë¹„ìš©: HP -3</div>
        </button>
        <!-- Card B (Gold) -->
        <button id="cardFinisherGold"
          style="width:160px; padding:20px; background:#4a3f1f; border:2px solid #ffcc00; border-radius:12px; color:#ffeecc; display:flex; flex-direction:column; gap:10px; cursor:pointer; align-items:center; transition: transform 0.2s;">
          <b style="font-size:18px; color:#ffcc00;">ê³¨ë“œ ë¶€ìŠ¤íŠ¸</b>
          <div style="font-size:12px; color:#ffdd99; text-align:center;">
            íƒ€ì›Œ ê³µì† 1.20x<br>ì‚¬ê±°ë¦¬ ë³´ë„ˆìŠ¤ ì—†ìŒ
          </div>
          <div style="font-size:14px; color:#ffcc00;">ì§€ì†: 5.0ì´ˆ</div>
          <div id="textFinisherGoldCost" style="font-size:14px; color:#ffd700; font-weight:bold;">ë¹„ìš©: ê³„ì‚°ì¤‘...</div>
        </button>
      </div>
      <button id="btnCancelFinisher"
        style="margin-top:30px; padding:10px 20px; border-radius:8px; background:#2a2f4c; color:#fff; border:1px solid #4a5568;">ì·¨ì†Œ
        (ESC)</button>
    </div>

    <div id="resultModal">
      <div class="result-box" id="resultBox">
        <div class="result-title" id="resTitle">W100 FAILURE</div>
        <div class="result-subtitle" id="resSub">System Overloaded...</div>
        <div class="rank-badge" id="resRank">C</div>

        <div class="stat-grid">
          <div class="stat-item"><span>ğŸŒŠ ë„ë‹¬ ì›¨ì´ë¸Œ</span><b id="resWave">100</b></div>
          <div class="stat-item"><span>â­ ìµœê³  ê°•í™”</span><b id="resMaxLevel">0</b></div>
          <div class="stat-item"><span>ğŸ’° ëˆ„ì  ê³¨ë“œ</span><b id="resGold" style="color:#ffd700;">0G</b></div>
          <div class="stat-item"><span>ğŸ—ï¸ ê±´ì„¤ íƒ€ì›Œ</span><b id="resTowers">0</b></div>
        </div>

        <input type="text" id="playerName" placeholder="AAA" maxlength="3" autocomplete="off"
          oninput="this.value = this.value.toUpperCase().replace(/[^A-Z]/g, '')"
          style="width:100%; padding:12px; margin-bottom:20px; background:rgba(0,0,0,0.4); border:1px solid #556; border-radius:8px; color:#fff; font-size:16px; text-align:center; outline:none;" />

        <div class="result-btns">
          <button id="btnResNew" style="background:#2a3566; border-color:#7aa6ff;">NEW START</button>
          <button id="btnResMain" style="background:#2c4a6e; border-color:#7aa6ff; color:#fff;">ë­í‚¹ ë“±ë¡</button>
        </div>
      </div>
    </div>


    <div id="waveProgressBar">
      <div id="waveProgressFill"></div>
    </div>
    <div class="canvas-container" id="canvasContainer">
      <canvas id="c" class="game" width="540" height="816"></canvas>
      <div id="floatLogContainer"></div>
      <div id="toast"></div>
    </div>

    <div class="panel ui">
      <div class="top-bar" id="topStat"><span>ì¤€ë¹„ì¤‘...</span></div>

      <!-- ë°°ì† ì œì–´ ë²„íŠ¼ (ì ˆëŒ€ ìœ„ì¹˜) -->
      <div style="position:absolute; top:8px; right:8px; z-index:100; display:flex; align-items:center;">
        <button id="btnSpeed"
          style="background:#2a2f4c; border-color:#4a5568; padding:4px 8px; font-size:12px; font-weight:bold; border-radius:4px; margin-right:8px;">
          â© 1x
        </button>
        <button id="btnFinisher"
          style="background:#4a1f1f; border-color:#ff4d4d; color:#ffcccc; padding:4px 8px; font-size:12px; font-weight:bold; border-radius:4px; opacity:0.5; pointer-events:none;">
          ğŸ”¥ í•„ì‚´ê¸°
        </button>
      </div>

      <div class="controls-grid">
        <button id="t1">ë¨¸ì‹ ê±´<span class="desc">ë¹ ë¥¸ ì—°ì‚¬</span><span class="cost">50G</span></button>
        <button id="t2">ìºë…¼<span class="desc">ë²”ìœ„ ê³µê²©</span><span class="cost">80G</span></button>
        <button id="t3">ìŠ¬ë¡œìš°<span class="desc">ì´ë™ ì €í•˜</span><span class="cost">70G</span></button>

        <!-- Col 1 (ì¢Œí•˜ë‹¨): íŒë§¤, ê°•í™” -->
        <div style="grid-column:1; grid-row:2; display:flex; gap:4px;">
          <button id="sell" style="flex:1;">íŒë§¤</button>
          <button id="upgrade" style="flex:1;">ê°•í™”</button>
        </div>

        <!-- Col 2 (ì¤‘ì•™í•˜ë‹¨): ë½‘ê¸°, ì˜¬ì¸ -->
        <div style="grid-column:2; grid-row:2; display:flex; gap:4px;">
          <button id="buyUp"
            style="flex:1; background:#2a1f3d; border-color:#9d4edd; color:#e0c3fc; font-size:11px; line-height:1.2; padding:2px;">
            ê°•í™”Pë½‘ê¸°<br><span class="cost" style="font-size:9px; opacity:0.8; margin-top:0;">40G</span>
          </button>
          <button id="buyAll"
            style="flex:1; background:#4a1f1f; border-color:#ff4d4d; color:#ffcccc; font-size:11px; line-height:1.2; padding:2px;">
            ê°•í™”P All-In<br><span style="font-size:9px; opacity:0.8; margin-top:0;">ë‚¨ì€ ëˆ ì „ë¶€ ì˜¬ì¸</span>
          </button>
        </div>

        <!-- Col 3 (ìš°í•˜ë‹¨): ì‹ ê·œ ì˜ì›… ë½‘ê¸° -->
        <button id="buyHero"
          style="grid-column:3; grid-row:2; background:#361f36; border-color:#ff3366; color:#ffccdd;">
          ì˜ì›… ë½‘ê¸°
          <span class="desc" style="color: #ff99bb;">ë³´ìŠ¤ ì „ìš© í‚¬ëŸ¬</span>
          <span class="cost" style="color:#ff6699; opacity:1;">100P</span>
        </button>

        <button id="startWave"><span>â–¶</span><span>ì›¨ì´ë¸Œ</span></button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const SCHEMA_VERSION = '1.0.0';
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      const container = document.getElementById('canvasContainer');
      const logContainer = document.getElementById('floatLogContainer');

      // ====== 1. ë°ì´í„° ì•„í‚¤í…ì²˜: í•´ìƒë„ ë° ê·¸ë¦¬ë“œ ======
      const LOGICAL_W = 540;
      const LOGICAL_H = 816;
      const ASPECT = LOGICAL_W / LOGICAL_H;

      const gridSize = 48;
      const gridCols = Math.floor(LOGICAL_W / gridSize);
      const gridRows = Math.floor(LOGICAL_H / gridSize);

      const offsetX = (LOGICAL_W - gridCols * gridSize) / 2;
      const offsetY = (LOGICAL_H - gridRows * gridSize) / 2;

      // ====== 2. ë°˜ì‘í˜• ìº”ë²„ìŠ¤ ë¦¬ìŠ¤ì¼€ì¼ë§ (High-DPI) ======
      function resizeCanvas() {
        const availW = container.clientWidth;
        const availH = container.clientHeight;

        let cssW = availW;
        let cssH = availW / ASPECT;

        if (cssH > availH) {
          cssH = availH;
          cssW = cssH * ASPECT;
        }

        const dpr = window.devicePixelRatio || 1;
        canvas.style.width = `${Math.floor(cssW)}px`;
        canvas.style.height = `${Math.floor(cssH)}px`;

        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);

        ctx.scale(dpr * (cssW / LOGICAL_W), dpr * (cssH / LOGICAL_H));
      }
      window.addEventListener('resize', resizeCanvas);
      setTimeout(resizeCanvas, 0);

      // ====== 3. ì…ë ¥ ì¢Œí‘œ ë§¤í•‘ íŒŒì´í”„ë¼ì¸ ======
      function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return { x: 0, y: 0 };

        let cx = evt.clientX;
        let cy = evt.clientY;

        if (evt.touches && evt.touches.length > 0) {
          cx = evt.touches[0].clientX;
          cy = evt.touches[0].clientY;
        } else if (evt.changedTouches && evt.changedTouches.length > 0) {
          cx = evt.changedTouches[0].clientX;
          cy = evt.changedTouches[0].clientY;
        }

        const x = (cx - rect.left) / rect.width * LOGICAL_W;
        const y = (cy - rect.top) / rect.height * LOGICAL_H;
        return { x, y };
      }

      canvas.addEventListener('touchstart', (e) => {
        if (e.cancelable) e.preventDefault();
        handleInput(getMousePos(e));
      }, { passive: false });
      canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
      canvas.addEventListener('mousedown', (e) => handleInput(getMousePos(e)));

      // ====== 4. ë¡œê¹… ì‹œìŠ¤í…œ ======
      function log(msg) {
        const el = document.createElement('div');
        el.className = 'float-log-item';
        el.textContent = msg;
        logContainer.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 3600);
      }

      // ====== 5. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë° ìƒíƒœ ê´€ë¦¬ ======
      const path = [
        { x: 270, y: 24 },  // ğŸ•³ï¸ ë™êµ´(ì¤‘ì•™)ì—ì„œ ìŠ¤í°
        { x: 270, y: 70 },
        { x: 72, y: 70 },  // ì†Œêµ´ ë‚´ë¶€ ì¢Œì¸¡ íš¡ë‹¨
        { x: 468, y: 70 },  // ì†Œêµ´ ë‚´ë¶€ ìš°ì¸¡ íš¡ë‹¨
        { x: 468, y: 150 },  // ì†Œêµ´ íƒˆì¶œ ë° ìœ ì € êµ¬ì—­ ì§„ì…
        { x: 72, y: 150 },
        { x: 72, y: 300 },
        { x: 468, y: 300 },
        { x: 468, y: 450 },
        { x: 72, y: 450 },
        { x: 72, y: 600 },
        { x: 468, y: 600 },
        { x: 468, y: 700 },
        { x: 72, y: 700 },
        { x: 72, y: 780 },
        { x: 270, y: 780 },
        { x: 270, y: LOGICAL_H }
      ];

      function dist(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx, dy); }

      const OVERCLOCK_WAVES = [1, 5];
      const OVERCLOCK_TRIGGER_PROGRESS = 0.35;
      const OVERCLOCK_DURATION = 3.5;
      const OVERCLOCK_FR_MULT = 1.35;
      const OVERCLOCK_RANGE_MULT = 1.06;
      const OVERCLOCK_KILL_GOLD_MULT = 0.92;
      const OVERCLOCK_INTERNAL_CD = 15.0;
      const SYNERGY_FREEZE_MIN_WAVE = 6;

      const MG_STACK_WINDOW = 2.0;
      const MG_VULN_DURATION = 3.0;
      const MG_VULN_CD = 4.0;
      const MG_STACKS_NORMAL = 10;
      const MG_STACKS_TANK = 8;
      const MG_STACKS_BOSS = 12;
      const MG_VULN_MULT_NORMAL = 1.15;
      const MG_VULN_MULT_TANK = 1.20;
      const MG_VULN_MULT_BOSS = 1.08;

      const FINISHER_HP_COST = 3;
      const FINISHER_HP_DUR = 6.0;
      const FINISHER_HP_FR = 1.35;
      const FINISHER_HP_RANGE = 1.06;
      const FINISHER_BOSS_DAMP = 0.70;
      const FINISHER_HP_KILL_GOLD_MULT = 0.90;

      const FINISHER_GOLD_BASE = 120;
      const FINISHER_GOLD_PER_WAVE = 10;
      const FINISHER_GOLD_WALLET_PCT = 0.35;
      const FINISHER_GOLD_DUR = 5.0;
      const FINISHER_GOLD_FR = 1.20;
      const FINISHER_GOLD_RANGE = 1.00;
      const FINISHER_GOLD_KILL_GOLD_MULT = 0.92;

      // --- HERO SCALING ---
      const HERO_S_ADD = 1;
      const HERO_SS_ADD = 2;
      const HERO_S_MAX_OFFSET = 2;
      const HERO_SS_MAX_OFFSET = 3;

      // --- JIT Synergy Tips ---
      let hintFlags = {
        freezeTriggeredOnce: false, vulnTriggeredOnce: false,
        freezeHintShown: false, vulnHintShown: false,
        checkpointW6Shown: false, checkpointW11Shown: false, checkpointW19Shown: false,
        remindFreezeAfterW20Shown: false, remindVulnAfterW20Shown: false
      };
      try {
        const _saved = localStorage.getItem('defenseHintFlags_v1');
        if (_saved) hintFlags = Object.assign(hintFlags, JSON.parse(_saved));
      } catch (e) { }
      function saveHints() { localStorage.setItem('defenseHintFlags_v1', JSON.stringify(hintFlags)); }

      let toastTimer = null;
      let lastToastMsg = "";
      let lastToastTime = 0;
      function showToast(msg, ms = 4000) {
        if (msg === lastToastMsg && (Date.now() - lastToastTime) < 3000) return;
        lastToastMsg = msg; lastToastTime = Date.now();
        const toast = document.getElementById('toast');
        if (!toast) return;

        // textContentë¥¼ innerHTMLë¡œ êµì²´í•˜ì—¬ <br> íƒœê·¸ í—ˆìš©
        toast.innerHTML = msg;

        toast.style.display = 'block';
        void toast.offsetWidth; // force reflow
        toast.classList.add('show');
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => { if (!toast.classList.contains('show')) toast.style.display = 'none'; }, 300);
        }, ms);
      }
      // -------------------------

      const getDeviceInfo = () => {
        const ua = navigator.userAgent;
        const isMobile = /Mobile|Android|iP(hone|ad)/i.test(ua);
        return {
          ua_full: ua,
          browser: /Chrome/i.test(ua) ? 'Chrome' : /Safari/i.test(ua) ? 'Safari' : /Firefox/i.test(ua) ? 'Firefox' : 'Other',
          engine: /AppleWebKit/i.test(ua) ? 'AppleWebKit' : 'Other',
          os: /Android/i.test(ua) ? 'Android' : /iPhone|iPad/i.test(ua) ? 'iOS' : /Windows/i.test(ua) ? 'Windows' : 'Mac',
          platform: isMobile ? 'MOBILE' : 'DESKTOP',
          screen: `${window.innerWidth}x${window.innerHeight}`,
          control: ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? 'TOUCH' : 'MOUSE'
        };
      };

      const G = {
        gameState: 'MENU', isTutorialDone: false,
        gold: 250, lives: 20, wave: 0, inWave: false, time: 0,
        gameSpeed: 1, // Time Scaling 1~3x
        upgradePoints: 1, // Start with 1 Point
        enemies: [], towers: [], projectiles: [], floatTexts: [],
        mode: 'place', selectedTowerType: 1, pendingHero: null,
        previewTower: null,
        spawnPlan: null, spawnCursor: 0, killedThisWave: 0,
        totalSpawnCount: 0, currentFinishedCount: 0, // Progress State
        globalRangeDebuff: false, // W90 Boss Effect

        // Auto Overclock State
        overclockActive: false,
        overclockUntil: 0,
        overclockUsedThisWave: false,
        overclockCooldownUntil: 0,

        // Finisher State
        finisherUsedThisWave: false,
        finisherActive: false,
        finisherType: null,
        finisherUntil: 0,
        finisherFRMult: 1,
        finisherRangeMult: 1,
        finisherKillGoldMult: 1,
        currentFinisherGoldCost: 0,
        // ğŸ‘‡ ì—¬ê¸°ì— ì‹ ê·œ ì½”ë“œ ì¶”ê°€!
        rock: { available: true, active: false, timer: 0, duration: 10.0 },

        ui: {
          btnSpeed: document.getElementById('btnSpeed'),
          btnFinisher: document.getElementById('btnFinisher'),
          finisherModal: document.getElementById('finisherModal'),
          cardFinisherHP: document.getElementById('cardFinisherHP'),
          cardFinisherGold: document.getElementById('cardFinisherGold'),
          textFinisherGoldCost: document.getElementById('textFinisherGoldCost'),
          btnCancelFinisher: document.getElementById('btnCancelFinisher'),
          t1: document.getElementById('t1'), t2: document.getElementById('t2'), t3: document.getElementById('t3'),
          startWave: document.getElementById('startWave'), sell: document.getElementById('sell'),
          upgrade: document.getElementById('upgrade'), topStat: document.getElementById('topStat'),
          buyUp: document.getElementById('buyUp'),
          buyAll: document.getElementById('buyAll'), // All-In ë²„íŠ¼ ê°ì²´ ìºì‹± ì¶”ê°€
          buyHero: document.getElementById('buyHero'), // ì‹ ê·œ: ì˜ì›… ë½‘ê¸°
          progressFill: document.getElementById('waveProgressFill'), // Cached DOM
        },

        // --- ENDING TRACKER ---
        endingActive: false,
        endingType: null,
        endingPhase: 0,
        endingTimer: 0,
        endingStats: {},
        hiddenEndingLabel: "",
        statsFreezeCount: 0,
        statsVulnCount: 0,
        statsFinisherCount: 0,

        // --- ANALYTICS ---
        playStartTime: 0, retryCount: 0,
        buildCount: 0, sellCount: 0, gachaCount: 0,
        deathPos: { x: 0, y: 0 }, deathReason: ""
      };

      // Economy Guard Helper
      function addRewardGold(e) {
        let totalMult = 1;
        if (G.overclockActive) totalMult *= OVERCLOCK_KILL_GOLD_MULT;
        if (G.finisherActive) totalMult *= G.finisherKillGoldMult;
        let reward = Math.floor(e.reward * totalMult);
        G.gold += reward;
        addFloatText(`+${reward}`, e.x, e.y);
      }

      // Remove local getGachaCost if it exists (Cleanup)

      // --- ìˆ˜ì • í›„ TOWER_TYPES ë°ì´í„° ì•„í‚¤í…ì²˜ ---
      const TOWER_TYPES = {
        1: {
          name: 'ë¨¸ì‹ ê±´',
          cost: 50,
          range: 130,    // ì‚¬ê±°ë¦¬ ëŒ€í­ ìƒí–¥ (ë¨¼ì € ë•Œë¦¼)
          fireRate: 0.95, // ê³µê²© ì†ë„ 2ë°° ìƒí–¥ (ë”°ë‹¤ë‹¹!)
          damage: 8,    // ì†ë„ ëŒ€ì‹  ë‹¨ë°œ ë°ë¯¸ì§€ ë¯¸ì„¸ ì¡°ì •
          aoe: 0,
          slow: 0,
          color: '#7aa6ff'
        },
        2: {
          name: 'ìºë…¼',
          cost: 80,
          range: 110,    // ì‚¬ê±°ë¦¬ í•˜í–¥ (ê°€ê¹Œì´ ì™€ì•¼ ì¨)
          fireRate: 0.35, // ê³µê²© ì†ë„ í•˜í–¥ (í•œ ë°œ í•œ ë°œì´ ë¬µì§í•¨)
          damage: 24,    // ê´‘ì—­ ë°ë¯¸ì§€ ìœ ì§€
          aoe: 85,       // í­ë°œ ë²”ìœ„ ë¯¸ì„¸ ìƒí–¥
          slow: 0,
          color: '#ffb86b'
        },
        3: {
          name: 'ìŠ¬ë¡œìš°',
          cost: 70,
          range: 120,
          fireRate: 0.55,
          damage: 8,
          aoe: 0,
          slow: 0.45,
          color: '#85ffb3'
        },
      };

      const ENEMY_TYPES = {
        normal: { name: 'ì¼ë°˜', hp: 35, speed: 70, reward: 8, color: '#d7d9ff' },
        fast: { name: 'ë¹ ë¦„', hp: 25, speed: 150, reward: 7, color: '#ff7aa6' },
        tank: { name: 'ë‹¨ë‹¨', hp: 140, speed: 65, reward: 13, color: '#b6ff7a' },
        boss: { name: 'BOSS', hp: 500, speed: 50, reward: 80, color: '#ff3333' }
      };

      // ====== Boss Handler ======
      // ====== Boss Handler ======
      const BossHandler = {
        init: function (e, wave) {
          e.bossType = wave - (wave % 10); // W12 -> W10 Boss Type
          // W100 Special Handling
          if (wave >= 100) e.bossType = 100;

          // Trait Init
          e.slowEvadeCount = 3; // ìƒíƒœ ì´ìƒ í™•ì • íšŒí”¼ íšŸìˆ˜ ì´ˆê¸°í™”
          if (e.bossType === 50) { e.isStealth = false; e.stealthTimer = 0; }
          if (e.bossType === 70) { e.dashTimer = 0; }
          if (e.bossType === 40) { e.regenTimer = 0; }
          if (e.bossType === 100) { e.traitTimer = 0; e.activeTrait = null; }
        },

        applyTick: function (e, dt, G) {
          if (!e.isBoss) return;
          e.currentSpeed = e.speed; // Reset temp speed

          const type = (e.bossType === 100 && e.activeTrait) ? e.activeTrait : e.bossType;

          // W20 (Haste)
          if (type === 20 && e.hp < e.hpMax * 0.5) {
            e.currentSpeed = e.speed * 2;
            e.statusText = "HASTE";
          }

          // W40 (Regen)
          if (type === 40) {
            e.regenTimer = (e.regenTimer || 0) + dt;
            if (e.regenTimer >= 2.5) {
              e.hp = Math.min(e.hpMax, e.hp + (e.hpMax * 0.01));
              e.regenTimer = 0;
              addFloatText("+Regen", e.x, e.y - 10);
            }
            e.statusText = "REGEN";
          }

          // W50 (Stealth): 5s Visible / 2s Stealth
          if (type === 50) {
            e.stealthTimer = (e.stealthTimer || 0) + dt;
            const cycle = e.stealthTimer % 7;
            e.isStealth = cycle > 5;
            if (e.isStealth) e.statusText = "STEALTH";
          } else if (e.bossType === 50) {
            // If W100 switches off 50, reset stealth
            e.isStealth = false;
          }

          // W70 (Dash): 4s Interval, 50px Forward
          if (type === 70) {
            e.dashTimer = (e.dashTimer || 0) + dt;
            if (e.dashTimer >= 4.0) {
              e.dashReq = true; // Trigger Dash in Tick
              e.dashTimer = 0;
              e.statusText = "DASH";
            }
          }

          // W100 (Final): Random Trait Every 5s
          if (e.bossType === 100) {
            e.traitTimer = (e.traitTimer || 0) + dt;
            if (e.traitTimer >= 5.0) {
              const traits = [20, 30, 40, 50, 60, 70, 80, 90];
              e.activeTrait = traits[Math.floor(Math.random() * traits.length)];
              e.traitTimer = 0;
              addFloatText(`Pattern: W${e.activeTrait}`, e.x, e.y - 30);

              // Reset states on switch
              e.isStealth = false;
            }
          }
        },

        calcDamage: function (e, dmg, t) {
          if (!e.isBoss) return dmg;
          let finalDmg = dmg;
          const type = (e.bossType === 100 && e.activeTrait) ? e.activeTrait : e.bossType;

          // W30 (Phys Resist)
          if (type === 30 && t.type === 1) {
            finalDmg *= 0.5;
            addFloatText("Block", e.x, e.y - 10);
          }
          // W60 (Hardness)
          if (type === 60) {
            finalDmg = Math.max(1, finalDmg - 10);
          }
          // W80 (Absorb)
          if (type === 80) {
            e.radius = Math.min((e.radius || 16.5) + 0.5, 30);
            e.speed = Math.max(e.speed * 0.99, 10);
            addFloatText("Absorb", e.x, e.y - 10);
          }
          return finalDmg;
        },

        onDeath: function (e, G) {
          if (!e.isBoss) return;
          const type = e.bossType;

          // W10 (Split)
          if (type === 10) {
            for (let i = 0; i < 3; i++) spawnEnemy({ type: 'normal', hpMul: 1 }, e.x + (Math.random() * 20 - 10), e.y, e.pathIndex);
            addFloatText("Split!", e.x, e.y);
          }

          if (e.bossType === 100) {
            G.inWave = false;
            log("ğŸ‰ 100 ì›¨ì´ë¸Œ í´ë¦¬ì–´! ì¶•í•˜í•©ë‹ˆë‹¤!");
            triggerEnding('WIN');
          }
        }
      };

      // Upgrade Cost is now strictly Points based on level
      function getUpgradeCost(t) { return t.level; }

      // Dynamic Gacha Cost (Global Scope)
      function getGachaCost() {
        // Wave 1ì´ë©´ 1G, Wave 10ì´ë©´ 10G. 
        // ë‹¨, Wave ì‹œì‘ ì „(0)ì¼ ê²½ìš° ìµœì†Œ ë¹„ìš© 20ë¡œ ì˜ˆì™¸ ì²˜ë¦¬
        return Math.max(20, G.wave);
      }

      function getSellValue(t) {
        const base = TOWER_TYPES[t.type].cost;
        return Math.floor(base * 0.6 + (t.level - 1) * base * 0.2);
      }
      function applyUpgrade(t) {
        t.level++;
        t.damage *= 1.12;
        t.range *= 1.01;
        t.fireRate *= 1.025;
        t.cooldown = 0;
      }

      // Gacha Logic
      function buyUpgradePoint() {
        const cost = getGachaCost();
        if (G.gold < cost) { log(`ğŸ’¸ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤ (${cost}G)`); return; }

        G.gold -= cost;
        const r = Math.random();
        let earned = 0;
        let msg = '';

        if (r < 0.30) {
          earned = 0;
          msg = 'ê°•í™”P ë½‘ê¸° ì‹¤íŒ¨... (0P)';
        } else if (r < 0.80) {
          earned = 1;
          msg = 'ê°•í™”P 1 íšë“!';
        } else if (r < 0.92) {
          earned = 2;
          msg = 'ëŒ€ì„±ê³µ! ê°•í™”P 2 íšë“!';
        } else {
          // Jackpot 3~10
          earned = Math.floor(Math.random() * 8) + 3;
          msg = `ë¯¸ì³¤ë‹¤!! ê°•í™”P ${earned} íšë“!!`;
        }

        if (earned > 0) {
          G.upgradePoints += earned;
          // Visual Feedback for Gacha
          addFloatText(`+${earned}P`, LOGICAL_W / 2, LOGICAL_H / 2);
        } else {
          addFloatText(`ê½...`, LOGICAL_W / 2, LOGICAL_H / 2);
        }
        log(msg);
        saveGameState(); log('ğŸ’¾ í™•ë¥  ë³€ë™ìœ¼ë¡œ ì¸í•´ ê°•ì œ ì €ì¥ë¨.');
        updateUI();
      }

      // ì‹ ê·œ ì¶”ê°€: All-in íŠ¸ëœì­ì…˜ í•¨ìˆ˜
      function buyUpgradeAllIn() {
        const cost = getGachaCost();
        if (G.gold < cost) {
          log(`ğŸ’¸ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤ (${cost}G)`);
          return;
        }

        const count = Math.floor(G.gold / cost);
        let totalEarned = 0;
        let usedGold = count * cost;
        let failStreak = 0; // [ì‹ ê·œ] ì—°ì† ì‹¤íŒ¨ ì¹´ìš´í„° íŒŒì´í”„ë¼ì¸

        G.gold -= usedGold;

        // êµ¬ë§¤ íšŸìˆ˜ë§Œí¼ í™•ë¥  ì—°ì‚° ì¼ê´„ ì²˜ë¦¬
        for (let i = 0; i < count; i++) {
          const r = Math.random();
          if (r < 0.30) {
            failStreak++;
            // [ì‹ ê·œ] 3ì—°ì† ê½ ë°œìƒ ì‹œ, ì‹œìŠ¤í…œ ê°•ì œ ê°œì… (ì²œì¥ ì‹œìŠ¤í…œ)
            if (failStreak >= 3) {
              totalEarned += 1;
              failStreak = 0; // ì¹´ìš´í„° ì´ˆê¸°í™”
            }
          } else {
            failStreak = 0; // ì„±ê³µ ì‹œ ì¹´ìš´í„° ì´ˆê¸°í™”
            if (r < 0.80) {
              totalEarned += 1;
            } else if (r < 0.92) {
              totalEarned += 2;
            } else {
              totalEarned += Math.floor(Math.random() * 8) + 3;
            }
          }
        }

        if (totalEarned > 0) {
          G.upgradePoints += totalEarned;
          addFloatText(`Total +${totalEarned}P`, LOGICAL_W / 2, LOGICAL_H / 2);
          log(`ğŸ”¥ ì˜¬ì¸! ${count}íšŒ ë½‘ê¸°: ì´ ${totalEarned}P íšë“!`);
        } else {
          addFloatText(`ì „ë¶€ ê½...`, LOGICAL_W / 2, LOGICAL_H / 2);
          log(`ğŸ˜­ ì˜¬ì¸! ${count}íšŒ ë½‘ê¸°: ì „ë¶€ ê½ì…ë‹ˆë‹¤...`);
        }
        saveGameState(); log('ğŸ’¾ í™•ë¥  ë³€ë™ìœ¼ë¡œ ì¸í•´ ê°•ì œ ì €ì¥ë¨.');
        updateUI();
      }



      function makeWavePlan(w) {
        // 1. ìœ ì € ì²´ê° ë°ì´í„°ë¥¼ ë°˜ì˜í•œ 10% ìŠ¤ì¼€ì¼ë§ íŒŒì´í”„ë¼ì¸
        let baseHpMul = 1;
        if (w <= 40) {
          // W1~W40: 10% ë³µë¦¬ ì„±ì¥ (ìœ ì € ê²€ì¦ ì™„ë£Œ ìŠ¤ìœ—ìŠ¤íŒŸ)
          baseHpMul = Math.pow(1.10, w - 1);
        } else {
          // W41 ì´ìƒ: W40 ê¸°ì¤€ì (ì•½ 41ë°°)ì—ì„œ 5% ì™„í™”ëœ ë³µë¦¬ ì ìš©
          baseHpMul = Math.pow(1.10, 39) * Math.pow(1.09, w - 40);
        }

        // 2. ë³´ìŠ¤ ì›¨ì´ë¸Œ ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜ (ì—­ì²´ê° ë°©ì§€)
        if (w % 10 === 0 && w <= 100) {
          // [ìˆ˜ì • í¬ì¸íŠ¸] ê³±ì—°ì‚°(bossTierMult)ì„ ì œê±°í•˜ê³  ì„ í˜• ìƒìˆ˜ë¥¼ ë”í•˜ëŠ” êµ¬ì¡°ë¡œ ë³€ê²½
          const hybridBossMul = (baseHpMul * 1.2) + (w * 0.1);
          return [{ at: 1.0, type: 'boss', isBoss: true, bossType: w, hpMul: hybridBossMul }];
        }

        const plan = [];
        const base = 8 + Math.floor(w * 1.5);
        const fast = Math.max(0, Math.floor((w - 2) * 1.0));
        const tank = Math.max(0, Math.floor((w - 3) * 0.6));
        let t = 0;
        const add = (type, c, gap) => { for (let i = 0; i < c; i++) { plan.push({ at: t, type }); t += gap; } };

        add('normal', base, 0.7);
        if (fast > 0) { t += 1.0; add('fast', fast, 0.9); }
        if (tank > 0) { t += 2.0; add('tank', tank, 1.8); }

        if (w % 5 === 0 && w % 10 !== 0) {
          // [ìˆ˜ì • í¬ì¸íŠ¸] ì •ì˜ˆ ëª¬ìŠ¤í„°ìš© í•˜ì´ë¸Œë¦¬ë“œ ìŠ¤ì¼€ì¼ë§ ì ìš©
          const hybridMiniBossMul = (baseHpMul * 1.1) + (w * 0.05);
          const eliteSquad = [];
          for (let i = 0; i < 10; i++) {
            eliteSquad.push({
              at: 1.0 + (i * 2.0),
              type: 'tank',
              isMiniBoss: true,
              hpMul: hybridMiniBossMul,
              rewardMul: 4
            });
          }
          return eliteSquad;
        }

        const rewardMul = 1 + Math.floor((w - 1) / 10) * 0.5;
        return plan.map(p => ({ ...p, hpMul: baseHpMul, rewardMul }));
      }

      function startWave() {
        if (G.inWave) return;

        // [ìˆ˜ì • ì™„ë£Œ]: íŠœí† ë¦¬ì–¼ì„ ì•„ì§ ê¹¨ì§€ ì•Šì•˜ì„ ë•Œë§Œ í—ˆìˆ˜ì•„ë¹„ ì†Œí™˜
        if (G.wave === 0 && !G.isTutorialDone) { G.inWave = true; G.killedThisWave = 0; waveStartTime = G.time; G.spawnPlan = [{ at: 0.5, type: 'normal', hpMul: 0.5, speed: 25, isTutorial: true }]; G.spawnCursor = 0; G.totalSpawnCount = 1; G.currentFinishedCount = 0; G.previewTower = null; updateUI(); return; }

        G.wave++; G.inWave = true; G.killedThisWave = 0;
        G.spawnPlan = makeWavePlan(G.wave); G.spawnCursor = 0;

        // --- Wave Checkpoint Hints ---
        if (G.wave === 6 && !hintFlags.checkpointW6Shown) {
          showToast("ğŸ’Œê¿€íŒ:<br>ìŠ¬ë¡œìš°+ìºë…¼ ì¡°í•©ì„ í•œ ë²ˆ ì¨ë³´ì„¸ìš”. (íŒŒë€ ë°•ìŠ¤=ë¹™ê²°)", 5000);
          hintFlags.checkpointW6Shown = true; saveHints();
        }
        if (G.wave === 11 && !hintFlags.checkpointW11Shown) {
          showToast("ğŸ’Œê¿€íŒ:<br>íƒ±ì»¤ê°€ ë‹¨ë‹¨í•˜ë©´ ë¨¸ì‹ ê±´ìœ¼ë¡œ ì·¨ì•½ì„ ë…¸ë ¤ë³´ì„¸ìš”.", 5000);
          hintFlags.checkpointW11Shown = true; saveHints();
        }
        if (G.wave === 19 && !hintFlags.checkpointW19Shown) {
          showToast("ğŸ’Œê¿€íŒ:<br>ë³´ìŠ¤ëŠ” CCë³´ë‹¤ 'ë”œ ì°¬ìŠ¤(ì·¨ì•½)' íƒ€ì´ë°ì´ ì¤‘ìš”!", 5000);
          hintFlags.checkpointW19Shown = true; saveHints();
        }
        if (G.wave >= 21 && G.wave % 10 !== 0) { // skip on boss waves
          if (!hintFlags.freezeTriggeredOnce && !hintFlags.remindFreezeAfterW20Shown) {
            showToast("ì•„ì§ â„ë¹™ê²°ì„ ëª» ë´¤ë‹¤ë©´:<br>ìŠ¬ë¡œìš°(ë ˆì´ë‹¤) + ìºë…¼ ì¡°í•©ì„ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”!", 2600);
            hintFlags.remindFreezeAfterW20Shown = true; saveHints();
          } else if (!hintFlags.vulnTriggeredOnce && !hintFlags.remindVulnAfterW20Shown) {
            showToast("ì•„ì§ ğŸ’¥ì·¨ì•½ì„ ëª» ë´¤ë‹¤ë©´:<br>ë¨¸ì‹ ê±´ì„ íƒ±ì»¤/ë³´ìŠ¤ ìª½ì— ì¶”ê°€í•´ë³´ì„¸ìš”!", 2600);
            hintFlags.remindVulnAfterW20Shown = true; saveHints();
          }
        }

        // Progress Init
        G.totalSpawnCount = G.spawnPlan.length;
        G.currentFinishedCount = 0;

        // Auto Overclock Wave Reset
        G.overclockUsedThisWave = false;
        G.overclockActive = false;
        G.overclockUntil = 0;
        G.overclockCooldownUntil = 0; // Guarantee once-per-wave trigger

        // Finisher Wave Reset
        G.finisherUsedThisWave = false;
        G.finisherActive = false;
        G.finisherUntil = 0;
        G.finisherType = null;
        G.finisherFRMult = 1;
        G.finisherRangeMult = 1;
        G.finisherKillGoldMult = 1;

        waveStartTime = G.time;

        if (G.wave % 10 === 0) log(`âš ï¸ BOSS WAVE ${G.wave}! ì¤€ë¹„í•˜ì„¸ìš”!`);
        else if (G.wave % 5 === 0) log(`ğŸ›¡ï¸ ì •ì˜ˆ ëª¬ìŠ¤í„°ê°€ ë“±ì¥í–ˆìŠµë‹ˆë‹¤!`);
        else log(`âš ï¸ ì›¨ì´ë¸Œ ${G.wave} ì‹œì‘!`);

        G.previewTower = null; updateUI();
      }

      // Supports override for W10 Split
      function spawnEnemy(entry, ovX, ovY, ovIdx, ovTier) {
        const base = ENEMY_TYPES[entry.type];

        // Tier Calculation (Max 3)
        // If override Tier exists (e.g. split minion), use it. Else calc from Wave.
        const tier = ovTier ?? (entry.isBoss ? 1 : Math.min(3, Math.floor((G.wave - 1) / 30) + 1));

        const reward = Math.floor(base.reward * (entry.rewardMul || 1));

        const e = {
          type: entry.type,
          x: ovX ?? path[0].x,
          y: ovY ?? path[0].y,
          pathIndex: ovIdx ?? 0,
          hpMax: base.hp * entry.hpMul,
          hp: base.hp * entry.hpMul,
          speed: base.speed,
          reward: reward * (entry.isBoss ? 7 : 1),
          slowUntil: 0, slowFactor: 0,
          color: base.color, alive: true,
          isBoss: entry.isBoss || false,
          isTutorial: entry.isTutorial || false,
          isMiniBoss: entry.isMiniBoss || false,
          bossType: entry.bossType || 0,
          radius: entry.isBoss ? 16.5 : (entry.isMiniBoss ? 13 : 11),
          tier: tier,
          canSplit: true, // For T3 Normal Split check
          prevX: ovX ?? path[0].x, // For Flipping
          hitTime: -1, // For Hit Flash
          slowResistance: 0, // Boss Slow Resistance

          // Synergy State
          frozenUntil: 0,
          synergyFreezeCdUntil: 0,
          lastSlowedByType: 0,
          lastSlowedAt: 0,

          // T1 Stacking State
          mgStacks: 0,
          mgStackUntil: 0,
          vulnUntil: 0,
          vulnCdUntil: 0
        };

        if (e.isBoss) BossHandler.init(e, G.wave);

        if (e.isMiniBoss) e.speed *= 1.10;

        // Monster Evolution System
        if (G.wave > 10 && G.wave <= 50) {
          // W11-50: Color Evolution
          const hue = (240 + (G.wave - 11) * 5) % 360;
          e.evolutionColor = `hsla(${hue}, 100%, 70%, 0.6)`;
        } else if (G.wave > 50) {
          // W51+: Mutation (Spiked Shapes)
          e.isMutant = true;
          e.mutantColor = `hsla(${(G.wave * 10) % 360}, 100%, 50%, 1)`;
          // Randomize shape sides: 3 (Tri) to 8 (Oct)
          e.mutantSides = 3 + (G.wave % 6);
        }

        G.enemies.push(e);
      }

      function handleInput(pos) {
        if (G.endingActive) {
          handleEndingClick(pos);
          return;
        }
        if (G.gameState !== 'PLAYING') return;
        const gx = Math.floor((pos.x - offsetX) / gridSize);
        const gy = Math.floor((pos.y - offsetY) / gridSize);

        if (gx < 0 || gx >= gridCols || gy < 0 || gy >= gridRows) {
          G.previewTower = null; return;
        }

        const t = G.towers.find(t => t.gx === gx && t.gy === gy);

        if (G.mode === 'place' || G.mode === 'placeHero') {
          if (t) { log('ğŸš« ì´ë¯¸ íƒ€ì›Œê°€ ìˆìŠµë‹ˆë‹¤.'); G.previewTower = null; return; }

          const targetType = G.mode === 'placeHero' ? 1 : G.selectedTowerType;

          if (G.previewTower && G.previewTower.gx === gx && G.previewTower.gy === gy && G.previewTower.type === targetType && Boolean(G.previewTower.isHero) === (G.mode === 'placeHero')) {
            if (G.mode === 'placeHero') {
              placeHeroTower(gx, gy);
              G.previewTower = null;
              setMode('place', 1);
            } else {
              placeTower(gx, gy, G.selectedTowerType);
              G.previewTower = null;
            }
          } else {
            G.previewTower = { gx, gy, type: targetType, isHero: G.mode === 'placeHero', pendingHero: G.pendingHero };
          }
        } else if (G.mode === 'sell' && t) {
          if (!G.isTutorialDone || G.wave === 0) { log('ğŸš« íŠœí† ë¦¬ì–¼ í›ˆë ¨ ì¤‘ì—ëŠ” íƒ€ì›Œë¥¼ íŒë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); G.previewTower = null; return; }
          const v = getSellValue(t); G.gold += v;
          G.towers = G.towers.filter(x => x !== t);
          G.sellCount++; // Analytics hook
          log(`ğŸ’° íŒë§¤ ì™„ë£Œ (+${v}G)`); addFloatText(`+${v}`, t.x, t.y);
          saveGameState();
          G.previewTower = null;
        } else if (G.mode === 'upgrade' && t) {
          // Level Cap Check
          if (t.level >= G.wave + 2) {
            log(`ğŸš« í˜„ì¬ ì›¨ì´ë¸Œ í•œê³„ ë„ë‹¬! (Max Lv.${G.wave + 2})`);
            G.previewTower = null;
            return;
          }

          const c = getUpgradeCost(t); // returns t.level
          if (G.upgradePoints >= c) {
            G.upgradePoints -= c;
            applyUpgrade(t);
            log(`âš¡ ê°•í™” ì„±ê³µ (Lv.${t.level})`); addFloatText('UP!', t.x, t.y - 10);
            saveGameState();
          } else { log(`ğŸ’ ê°•í™” í¬ì¸íŠ¸ ë¶€ì¡± (${c}P í•„ìš”)`); }
          G.previewTower = null;
        } else {
          G.previewTower = null;
        }
        updateUI();
      }

      function placeTower(gx, gy, type) {

        // ë°ì´í„° ì œì•½ ì¡°ê±´: ìƒë‹¨ 2ì¹¸(ì†Œêµ´)ì€ ê±´ì„¤ ë¶ˆê°€ íŒì •
        if (gy < 2) {
          log("ğŸš« ì ì˜ ì†Œêµ´ì—ëŠ” íƒ€ì›Œë¥¼ ê±´ì„¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
          addFloatText("Access Denied", offsetX + gx * gridSize + 24, offsetY + gy * gridSize + 24);
          return;
        }

        const def = TOWER_TYPES[type];
        if (G.gold < def.cost) { log(`ğŸ’¸ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤ (${def.cost}G)`); return; }

        const px = gx * gridSize + gridSize / 2 + offsetX;
        const py = gy * gridSize + gridSize / 2 + offsetY;

        if (isNearPath(px, py, 28)) { log('ğŸš« ì´ë™ ê²½ë¡œ ê·¼ì²˜ì…ë‹ˆë‹¤.'); return; }

        G.gold -= def.cost;
        updateUI();
        G.towers.push({
          gx, gy, type, level: 1,
          x: px, y: py,
          range: def.range, damage: def.damage,
          fireRate: def.fireRate, aoe: def.aoe, slow: def.slow,
          cooldown: 0,
          lastAngle: 0 // State Persistence
        });
        G.buildCount++; // Analytics hook
        log(`ğŸ”¨ ${def.name} ê±´ì„¤ (-${def.cost}G)`);
        addFloatText(`-${def.cost}`, px, py - 10);
        saveGameState();
        updateUI();
      }

      function placeHeroTower(gx, gy) {
        const def = TOWER_TYPES[1]; // T1 ë² ì´ìŠ¤
        const px = gx * gridSize + gridSize / 2 + offsetX;
        const py = gy * gridSize + gridSize / 2 + offsetY;

        if (isNearPath(px, py, 28)) { log('ğŸš« ì´ë™ ê²½ë¡œ ê·¼ì²˜ì…ë‹ˆë‹¤.'); return; }

        const h = G.pendingHero;
        G.isTutorialDone = true;
        updateUI();

        // --- [ì‹ ê·œ ì£¼ì…] ì˜ì›… ë“±ê¸‰ë³„ ë™ì  ìŠ¤ì¼€ì¼ë§(Dynamic Scaling) ì•„í‚¤í…ì²˜ ---
        const baseLevels = G.towers.filter(t => !t.isHero).map(t => t.level).sort((a, b) => b - a);
        const top1 = baseLevels[0] || 1;

        // 1) Compute coreAvg (Top 50% truncated mean, clamped 3..6)
        const n = baseLevels.length;
        const coreCount = Math.min(6, Math.max(3, Math.ceil(n * 0.5)));
        const core = baseLevels.slice(0, coreCount);
        const coreAvg = core.length ? Math.floor(core.reduce((s, v) => s + v, 0) / core.length) : 1;

        // 2) Top 3 Avg
        const top3avg = baseLevels.length >= 3
          ? Math.floor((baseLevels[0] + baseLevels[1] + baseLevels[2]) / 3)
          : (baseLevels.length > 0 ? Math.floor(baseLevels.reduce((s, v) => s + v, 0) / baseLevels.length) : 1);

        let targetLevel = 1;

        if (h.grade === 'A') {
          // Aê¸‰: í˜„ì¬ ë§µì— ì¡´ì¬í•˜ëŠ” ë¹„-ì˜ì›… íƒ€ì›Œ ì¤‘ ìƒìœ„ 5ê°œì˜ í‰ê·  ë ˆë²¨ (ì´ë™í‰ê·  ì¶”ì¢…)
          const top5 = baseLevels.slice(0, 5);
          if (top5.length > 0) {
            const sum = top5.reduce((val, acc) => val + acc, 0);
            targetLevel = Math.max(1, Math.floor(sum / top5.length));
          }
        } else if (h.grade === 'S') {
          if (baseLevels.length > 0) {
            const baseS = Math.max(top3avg + HERO_S_ADD, coreAvg + 1);
            targetLevel = Math.min(baseS, Math.max(1, G.wave + HERO_S_MAX_OFFSET));
          }
        } else if (h.grade === 'SS') {
          if (baseLevels.length > 0) {
            const baseSS = Math.max(top1 + HERO_SS_ADD, coreAvg + 2);
            targetLevel = Math.min(baseSS, Math.max(1, G.wave + HERO_SS_MAX_OFFSET));
          }
        }

        // --- ë ˆë²¨ ê¸°ë°˜ ë³µë¦¬(Compound) ìŠ¤íƒ¯ ì¬ì—°ì‚° ---
        // ì¼ë°˜ íƒ€ì›Œì˜ ë ˆë²¨ì—… ë¡œì§(applyUpgrade)ê³¼ ë™ì¼í•œ ì„±ì¥ë¥ ì„ ì ìš©í•˜ì—¬ ë² ì´ìŠ¤ ìŠ¤íƒ¯ ë»¥íŠ€ê¸°
        const levelMod = targetLevel - 1;
        const scaledDamage = (def.damage * 5) * Math.pow(1.15, levelMod);
        let scaledRange = def.range * Math.pow(1.03, levelMod);
        const scaledFireRate = def.fireRate * Math.pow(1.03, levelMod);

        let aAuraRadius = 250;
        if (h.grade === 'SS') {
          scaledRange *= 1.15;
        } else if (h.grade === 'S') {
          scaledRange *= 1.05;
        } else if (h.grade === 'A') {
          aAuraRadius = Math.min(Math.max(250 + levelMod * 1.2, 250), 320);
        }

        scaledRange = Math.min(scaledRange, 220);

        G.towers.push({
          gx, gy, type: 1, level: targetLevel,
          x: px, y: py,
          range: scaledRange,
          damage: scaledDamage,
          fireRate: scaledFireRate,
          aoe: def.aoe,
          slow: def.slow,
          cooldown: 0,
          lastAngle: 0,
          isHero: true,
          heroGrade: h.grade,
          remainWaves: h.remainWaves,
          globalBurnTimer: 0, // Së“±ê¸‰ ì „ìš©
          ssTrueDmgCdUntil: 0, // SSë“±ê¸‰ ì „ìš©
          aAuraRadius // Aë“±ê¸‰ ì „ìš©
        });

        // [ìˆ˜ì • ì™„ë£Œ] ë“±ê¸‰ë³„ ë©”ì‹œì§€ ë° íŠ¹ì„± ë¶„ê¸° íŒŒì´í”„ë¼ì¸
        let heroName = "";
        let heroAbility = "";

        if (h.grade === 'SS') {
          heroName = "ğŸ”´ [SSê¸‰: ë³´ìŠ¤ ìŠ¬ë ˆì´ì–´]";
          heroAbility = "ë³´ìŠ¤ íƒ€ê²© ì‹œ ì£¼ê¸°ì ìœ¼ë¡œ 'ê³ ì • í”¼í•´(ìƒí•œ)'ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.";
        } else if (h.grade === 'S') {
          heroName = "ğŸŸ¡ [Sê¸‰: ì´ê·¸ë‹ˆìŠ¤ ì— ë²„]";
          heroAbility = "0.5ì´ˆë§ˆë‹¤ ì „ì—­ í™”ì—¼ ë°ë¯¸ì§€. (ë³´ìŠ¤ëŠ” ì•½í™” ì ìš©)";
        } else {
          heroName = "ğŸŸ¢ [Aê¸‰: í”„ë¡œìŠ¤íŠ¸ ê°€ë””ì–¸]";
          heroAbility = `ë°˜ê²½ ${Math.floor(aAuraRadius)}px ë‚´ì˜ ëª¨ë“  ì ì„ 50% ê°ì†ì‹œí‚µë‹ˆë‹¤.`;
        }

        // í†µí•© ë¡œê·¸ ì¶œë ¥ ë° UI ì—…ë°ì´íŠ¸
        log(`${heroName} ê°•ë¦¼! (Lv.${targetLevel} / ìˆ˜ëª…: ${h.remainWaves}W)`);
        log(`ã„´ íŠ¹ì„±: ${heroAbility}`);

        addFloatText(`ğŸš€ ${h.grade} GRADE HERO!`, px, py - 10);

        G.pendingHero = null;
        saveGameState();
        updateUI();
      }

      function buyHeroPoint() {
        const cost = 100;
        if (G.upgradePoints < cost) { log(`ğŸ’ ê°•í™”Pê°€ ë¶€ì¡±í•©ë‹ˆë‹¤ (${cost}P)`); return; }

        G.upgradePoints -= cost;
        // [ìˆ˜ì • ì™„ë£Œ] ëª¨ë“  ì˜ì›…ì˜ ìˆ˜ëª…ì„ 1ë¼ìš´ë“œë¡œ í†µì œ
        const remainWaves = 1;
        const r = Math.random();
        let heroGrade = 'A';
        if (r < 0.2) heroGrade = 'SS';
        else if (r < 0.5) heroGrade = 'S';

        G.mode = 'placeHero';
        G.pendingHero = { grade: heroGrade, remainWaves: remainWaves };
        log(`âœ¨ [${heroGrade}ë“±ê¸‰] ì˜ì›… ëŒ€ê¸° ì¤‘! ì›í•˜ëŠ” ê³³ì— ê±´ì„¤í•˜ì„¸ìš”.`);
        updateUI();
      }

      function isNearPath(x, y, r) {
        for (let i = 0; i < path.length - 1; i++) {
          if (pointToSegmentDistance({ x, y }, path[i], path[i + 1]) <= r) return true;
        }
        return false;
      }
      function pointToSegmentDistance(p, a, b) {
        const vx = b.x - a.x, vy = b.y - a.y, wx = p.x - a.x, wy = p.y - a.y;
        const c1 = vx * wx + vy * wy; if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
        const c2 = vx * vx + vy * vy; if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
        const t = c1 / c2; return Math.hypot(p.x - (a.x + t * vx), p.y - (a.y + t * vy));
      }

      function addFloatText(text, x, y) { G.floatTexts.push({ text, x, y, life: 1.0 }); }


      // ====== 5. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë° ìƒíƒœ ê´€ë¦¬ ìƒë‹¨ì— ì¶”ê°€ ======
      let last = performance.now(); // [êµì •] last ì´ˆê¸°ê°’ ì„ ì–¸
      let waveStartTime = 0;        // [êµì •] waveStartTime ì„ ì–¸


      // --- ENDING SYSTEM (HTML UI ì—°ë™) ---
      function triggerEnding(type) {
        G.gameState = 'GAMEOVER';

        // íƒ€ì›Œ ê°¯ìˆ˜ ê³„ì‚°
        let tCount = 0;
        G.towers.forEach(t => { if (!t.isHero) tCount++; });

        // ëª¨ë‹¬ UI ì—˜ë¦¬ë¨¼íŠ¸ ê°€ì ¸ì˜¤ê¸°
        const modal = document.getElementById('resultModal');
        const box = document.getElementById('resultBox');
        const title = document.getElementById('resTitle');
        const sub = document.getElementById('resSub');
        const rank = document.getElementById('resRank');

        // ë°ì´í„° ë°”ì¸ë”©
        const maxLevel = G.towers.length > 0 ? Math.max(...G.towers.map(t => t.level)) : 0;
        document.getElementById('resWave').innerText = G.wave;
        document.getElementById('resMaxLevel').innerText = maxLevel;
        document.getElementById('resGold').innerText = Math.floor(G.totalGoldEarned || 0) + 'G';
        document.getElementById('resTowers').innerText = tCount;

        // ë­í¬ ê³„ì‚°
        let grade = 'F';
        let gradeColor = '#555';
        if (type === 'WIN') {
          grade = G.lives >= 20 ? 'S' : (G.lives >= 10 ? 'A' : 'B');
          gradeColor = grade === 'S' ? '#ffcc00' : '#7aa6ff';
        } else {
          if (G.wave >= 80) grade = 'A';
          else if (G.wave >= 50) grade = 'B';
          else if (G.wave >= 20) grade = 'C';
          gradeColor = '#ff4d4d';
        }

        rank.innerText = grade;
        rank.style.color = gradeColor;

        if (type === 'WIN') {
          title.innerText = "MISSION CLEAR!";
          title.style.color = "#7aa6ff";
          sub.innerText = "ì™„ë²½í•œ ë°©ì–´ì„ ì…ë‹ˆë‹¤, ì‚¬ë ¹ê´€ë‹˜.";
          box.style.borderColor = "#7aa6ff";
          box.style.boxShadow = "0 15px 40px rgba(0,0,0,0.5), inset 0 0 20px rgba(122,166,255,0.2)";
        } else {
          title.innerText = `W${G.wave} FAILURE`;
          title.style.color = "#ff4d4d";
          sub.innerText = "ë°©ì–´ì„ ì´ ëŒíŒŒë‹¹í–ˆìŠµë‹ˆë‹¤...";
          box.style.borderColor = "#ff4d4d";
          box.style.boxShadow = "0 15px 40px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,77,77,0.2)";
        }

        modal.style.display = 'flex';
      }

      // ê²°ê³¼ ì°½ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (Firebase API ì—°ë™ìš© ë˜í•‘)
      async function extractAndSaveScore() {
        if (!window.defenseRankingAPI) return;
        let nameInput = document.getElementById('playerName').value.trim();
        if (!nameInput) nameInput = "AAA";
        const rankB = document.getElementById('resRank').innerText;
        await window.defenseRankingAPI.saveScore(nameInput, G.wave, G.totalGoldEarned || 0, rankB);
      }

      document.getElementById('btnResNew').onclick = async () => {
        document.getElementById('resultModal').style.display = 'none';
        await extractAndSaveScore();
        localStorage.removeItem('defenseSave');
        G.gameState = 'PLAYING';
        resetGame();
        G.isTutorialDone = false;
        updateUI();
      };

      document.getElementById('btnResMain').onclick = async () => {
        document.getElementById('resultModal').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('rankingModal').style.display = 'flex';
        document.getElementById('rankingList').innerHTML = '<div style="text-align:center; color:#888; padding:20px;">ê¸°ë¡ì„ ì „ì†¡í•˜ëŠ” ì¤‘...</div>';
        await extractAndSaveScore();
        await new Promise(resolve => setTimeout(resolve, 600));
        if (window.defenseRankingAPI) window.defenseRankingAPI.loadRankings();
      };


      function tick(now) {
        const realDt = Math.min(0.05, (now - last) / 1000);
        last = now;

        // [ì‹ ê·œ ì£¼ì…] G.gameSpeedë§Œí¼ ì„œë¸Œ-ìŠ¤í…Œí•‘ ë£¨í”„ ì‹¤í–‰
        if (G.gameState === 'PLAYING') {
          // Ending Phase 1 Timer logic (runs even if gameplay is frozen)
          if (G.endingActive) {
            G.endingTimer += realDt;
            if (G.endingPhase === 1 && G.endingTimer >= 1.2) {
              G.endingPhase = 2;
              G.endingTimer = 0;
            }
          }

          if (G.endingActive) {
            // Freeze gameplay entirely, skip tracking loop mechanics
            render();
            requestAnimationFrame(tick);
            return;
          }

          for (let step = 0; step < G.gameSpeed; step++) {
            let endingJustTriggered = false;
            const dt = realDt; // ì„œë¸Œ ìŠ¤í…ë³„ ë™ì¼í•œ dt ì ìš©
            G.time += dt;

            // Reset Global Debuff Every Frame (Sub-step)
            G.globalRangeDebuff = false;

            if (G.inWave && G.spawnPlan) {
              const elapsed = G.time - waveStartTime;
              while (G.spawnCursor < G.spawnPlan.length && G.spawnPlan[G.spawnCursor].at <= elapsed) {
                spawnEnemy(G.spawnPlan[G.spawnCursor]); G.spawnCursor++;
              }
              if (G.spawnCursor >= G.spawnPlan.length && G.enemies.every(e => !e.alive)) {
                G.inWave = false;

                // Prevent buff leakage outside combat
                G.overclockActive = false;
                G.overclockUntil = 0;

                // Finisher Wave Clear Reset
                G.finisherActive = false;
                G.finisherUntil = 0;
                G.finisherType = null;
                G.finisherFRMult = 1;
                G.finisherRangeMult = 1;
                G.finisherKillGoldMult = 1;

                const bonus = 40 + G.wave * 10; G.gold += bonus;
                log(`ğŸ‰ ì›¨ì´ë¸Œ í´ë¦¬ì–´! (+${bonus}G)`);

                // --- Rental Hero Lifecycle ---
                G.towers = G.towers.filter(t => {
                  if (t.isHero) {
                    t.remainWaves--;
                    if (t.remainWaves <= 0) {
                      log(`ğŸ‘‹ ${t.heroGrade}ë“±ê¸‰ ì˜ì›… íƒ€ì›Œê°€ ë– ë‚©ë‹ˆë‹¤...`);
                      return false;
                    }
                  }
                  return true;
                });

                saveGameState();
                updateUI();
              }
            }

            // Auto Overclock Logic Check
            if (G.inWave && G.wave >= OVERCLOCK_WAVES[0] && G.wave <= OVERCLOCK_WAVES[1] && !(G.wave === 0 && !G.isTutorialDone)) {
              if (!G.overclockUsedThisWave && G.time >= G.overclockCooldownUntil && G.totalSpawnCount > 0) {
                const progress = G.currentFinishedCount / G.totalSpawnCount;
                if (progress >= OVERCLOCK_TRIGGER_PROGRESS) {
                  G.overclockActive = true;
                  G.overclockUntil = G.time + OVERCLOCK_DURATION;
                  G.overclockUsedThisWave = true;
                  G.overclockCooldownUntil = G.time + OVERCLOCK_INTERNAL_CD;
                  log("âš¡ OVERCLOCK!");
                  addFloatText("âš¡ OVERCLOCK!", LOGICAL_W / 2, LOGICAL_H / 2 - 50);
                }
              }
            }

            // Auto Overclock Expiration Check
            if (G.overclockActive && G.time >= G.overclockUntil) {
              G.overclockActive = false;
            }

            // Finisher Expiration Check
            if (G.finisherActive && G.time >= G.finisherUntil) {
              G.finisherActive = false;
              G.finisherType = null;
              G.finisherFRMult = 1;
              G.finisherRangeMult = 1;
              G.finisherKillGoldMult = 1;
              updateUI();
            }

            // 1. ë£¨í”„ ì‹œì‘ ì§ì „ì— 'ì´ë²ˆ í”„ë ˆì„ì— ìš´ì„ì´ ê³µê²©ë°›ì•˜ëŠ”ê°€?'ë¥¼ ì²´í¬í•˜ëŠ” ë³€ìˆ˜ ì„ ì–¸
            let isRockPushed = false;


            for (const e of G.enemies) {
              if (!e.alive) continue;
              e.prevX = e.x;

              if (e.dashCooldown > 0) e.dashCooldown -= dt;

              BossHandler.applyTick(e, dt, G);

              // ğŸ‘‡ [ìˆ˜ì •ëœ ê°ì† ë¡œì§] ìŠ¬ë¡œìš°ê°€ í’€ë¦¬ë©´ ê³„ìˆ˜ë„ í™•ì‹¤í•˜ê²Œ ë¦¬ì…‹!
              let effectiveSlow = 0;
              if (e.slowUntil > G.time) {
                effectiveSlow = e.slowFactor;
              } else {
                e.slowFactor = 0; // ìƒíƒœ ì´ìƒ ì¢…ë£Œ ì‹œ ê°ì† ë¹„ìœ¨ ì´ˆê¸°í™”
              }

              if (e.isBoss) effectiveSlow *= 0.5;

              const speed = (e.currentSpeed || e.speed) * (1 - effectiveSlow);
              const finalSpeed = e.isBoss ? Math.max(speed, (e.currentSpeed || e.speed) * 0.4) : speed;

              // Synergy: Freeze Block (Do not advance movement if frozen)
              if (e.frozenUntil > G.time) {
                continue; // Skip movement processing this sub-step
              }

              if (e.dashReq || e.evadeDashReq) {
                const nextIdx = Math.min(e.pathIndex + 1, path.length - 1);
                const nextParam = path[nextIdx];
                const angle = Math.atan2(nextParam.y - e.y, nextParam.x - e.x);

                const distToNext = dist({ x: e.x, y: e.y }, nextParam);
                const dashDist = Math.min(50, distToNext);

                e.x += Math.cos(angle) * dashDist;
                e.y += Math.sin(angle) * dashDist;

                if (e.evadeDashReq) {
                  e.evadeDashReq = false;
                } else {
                  e.dashReq = false;
                  addFloatText("Dash!", e.x, e.y);
                }
              }

              let move = finalSpeed * dt;
              if (finalSpeed > 0 && move < 0.2) move = 0.2;

              while (move > 0 && e.pathIndex < path.length - 1) {
                const next = path[e.pathIndex + 1];
                const distToNext = dist({ x: e.x, y: e.y }, next);

                if (distToNext <= move + 0.5) {
                  e.x = next.x;
                  e.y = next.y;
                  e.pathIndex++;
                  move -= distToNext;
                } else {
                  const dx = (next.x - e.x) / distToNext;
                  const dy = (next.y - e.y) / distToNext;
                  e.x += dx * move;
                  e.y += dy * move;
                  move = 0;
                }
              }

              // ğŸ‘‡ [ì‹ ê·œ ì¶”ê°€] ğŸŒ‘ ìš´ì„(ë°”ìœ„) ë¬¼ë¦¬ ì¶©ëŒ ë° ê°•ì œ ì •ì²´ ë¡œì§
              if (G.rock && G.rock.available && !e.isTutorial) {
                // ì ì´ ìš´ì„ ë°©ì–´ì„ (y: 790)ì„ ë„˜ìœ¼ë ¤ í•˜ë©´ ë°œë™!
                if (e.y >= 790 && e.pathIndex >= path.length - 2) {
                  if (!G.rock.active) {
                    G.rock.active = true;
                    G.rock.timer = G.rock.duration; // 5ì´ˆ íƒ€ì´ë¨¸ ì‹œì‘
                    log("ğŸŒ‘ ìµœí›„ì˜ ë°©ì–´ì„  ì‘ë™! 10ì´ˆê°„ ì ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤!");
                  }

                  // ìš´ì„ì´ í™œì„±í™”ë˜ì–´ ìˆëŠ” 10ì´ˆ ë™ì•ˆì€ ìœ„ì¹˜ë¥¼ ê°•ì œ ê³ ì • (í†µê³¼ ì ˆëŒ€ ë¶ˆê°€)
                  if (G.rock.timer > 0) {
                    e.y = 790; // ì´ ì„ ì„ ë„˜ì§€ ëª»í•¨
                    e.x = 270; // ì¤‘ì•™ ê¸¸ëª©ìœ¼ë¡œ ëª¨ì„
                    e.pathIndex = path.length - 2; // ë‹¤ìŒ ì¸ë±ìŠ¤ë¡œ ë„˜ì–´ê°€ëŠ” ê²ƒì„ ì°¨ë‹¨

                    // í•µì‹¬: ì ì´ ìš´ì„ì„ ë“¤ì´ë°›ê³  ìˆë‹¤ë©´ í‘¸ì‹œ ìƒíƒœë¥¼ trueë¡œ ë³€ê²½!
                    isRockPushed = true;
                  }
                }
              }


              if (e.pathIndex >= path.length - 1) {
                // [ì‹ ê·œ ì£¼ì…] í—ˆìˆ˜ì•„ë¹„ë¥¼ ë†“ì³ë„ í˜ë„í‹° ì—†ì´ íŠœí† ë¦¬ì–¼ ê°•ì œ ì¡¸ì—…
                if (e.isTutorial) {
                  G.isTutorialDone = true;
                  G.gold += 200;
                  G.wave = 0;
                  e.alive = false;
                  log('ğŸ‰ íŠœí† ë¦¬ì–¼ ì™„ë£Œ! [â–¶ ì›¨ì´ë¸Œ]ë¥¼ ëˆŒëŸ¬ ë³¸ê²©ì ì¸ ë°©ì–´ë¥¼ ì‹œì‘í•˜ì„¸ìš”.');
                  updateUI();
                  if (typeof saveGameState === 'function') saveGameState();
                  continue;
                }

                // ğŸ‘‡ [ì‹ ê·œ ì¶”ê°€] 5ì´ˆ ë°©ì–´ ë°”ìœ„ ë¡œì§
                if (G.rock && G.rock.available) {
                  if (!G.rock.active) {
                    G.rock.active = true;
                    G.rock.timer = G.rock.duration; // 5ì´ˆ íƒ€ì´ë¨¸ ì‹œì‘
                    log("ğŸª¨ ìµœí›„ì˜ ë°©ì–´ì„ ! ë°”ìœ„ê°€ ì ì„ 5ì´ˆê°„ ë§‰ì•„ëƒ…ë‹ˆë‹¤!");
                    addFloatText("ğŸª¨ BLOCK!", e.x, e.y - 30);
                  }
                }

                // ë°”ìœ„ê°€ ë°œë™ ì¤‘ì´ë©´ ë°ë¯¸ì§€ë¥¼ ì…ì§€ ì•Šê³  ê¸¸ ëì—ì„œ ëŒ€ê¸°(ì •ì²´)í•¨
                if (G.rock && G.rock.active && G.rock.timer > 0) {
                  e.x = path[path.length - 1].x;
                  e.y = path[path.length - 1].y;
                  continue; // ì•„ë˜ì— ìˆëŠ” ë¼ì´í”„ ê°ì†Œ ë¡œì§ì„ ë¬´ì‹œí•˜ê³  ë„˜ê¹€!
                }

                e.alive = false;
                const damageToLife = e.isBoss ? 5 : 1;
                G.lives -= damageToLife;

                if (e.isBoss) {
                  log(`ğŸš¨ ê²½ê³ : ë³´ìŠ¤ê°€ ëŒíŒŒí–ˆìŠµë‹ˆë‹¤! HP -${damageToLife}`);
                  addFloatText(`HP -${damageToLife}`, e.x, e.y);
                } else {
                  log(`ğŸ’¥ ëª¬ìŠ¤í„° í†µê³¼!`);
                }

                updateUI();
                if (G.lives <= 0 || (e.isBoss && e.bossType === 100)) {
                  if (G.lives <= 0 || (G.wave === 100 && !G.endingActive)) {
                    G.lives = 0;
                    updateUI();
                    G.deathPos = { x: Math.floor(e.x), y: Math.floor(e.y) };
                    G.deathReason = e.isBoss ? "Boss Break" : "Monster Break";
                    triggerEnding('FAIL');
                    endingJustTriggered = true;
                    G.inWave = false;
                    G.spawnPlan = null;
                    break;
                  }
                }
              }

              // 3. ë£¨í”„ ì¢…ë£Œ ì§í›„, í‘¸ì‹œ ìƒíƒœì¼ ë•Œë§Œ ë‚´êµ¬ë„(íƒ€ì´ë¨¸) ê°ì†Œ!
              if (G.rock && G.rock.active && isRockPushed) {
                G.rock.timer -= dt; // ì ì´ ë°€ê³  ìˆì„ ë•Œë§Œ ì‹œê°„ì´ ê¹ì„
                if (G.rock.timer <= 0) {
                  G.rock.available = false;
                  G.rock.active = false;
                  log("ğŸ’¥ ìµœí›„ì˜ ë°©ì–´ì„ ì´ ì‚°ì‚°ì¡°ê° ë‚¬ìŠµë‹ˆë‹¤!");
                }
              }

            }

            if (endingJustTriggered) break;

            for (const t of G.towers) {
              t.cooldown -= dt;
              t.targetCheckTimer = (t.targetCheckTimer || 0) - dt; // íƒ€ê²Ÿì¹­ ì¿¨íƒ€ì„ ì²˜ë¦¬

              if (t.isHero) {
                if (t.heroGrade === 'A') {
                  const auraRad = t.aAuraRadius || 250;
                  for (const e of G.enemies) {
                    if (e.alive && dist(t, e) <= auraRad) {
                      e.slowUntil = Math.max(e.slowUntil, G.time + 0.1);
                      e.slowFactor = Math.max(e.slowFactor, 0.5);
                    }
                  }
                } else if (t.heroGrade === 'S') {
                  t.globalBurnTimer += dt;
                  if (t.globalBurnTimer >= 0.5) {
                    t.globalBurnTimer -= 0.5;
                    const burnDmg = t.damage * 0.2;
                    for (const e of G.enemies) {
                      if (e.alive) {
                        const actualDmg = e.isBoss ? burnDmg * 0.25 : burnDmg;
                        e.hp -= actualDmg;
                        if (e.hp <= 0 && e.alive) {
                          e.alive = false;
                          if (e.isBoss) { G.lives += 1; log(`ğŸ’– ë³´ìŠ¤ ì²˜ì¹˜! ì‹œìŠ¤í…œ ë³µêµ¬ (HP +1)`); updateUI(); }
                          if (!e.isBoss || e.bossType !== 10) G.currentFinishedCount++;
                          BossHandler.onDeath(e, G);
                          if (e.isMiniBoss && Math.random() < 0.2) { G.upgradePoints++; addFloatText(`Lucky! +1P`, e.x, e.y - 15); }
                          addRewardGold(e);
                          updateUI();
                        }
                      }
                    }
                  }
                }
              }

              // [ì‹ ê·œ ì£¼ì…] íƒ€ê²Ÿ ìµœì í™” (Target Caching & Invalidation ê·œì¹™)
              let needsNewTarget = false;

              // W90 Global Range Debuff Check (Active Bosstype 90 or W100 with trait 90)
              const hasW90 = G.enemies.some(e => e.alive && e.isBoss && ((e.bossType === 90) || (e.bossType === 100 && e.activeTrait === 90)));

              // Apply Overclock Range Buff first (Excluding Heroes), then W90 Debuff
              const oc = (G.overclockActive && !t.isHero);
              const finR = (G.finisherActive && !t.isHero) ? G.finisherRangeMult : 1;
              let effectiveRange = t.range * (oc ? OVERCLOCK_RANGE_MULT : 1) * finR;
              if (hasW90) effectiveRange *= 0.8;

              if (!t.target) {
                needsNewTarget = true;
              } else if (!t.target.alive) {
                needsNewTarget = true;
              } else if (dist(t, t.target) > effectiveRange) {
                needsNewTarget = true;
              } else if (t.targetCheckTimer <= 0) {
                needsNewTarget = true;
              }

              if (needsNewTarget) {
                t.target = findTarget(t, effectiveRange);
                t.targetCheckTimer = 0.2; // 0.2ì´ˆ ì¿¨íƒ€ì„ ë¶€ì—¬
              }

              // íƒ€ê²Ÿì´ ì¡´ì¬í•˜ê³  ë°œì‚¬ ê°€ëŠ¥í•  ë•Œ
              if (t.cooldown <= 0 && t.target) {
                // Update Aim Angle
                t.lastAngle = Math.atan2(t.target.y - t.y, t.target.x - t.x);
                fire(t, t.target);

                // Apply Overclock Fire Rate Buff (Excluding Heroes)
                const oc = (G.overclockActive && !t.isHero);
                const finFR = (G.finisherActive && !t.isHero) ? G.finisherFRMult : 1;
                const effectiveFireRate = t.fireRate * (oc ? OVERCLOCK_FR_MULT : 1) * finFR;
                t.cooldown = 1 / effectiveFireRate;
              } else if (t.cooldown <= 0 && !t.target) {
                t.cooldown = 0.1; // Idle ìƒíƒœ ì¬íƒìƒ‰ ì£¼ê¸° 0.1ì´ˆ 
              }

              // Recoil Decay
              t.recoil = Math.max(0, (t.recoil || 0) - dt * 20);
            }

            // if (G.time % 2 < dt) {
            //   G.enemies = G.enemies.filter(e => e.alive);
            //   G.projectiles = G.projectiles.filter(p => p.life > 0);
            //   G.floatTexts = G.floatTexts.filter(f => f.life > 0);
            // }

            // [ìˆ˜ì •ëœ ì•„í‚¤í…ì²˜ ì ìš©: ë£¨í”„ ë‚´ë¶€ í•˜ë‹¨]
            // ìƒíƒœê°€ ì¢…ë£Œëœ ê°ì²´ëŠ” ì§€ì—° ì—†ì´ ì¦‰ê°ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œ (GC ê°•ì œí™”)
            G.enemies = G.enemies.filter(e => e.alive);
            G.projectiles = G.projectiles.filter(p => p.life > 0);
            G.floatTexts = G.floatTexts.filter(f => f.life > 0);

            G.projectiles.forEach(p => p.life -= dt);
            // í”Œë¡œíŒ… í…ìŠ¤íŠ¸ì˜ ìˆ˜ëª… ì°¨ê°ì€ ê²Œì„ ì†ë„ì™€ ë³„ê°œë¡œ ì¼ì •í•œ í˜„ì‹¤ ì‹œê°„ì„ ê±°ì¹˜ê²Œ í•˜ë„ë¡ G.gameSpeedë¡œ ë‚˜ëˆ„ì–´ì¤Œ
            G.floatTexts.forEach(f => { f.life -= dt / G.gameSpeed; f.y -= 25 * dt; });
          } // Sub-stepping loop End
        }

        render(); // Rendering pipelineì€ ë£¨í”„ ë°–ì—ì„œ í”„ë ˆì„ë‹¹ 1ë²ˆë§Œ ì‹¤í–‰
        requestAnimationFrame(tick);
      }

      function findTarget(t, range) {
        let best = null, bestScore = -Infinity;

        for (const e of G.enemies) {
          if (!e.alive || dist(t, e) > range) continue;
          if (e.isStealth) continue; // W50 Stealth Ignored

          const score = e.pathIndex * 10000 - dist(e, path[Math.min(e.pathIndex + 1, path.length - 1)]);
          if (score > bestScore) { bestScore = score; best = e; }
        }
        return best;
      }

      function fire(t, target) {
        const dmg = t.damage;
        t.recoil = 5; // Set Recoil

        if (t.type === 2) {
          // T2 Multi-Missile Volley (5 shots)
          for (let i = 0; i < 5; i++) {
            const spreadX = (Math.random() - 0.5) * 30;
            const spreadY = (Math.random() - 0.5) * 30;
            G.projectiles.push({
              x1: t.x, y1: t.y, x2: target.x + spreadX, y2: target.y + spreadY,
              life: 0.15 + i * 0.05, // Staggered impact
              type: 2, aoe: t.aoe,
              isFinal: i === 4 // Mark final shot for AOE ring
            });
          }
          // AOE Logic is handled per projectile impact or we just apply damage once?
          // Current logic: AOE damage is applied immediately for simplicity, visuals are delayed.
          // To be precise: damage should sync with visuals. But for now, keeping immediate damage for responsiveness.
          G.enemies.forEach(e => {
            if (e.alive && dist(target, e) <= t.aoe) {
              // Synergy Check: "ëƒ‰ê° í­ë°œ" 
              // If slowed by T3 and within last 1.6s
              if (G.wave >= SYNERGY_FREEZE_MIN_WAVE && !e.isBoss && e.lastSlowedByType === 3 && (G.time - e.lastSlowedAt <= 1.6)) {
                if (G.time >= e.synergyFreezeCdUntil) {
                  e.frozenUntil = Math.max(e.frozenUntil, G.time + 0.35);
                  e.synergyFreezeCdUntil = G.time + 2.0;
                  G.statsFreezeCount++; // Ending stat tracker

                  // âœ¨ [ì‹ ê·œ ì¶”ê°€] ì‹œë„ˆì§€ ë°œë™ì„ ì•Œë¦¬ëŠ” ê°•ë ¥í•œ í”Œë¡œíŒ… í…ìŠ¤íŠ¸!
                  addFloatText("â„ï¸", e.x, e.y - 30);

                  // Synergy Tips: Freeze
                  hintFlags.freezeTriggeredOnce = true;
                  if (!hintFlags.freezeHintShown) {
                    showToast("ê¿€íŒ: ìŠ¬ë¡œìš°(ë ˆì´ë‹¤) ì ì´ ìºë…¼ í­ë°œì„ ë§ìœ¼ë©´ â„ ì ê¹ ë¹™ê²°!", 2000);
                    hintFlags.freezeHintShown = true; saveHints();
                  }
                }
              }
              dealDamage(e, dmg, t);
            }
          });
        } else {
          // Standard Shot ë‚´ë¶€ ë¡œì§
          if (t.slow > 0) {
            // 1. [ê³µí†µ ë¡œì§] ëª¬ìŠ¤í„° ì¢…ë¥˜ì— ìƒê´€ì—†ì´ ìŠ¬ë¡œìš° ë””ë²„í”„ëŠ” ë¬´ì¡°ê±´ ì¸ê°€í•©ë‹ˆë‹¤.
            // (ë³´ìŠ¤ê°€ ì•„ì˜ˆ ë©ˆì¶”ì§€ ì•Šê³  50% ì†ë„ë¡œ ì²œì²œíˆ ê°€ëŠ” ë¡œì§ì€ tick í•¨ìˆ˜ì˜ effectiveSlow *= 0.5 ì—ì„œ ì´ë¯¸ ì²˜ë¦¬ë¨)
            target.slowUntil = Math.max(target.slowUntil, G.time + 1.5);
            target.slowFactor = Math.max(target.slowFactor, t.slow);

            // 2. [ë³´ìŠ¤ ë°˜ì‘ ë¡œì§] ëŒ€ìƒì´ ë³´ìŠ¤ì´ê³  ì”ì—¬ ëŒì§„ íšŸìˆ˜ê°€ ë‚¨ì•„ìˆë‹¤ë©´, ëŒì§„ì„ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.
            if (target.isBoss && target.slowEvadeCount > 0) {

              // [ìˆ˜ì •] dashCooldownì´ 0 ì´í•˜ì¼ ë•Œë§Œ ìƒˆë¡œìš´ ëŒì§„ í—ˆìš©
              if (!target.dashReq && !target.evadeDashReq && (target.dashCooldown || 0) <= 0) {
                target.slowEvadeCount--;
                target.evadeDashReq = true;
                target.dashCooldown = 2.0; // [ì‹ ê·œ ì£¼ì…] 2ì´ˆê°„ ì—°ì‡„ ëŒì§„ ì°¨ë‹¨
                addFloatText("ëŒì§„!", target.x, target.y - 20);
              }
            }
          }
          // Simple AOE check (if any T1 has AOE? currently 0) or T3?
          if (t.aoe > 0 && t.type !== 2) {
            G.enemies.forEach(e => { if (e.alive && dist(target, e) <= t.aoe) dealDamage(e, dmg, t); });
          } else {
            dealDamage(target, dmg, t);
          }

          // Synergy Tagging: Track slow source
          if (t.slow > 0) {
            target.lastSlowedByType = t.type;
            target.lastSlowedAt = G.time;
          }

          G.projectiles.push({
            x1: t.x, y1: t.y, x2: target.x, y2: target.y,
            life: 0.15, type: t.type, aoe: t.aoe || 0
          });
        }
      }

      function dealDamage(e, dmg, t) {
        if (!e.alive) return;

        // [ì‹ ê·œ êµì²´ ì½”ë“œ] 3 ë‹¤ì¤‘ ë¬´ì  êµ¬ì—­ (Safe Zones) ì•„í‚¤í…ì²˜
        const safeZones = [
          { x: LOGICAL_W / 2, y: (gridSize / 2) + offsetY }, // ì¤‘ì•™ ë™êµ´
          { x: 100, y: gridSize + offsetY },                 // ì¢Œì¸¡ í™”ì‚°
          { x: 440, y: gridSize + offsetY }                  // ìš°ì¸¡ í™”ì‚°
        ];

        // ëª¬ìŠ¤í„°ì™€ ê°€ì¥ ê°€ê¹Œìš´ ì•ˆì „ êµ¬ì—­ê¹Œì§€ì˜ ê±°ë¦¬ ì‚°ì¶œ
        const minDist = Math.min(...safeZones.map(z => Math.hypot(e.x - z.x, e.y - z.y)));

        // ì–´ëŠ í•œ êµ¬ì—­ì´ë¼ë„ ë°˜ê²½ 45px ì´ë‚´ì— ìˆë‹¤ë©´ ë°ë¯¸ì§€ ë° ìŠ¬ë¡œìš° ì›ì²œ ì°¨ë‹¨
        if (minDist < 45) {
          return;
        }

        let finalDmg = dmg;

        // --- Machinegun (T1) Armor Break Stacking ---
        if (t && t.type === 1 && !t.isHero) {
          if (G.time > e.mgStackUntil) e.mgStacks = 0;
          e.mgStacks += 1;
          e.mgStackUntil = G.time + MG_STACK_WINDOW;

          let threshold = MG_STACKS_NORMAL;
          if (e.isBoss) threshold = MG_STACKS_BOSS;
          else if (e.type === 'tank') threshold = MG_STACKS_TANK;

          if (e.mgStacks >= threshold && G.time >= e.vulnCdUntil) {
            e.vulnUntil = Math.max(e.vulnUntil, G.time + MG_VULN_DURATION);
            e.vulnCdUntil = G.time + MG_VULN_CD;
            e.mgStacks = 0;
            G.statsVulnCount++; // Ending stat tracker
            addFloatText("ğŸ’¥", e.x, e.y - 20);

            // Synergy Tips: Vuln
            hintFlags.vulnTriggeredOnce = true;
            if (!hintFlags.vulnHintShown) {
              showToast("ê¿€íŒ: ë¨¸ì‹ ê±´ì´ ê³„ì† ë§íˆë©´ ğŸ”´ 'ì·¨ì•½'! íƒ±ì»¤/ë³´ìŠ¤ê°€ ë” ë¹¨ë¦¬ ë…¹ì•„ìš”.", 2000);
              hintFlags.vulnHintShown = true; saveHints();
            }
          }
        }

        // Apply Boss Defense Logic
        finalDmg = BossHandler.calcDamage(e, finalDmg, t);

        // T3 Tank (Hardness)
        if (!e.isBoss && e.tier >= 3 && e.type === 'tank') {
          finalDmg = Math.max(1, finalDmg - 10);
        }

        // Boss Vulnerability (Slowed -> +20% Dmg)
        if (e.isBoss && e.slowUntil > G.time) {
          finalDmg *= 1.2;
          addFloatText("Weak!", e.x, e.y - 20);
        }

        // --- Rental Hero SS Grade True Damage ---
        if (t && t.isHero && t.heroGrade === 'SS' && e.isBoss) {
          if (G.time >= t.ssTrueDmgCdUntil) {
            const trueDmg = Math.min(e.hp * 0.008, e.hpMax * 0.01);
            t.ssTrueDmgCdUntil = G.time + 0.8;
            finalDmg += trueDmg;
            addFloatText("TrueDmg!", e.x, e.y - 20);
          }
        }

        if (e.vulnUntil > G.time) {
          let mult = MG_VULN_MULT_NORMAL;
          if (e.isBoss) mult = MG_VULN_MULT_BOSS;
          else if (e.type === 'tank') mult = MG_VULN_MULT_TANK;
          finalDmg *= mult;
        }

        e.hp -= finalDmg;
        e.hitTime = G.time; // Trigger Hit Flash

        if (e.hp <= 0 && e.alive) {
          // [ì‹ ê·œ ì£¼ì…] í—ˆìˆ˜ì•„ë¹„ ì²˜ì¹˜ ì‹œ íŠœí† ë¦¬ì–¼ ê°•ì œ ì¡¸ì—… ë° ë³´ìƒ ì§€ê¸‰
          if (e.isTutorial) {
            G.isTutorialDone = true;
            G.gold += 200;
            G.wave = 0;
            e.alive = false;
            log('ğŸ‰ íŠœí† ë¦¬ì–¼ ì™„ë£Œ! [â–¶ ì›¨ì´ë¸Œ]ë¥¼ ëˆŒëŸ¬ ë³¸ê²©ì ì¸ ë°©ì–´ë¥¼ ì‹œì‘í•˜ì„¸ìš”.');
            updateUI();
            if (typeof saveGameState === 'function') saveGameState();
            return;
          }

          e.alive = false;

          // [ìˆ˜ì •] ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ ë¼ì´í”„ ê³ ì • +5 íšŒë³µ (ê³µí‰í•œ ë¦¬ìŠ¤í¬/ë¦¬í„´)
          if (e.isBoss) {
            const healAmount = 5;

            // ì œí•œ ì—†ì´ ë¬´ì¡°ê±´ ì¶”ê°€
            G.lives += healAmount;

            log(`ğŸ’– ë³´ìŠ¤ ì²˜ì¹˜! ì‹œìŠ¤í…œ í™•ì¥ (HP +${healAmount})`);
            addFloatText(`HP +${healAmount}`, e.x, e.y - 30);
            updateUI();
          }


          if (!e.isBoss || e.bossType !== 10) G.currentFinishedCount++; // Kill count

          BossHandler.onDeath(e, G); // Check Boss Death Logic

          // Mini-Boss Drop (20% Chance for 1 Point)
          if (e.isMiniBoss && Math.random() < 0.2) {
            G.upgradePoints++;
            addFloatText(`Lucky! +1P`, e.x, e.y - 15);
          }

          addRewardGold(e);
          updateUI();
        } else if (e.isBoss) {
          updateUI(); // Update UI on Boss Hit for HP Bar
        }
      }


      function resetGame() {
        G.gold = 250; G.lives = 20; G.wave = 0; G.inWave = false;
        G.upgradePoints = 1; // Reset to 1
        G.enemies = []; G.towers = []; G.projectiles = []; G.floatTexts = []; G.previewTower = null; G.pendingHero = null;

        // Reset Overclock
        G.overclockActive = false;
        G.overclockUntil = 0;
        G.overclockUsedThisWave = false;
        G.overclockCooldownUntil = 0;

        // Reset Finisher
        G.finisherUsedThisWave = false;
        G.finisherActive = false;
        G.finisherUntil = 0;
        G.finisherType = null;
        G.finisherFRMult = 1;
        G.finisherRangeMult = 1;
        G.finisherKillGoldMult = 1;
        G.rock = { available: true, active: false, timer: 0, duration: 10.0 };

        // Reset Ending State
        G.endingActive = false;
        G.endingType = null;
        G.endingPhase = 0;
        G.endingTimer = 0;
        G.endingStats = {};
        G.hiddenEndingLabel = "";
        G.statsFreezeCount = 0;
        G.statsVulnCount = 0;
        G.statsFinisherCount = 0;

        log('ğŸ”„ ì´ˆê¸°í™”ë¨.'); updateUI();
      }

      function saveGameState() {
        const data = {
          wave: G.wave,
          gold: G.gold,
          lives: G.lives,
          upgradePoints: G.upgradePoints,
          towers: G.towers,
          isTutorialDone: G.isTutorialDone,
          schemaVersion: SCHEMA_VERSION
        };
        localStorage.setItem('defenseSave', JSON.stringify(data));
      }

      function loadGameState() {
        const saved = localStorage.getItem('defenseSave');
        if (!saved) return false;
        try {
          const data = JSON.parse(saved);
          if (data.schemaVersion !== SCHEMA_VERSION) {
            alert("Save data version mismatch.");
            return false;
          }
          G.wave = data.wave;
          G.gold = data.gold;
          G.lives = data.lives;
          G.upgradePoints = data.upgradePoints;
          G.towers = data.towers;
          if (G.towers && G.towers.length > 0) {
            G.isTutorialDone = true;
          } else {
            G.isTutorialDone = data.isTutorialDone || false;
          }
          return true;
        } catch (e) {
          alert("Load failed.");
          return false;
        }
      }

      // initGameSession logic replaced inline.

      function render() {
        ctx.clearRect(0, 0, LOGICAL_W, LOGICAL_H);

        // [Line 1265 ë¶€ê·¼ ì‚½ì…]
        // 1. ì†Œêµ´ ë°°ê²½: ë”¥ ë ˆë“œ ìš©ì•” ì§€ëŒ€
        ctx.fillStyle = '#1a0505';
        ctx.fillRect(0, 0, LOGICAL_W, gridSize * 2 + offsetY);

        // 2. ìš©ì•” íë¦„ ì‹œê° íš¨ê³¼ (ë§¥ë™ ë¡œì§)
        ctx.strokeStyle = '#ff4500'; ctx.lineWidth = 4;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(Math.random() * LOGICAL_W, 0);
          ctx.lineTo(Math.cos(G.time + i) * 50 + (i * 100), gridSize * 2 + offsetY);
          ctx.globalAlpha = 0.2 + Math.sin(G.time * 2) * 0.1;
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

        // 3. ì§€í˜•ì§€ë¬¼ ì˜¤ë¸Œì íŠ¸ (í™”ì‚° ë° ìŠ¤í° ë™êµ´)
        ctx.font = '50px serif'; ctx.textAlign = 'center';
        ctx.fillText('ğŸŒ‹', 100, gridSize + offsetY);
        ctx.fillText('ğŸ•³ï¸', LOGICAL_W / 2, gridSize + 15 + offsetY);
        ctx.fillText('ğŸŒ‹', 440, gridSize + offsetY);

        // 4. ë¬¼ë¦¬ì  ê²½ê³„ì„  ë ˆì´ì €
        ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(0, gridSize * 2 + offsetY);
        ctx.lineTo(LOGICAL_W, gridSize * 2 + offsetY);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
        for (let i = 0; i <= gridCols; i++) { const x = i * gridSize + offsetX; ctx.moveTo(x, 0); ctx.lineTo(x, LOGICAL_H); }
        for (let i = 0; i <= gridRows; i++) { const y = i * gridSize + offsetY; ctx.moveTo(0, y); ctx.lineTo(LOGICAL_W, y); }
        ctx.stroke();

        ctx.beginPath(); ctx.lineWidth = 40; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();

        // Projectiles (Layering: Below Towers/Enemies)
        G.projectiles.forEach(p => {
          ctx.globalAlpha = Math.max(0, p.life / 0.15); // Alpha Sync

          switch (p.type) {
            case 1: // Laser (Single)
              ctx.beginPath();
              ctx.lineWidth = 4; ctx.strokeStyle = '#7aa6ff';
              ctx.shadowColor = '#fff'; ctx.shadowBlur = 10;
              ctx.moveTo(p.x1, p.y1); ctx.lineTo(p.x2, p.y2);
              ctx.stroke();
              break;
            case 2: // Explosion (AOE) - Missile Volley
              // Trajectory (Smoke Trail)
              ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(100,100,100,0.5)';
              ctx.moveTo(p.x1, p.y1); ctx.lineTo(p.x2, p.y2); ctx.stroke();
              // Missile
              const progress = 1 - p.life / 0.25; // Approx
              if (progress < 1) {
                ctx.beginPath(); ctx.fillStyle = '#ffda00';
                const mx = p.x1 + (p.x2 - p.x1) * progress;
                const my = p.y1 + (p.y2 - p.y1) * progress;
                ctx.arc(mx, my, 2, 0, Math.PI * 2); ctx.fill();
              }

              // Impact Explosion
              ctx.beginPath();
              ctx.fillStyle = `rgba(255, 100, 50, ${p.life * 5})`;
              ctx.arc(p.x2, p.y2, 12, 0, Math.PI * 2); ctx.fill(); // Small explosion per missile

              // Final AOE Ring
              if (p.isFinal) {
                ctx.beginPath(); ctx.strokeStyle = `rgba(255, 50, 0, ${p.life * 3})`;
                ctx.lineWidth = 1;
                ctx.arc(p.x2, p.y2, p.aoe, 0, Math.PI * 2); ctx.stroke();
              }
              break;
            case 3: // Cold Wave (Slow)
              // Expanding Ring
              const r = Math.max(0, 30 - (p.life * 200));
              ctx.beginPath();
              ctx.strokeStyle = `rgba(100, 200, 255, ${p.life * 6})`;
              ctx.lineWidth = 3;
              ctx.arc(p.x2, p.y2, r, 0, Math.PI * 2); ctx.stroke();
              break;
          }
        });
        ctx.globalAlpha = 1; ctx.shadowBlur = 0; // Reset Effects

        G.towers.forEach(t => {
          ctx.save();
          ctx.translate(t.x, t.y);

          // Apply Recoil (Kickback)
          if (t.recoil > 0) {
            ctx.translate(-Math.cos(t.lastAngle) * t.recoil, -Math.sin(t.lastAngle) * t.recoil);
          }

          // Render Logic
          if (t.type === 3 && !t.isHero) {
            // Type 3 (Slow - Radar): Scan Effect
            ctx.rotate(-(t.lastAngle || 0) + G.time * 2);

            // Base Ring
            ctx.beginPath(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2;
            ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.stroke();

            // Core
            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();

            // Radar Sweep
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, 12, 0, 0.5); ctx.fill();
          } else {
            // Type 1 & 2 (Turrets) & Heroes: Aim at Target
            ctx.rotate(t.lastAngle || 0);

            if (t.isHero) {
              ctx.shadowBlur = 15 + Math.sin(G.time * 5) * 5;
              if (t.heroGrade === 'A') { ctx.shadowColor = '#50C878'; ctx.fillStyle = '#50C878'; }
              else if (t.heroGrade === 'S') { ctx.shadowColor = '#FFD700'; ctx.fillStyle = '#FFD700'; }
              else if (t.heroGrade === 'SS') { ctx.shadowColor = '#FF0033'; ctx.fillStyle = '#FF0033'; }

              ctx.fillRect(-12, -12, 24, 24);
              ctx.fillStyle = '#fff';
              ctx.fillRect(12, -4, 14, 8);
              ctx.shadowBlur = 0;
            } else if (t.type === 1) {
              // Type 1 (Single)
              ctx.fillStyle = '#666'; ctx.fillRect(-10, -10, 20, 20); // Body
              ctx.fillStyle = '#333'; ctx.fillRect(10, -4, 12, 8);   // Barrel
            } else if (t.type === 2) {
              // Type 2 (AOE - ë‹¤ë ¨ì¥ ë¯¸ì‚¬ì¼ ì‹œìŠ¤í…œ / MLRS)

              // 1. í•˜ë¶€ íšŒì „ ë§ˆìš´íŠ¸ (Base Mount)
              ctx.fillStyle = '#2b303b';
              ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();

              // 2. ë°œì‚¬ëŒ€ ë³¸ì²´ (Launcher Pod) - ì¥ê°‘íŒ ëŠë‚Œì˜ ìœ¡ì¤‘í•œ ì§ì‚¬ê°í˜•
              ctx.fillStyle = '#4a5568';
              ctx.fillRect(-14, -12, 26, 24);

              // 3. ì¸¡ë©´ ì¥ê°‘ íŒ¨ë„ ë¼ì¸ (Armor Detailing)
              ctx.strokeStyle = '#1a202c';
              ctx.lineWidth = 2;
              ctx.strokeRect(-14, -12, 26, 24);

              // 4. ì „ë©´ë¶€ ë‹¤ë ¨ì¥ í¬íŠ¸ í•˜ìš°ì§•
              ctx.fillStyle = '#2d3748';
              ctx.fillRect(12, -11, 6, 22);

              // 5. íƒ„ë‘(Warheads) ì¥ì „ ìƒíƒœ ë™ê¸°í™” ë¡œì§ (The "How" & "Why")
              // íƒ€ì›Œì˜ ì¿¨íƒ€ì„ ë°ì´í„°(t.cooldown)ë¥¼ ì‹œê°í™”í•˜ì—¬ ìœ ì €ê°€ ë°œì‚¬ íƒ€ì´ë°ì„ ì˜ˆì¸¡ ê°€ëŠ¥í•˜ê²Œ í•¨
              const isLoaded = t.cooldown <= 0.2;

              // 3í–‰ 2ì—´(3x2)ì˜ ë¯¸ì‚¬ì¼ í¬íŠ¸ ë°°ì—´ ë Œë”ë§
              for (let row = -7; row <= 7; row += 7) {
                for (let col = 13; col <= 16; col += 3) {
                  ctx.beginPath();
                  ctx.arc(col, row, 1.8, 0, Math.PI * 2);

                  if (isLoaded) {
                    // ì¥ì „ ì™„ë£Œ: ë¶‰ì€ìƒ‰ íƒ„ë‘ ë…¸ì¶œ ë° ë¯¸ì„¸í•œ ê´‘ì›(Glow) ì´í™íŠ¸
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#ff4d4d';
                    ctx.fillStyle = '#ff4d4d';
                  } else {
                    // ì¬ì¥ì „ ì¤‘: ë¹ˆ í¬íŠ¸(ê²€ì€ êµ¬ë©)ë¡œ í‘œì‹œ
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#111';
                  }

                  ctx.fill();
                  ctx.shadowBlur = 0; // ê´‘ì› íš¨ê³¼ ì´ˆê¸°í™”
                }
              }
            }
          }

          ctx.restore();

          // Text Overlay (UI Rollback: Simple Number)
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          if (t.isHero) {
            ctx.fillText(`â³${t.remainWaves}`, t.x, t.y - 25);
          } else {
            ctx.fillText(t.level, t.x, t.y + 1);
          }
        });

        // ğŸ‘‡ [ì‹ ê·œ êµì²´] ğŸŒ‘ ì´ëª¨ì§€ ìš´ì„ ë Œë”ë§
        if (G.rock && G.rock.available) {
          ctx.save();
          // ì ë“¤ì´ ë§‰íˆëŠ” ê¸¸ëª© ì¢Œí‘œ (x: 270, y: 790)
          ctx.translate(270, 790);

          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

          if (G.rock.active) {
            // ğŸ’¥ ë°œë™ ì¤‘: ê°•í•˜ê²Œ ì§„ë™í•˜ëŠ” ğŸŒ‘ ìš´ì„
            ctx.translate((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6);
            ctx.font = '60px sans-serif';
            ctx.fillText('ğŸŒ‘', 0, 0);

            // ë¶‰ì€ìƒ‰ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸
            ctx.fillStyle = '#ff4d4d'; ctx.font = 'bold 22px sans-serif';
            ctx.shadowColor = '#000'; ctx.shadowBlur = 5;
            ctx.fillText(G.rock.timer.toFixed(1) + 's', 0, -40);
          } else {
            // ğŸ’¤ ëŒ€ê¸° ì¤‘: ë°˜íˆ¬ëª…í•˜ê²Œ ëŒ€ê¸°í•˜ëŠ” ğŸŒ‘ ìš´ì„
            ctx.globalAlpha = 0.4;
            ctx.font = '40px sans-serif';
            ctx.fillText('ğŸŒ‘', 0, 0);

            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#8892b0'; ctx.font = 'bold 11px sans-serif';
            ctx.fillText('LAST STAND', 0, -30);
          }
          ctx.restore();
        }


        G.enemies.forEach(e => {
          if (!e.alive) return;

          // [ìˆ˜ì • í¬ì¸íŠ¸ 1] ìŠ¤ì½”í”„(Scope) ì—ëŸ¬ í•´ê²°: emojiMapì„ ìµœìƒë‹¨ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¼
          const emojiMap = { normal: 'ğŸ§Ÿ', fast: 'ğŸ¦‡', tank: 'ğŸš', boss: 'ğŸ‘¹' };

          // 1. ì´ëª¨ì§€ ë§¤í•‘ (ìˆ˜ë¯¸ìƒê´€ êµ¬ì¡° ìœ ì§€)
          let emoji = 'ğŸ‘¾';
          if (e.isBoss) {
            const bossEmojis = { 10: 'ğŸ‘¹', 20: 'ğŸ±â€ğŸ‰', 30: 'ğŸ±â€ğŸš€', 40: 'ğŸ±â€ğŸ‘¤', 50: 'ğŸ‘»', 60: 'ğŸ¤¡', 70: 'ğŸ‘º', 80: 'â˜ ', 90: 'ğŸ¤–', 100: 'ğŸ‘¹' };
            const typeId = (e.bossType === 100) ? 100 : e.bossType;
            emoji = bossEmojis[typeId] || 'ğŸ‘¹';
          } else {
            emoji = e.isMiniBoss ? 'ğŸ¦¹â€â™‚ï¸' : (emojiMap[e.type] || 'ğŸ‘¾');
          }

          // 2. Data Scale-Up: W100 ìµœì¢… ë³´ìŠ¤ ì „ìš© ìŠ¤íƒ¯ ë»¥íŠ€ê¸°
          const isFinalBoss = (e.bossType === 100 && e.isBoss);

          // ì¼ë°˜ ë³´ìŠ¤ëŠ” 24, W100 ìµœì¢… ë³´ìŠ¤ëŠ” 48ë¡œ í…ìŠ¤íŠ¸ ë Œë”ë§ ë©´ì  4ë°°(2ë°°ìˆ˜ ì œê³±) í™•ëŒ€
          const fontSize = isFinalBoss ? 48 : (e.isBoss ? 24 : (e.isMiniBoss ? 19 : 16));

          // ë¹™ê²° ë°”ë‹¥ ì´í™íŠ¸ (ì–¼ìŒ ê³ ë¦¬) - ì  ì•„ë˜ì— ê¹”ë¦¬ê²Œ Draw Enemy ì§ì „ ë Œë”ë§
          if (e.frozenUntil > G.time && e.alive) {
            ctx.save();
            // ì ì˜ ìœ„ì¹˜ë¡œ ì´ë™
            ctx.translate(e.x, e.y);

            // 1. ë°˜íˆ¬ëª…í•œ ì–¼ìŒ íë¸Œ ìƒì„±
            ctx.fillStyle = 'rgba(150, 230, 255, 0.65)'; // ì¨í•œ ì–¼ìŒìƒ‰
            ctx.strokeStyle = '#ffffff'; // í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15; // ì‹œì„ ì„ ë„ëŠ” ë„¤ì˜¨ íš¨ê³¼

            // ë³´ìŠ¤ ì—¬ë¶€ì— ë”°ë¼ íë¸Œ í¬ê¸° ì¡°ì •
            const boxSize = e.isBoss ? 50 : 34;

            // íë¸Œ ê·¸ë¦¬ê¸° (ëª¨ì„œë¦¬ê°€ ì•½ê°„ ê°ì§„ í˜•íƒœ)
            ctx.fillRect(-boxSize / 2, -boxSize / 2 + 5, boxSize, boxSize);
            ctx.strokeRect(-boxSize / 2, -boxSize / 2 + 5, boxSize, boxSize);

            // 2. ì¤‘ì•™ì— ëˆˆì†¡ì´ ë§ˆí¬ ì¾…!
            ctx.font = `${e.isBoss ? 24 : 16}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText('â„ï¸', 0, 5);

            ctx.restore();
          }

          // ë°©ì–´êµ¬ íŒŒê´´(Armor Break) ë°”ë‹¥ ì´í™íŠ¸
          if (e.vulnUntil > G.time && e.alive) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.fillStyle = 'rgba(255, 100, 100, 0.65)';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            const boxSize = e.isBoss ? 50 : 34;
            ctx.fillRect(-boxSize / 2, -boxSize / 2 + 5, boxSize, boxSize);
            ctx.strokeRect(-boxSize / 2, -boxSize / 2 + 5, boxSize, boxSize);
            ctx.font = `${e.isBoss ? 24 : 16}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText('ğŸ’¥', 0, 5);
            ctx.restore();
          }

          ctx.save();

          // 3. Position & ë¯¸ì„¸ ì§„ë™(Vibration) ì´í™íŠ¸ ì£¼ì…
          let renderX = e.x;
          let renderY = e.y;

          if (isFinalBoss) {
            // ë¶ˆì•ˆì •í•œ ì—ë„ˆì§€ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•´ ë§¤ í”„ë ˆì„ë§ˆë‹¤ -1.5 ~ 1.5pxì˜ ë‚œìˆ˜(Noise) ì¢Œí‘œë¥¼ ë”í•´ ì§„ë™ ì—°ì¶œ
            renderX += (Math.random() - 0.5) * 3;
            renderY += (Math.random() - 0.5) * 3;
          }

          ctx.translate(renderX, renderY);
          if (e.x < e.prevX) ctx.scale(-1, 1);

          // [ì‹ ê·œ êµì²´ ì½”ë“œ] ë Œë”ë§ íŒŒì´í”„ë¼ì¸ ë¬´ì  êµ¬ì—­ ì‹œê°í™”
          const renderSafeZones = [
            { x: LOGICAL_W / 2, y: gridSize + 15 + offsetY }, // ë™êµ´ ë Œë” ì¢Œí‘œ
            { x: 100, y: gridSize + offsetY },                // ì¢Œì¸¡ í™”ì‚°
            { x: 440, y: gridSize + offsetY }                 // ìš°ì¸¡ í™”ì‚°
          ];

          const minRenderDist = Math.min(...renderSafeZones.map(z => Math.hypot(e.x - z.x, e.y - z.y)));

          if (minRenderDist < 45) {
            e.slowUntil = 0; // ìŠ¬ë¡œìš° ì§€ì† ì‹œê°„ì„ 0ìœ¼ë¡œ ê°•ì œ ì´ˆê¸°í™”
            ctx.globalAlpha = 0.3; // ë¬´ì  ìƒíƒœì„ì„ ì•”ì‹œí•˜ëŠ” ì€ì‹  íš¨ê³¼
          } else {
            ctx.globalAlpha = 1.0; // êµ¬ì—­ì„ ë²—ì–´ë‚˜ëŠ” ì¦‰ì‹œ ì‹¤ì²´í™”
          }



          // 4. Tier Aura & Boss Glow (ë§¥ë™í•˜ëŠ” ì•„ìš°ë¼)
          if (e.tier >= 2) {
            ctx.shadowBlur = e.tier === 3 ? 20 : 15;
            ctx.shadowColor = e.tier === 3 ? '#ff4d4d' : '#ffd700';
          }
          if (e.isBoss) {
            if (isFinalBoss) {
              // G.time ê¸°ë°˜ì˜ ì‚¬ì¸íŒŒ(Sine Wave) ê³¡ì„ ì„ ê³±í•´ ê·¸ë¦¼ìê°€ í˜¸í¡í•˜ë“¯(Pulsing) ì»¤ì¡Œë‹¤ ì‘ì•„ì§€ê²Œ ì„¤ê³„
              ctx.shadowBlur = 35 + Math.sin(G.time * 8) * 15;
              ctx.shadowColor = '#cc0000'; // í•œì¸µ ë” ì–´ë‘¡ê³  ë¬µì§í•œ ì ìƒ‰
            } else {
              ctx.shadowBlur = 20;
              ctx.shadowColor = '#ff0000';
            }
          }

          // 5. Draw Enemy
          if (e.isMutant && !e.isBoss) {
            ctx.fillStyle = e.mutantColor;
            ctx.beginPath();
            const sides = e.mutantSides;
            const r = e.radius || 11;
            for (let i = 0; i < sides; i++) {
              const theta = (i / sides) * Math.PI * 2;
              const spikeFac = 1.0 + Math.abs(Math.sin(i * 1324 + e.pathIndex)) * 0.8;
              const rMod = r * spikeFac;
              const x = Math.cos(theta) * rMod;
              const y = Math.sin(theta) * rMod;
              if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.closePath(); ctx.fill();

            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -3, 3, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -3, 1, 0, Math.PI * 2); ctx.fill();
          } else {
            if (e.evolutionColor && !e.isBoss) {
              ctx.globalCompositeOperation = 'source-over';
              ctx.shadowBlur = 10;
              ctx.shadowColor = e.evolutionColor;
              ctx.fillStyle = e.evolutionColor;
              ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
            }

            ctx.font = `${fontSize}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';

            // W100 ì „ìš©: ì”ìƒ(Ghosting) ë ˆì´ì–´ë¥¼ ë§ê·¸ë ¤ í€„ë¦¬í‹°ì—…
            if (isFinalBoss) {
              ctx.globalAlpha = 0.5;
              ctx.fillText(emoji, -2, 2);
              ctx.globalAlpha = 1.0;
            }

            ctx.fillText(emoji, 0, 0);
          }

          ctx.restore();

          // Status Text Overlay
          if (e.statusText && e.isBoss) {
            const bossR = (e.radius || 16.5) * 1.5;
            ctx.fillStyle = '#fff'; ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(e.statusText, e.x, e.y - bossR);
          }

          // 5. Minimal Horizontal HP Bar 
          const barW = e.isBoss ? 40 : 24;
          const barH = e.isBoss ? 4 : 3;
          const hpPct = Math.max(0, e.hp / e.hpMax);
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(e.x - barW / 2, e.y + (e.isBoss ? 18 : 12), barW, barH);
          ctx.fillStyle = hpPct > 0.5 ? '#00ff00' : '#ff0000';
          ctx.fillRect(e.x - barW / 2, e.y + (e.isBoss ? 18 : 12), barW * hpPct, barH);


          // 6. Boss Text
          if (e.isBoss) {
            const bossR = (e.radius || 16.5) * 1.2;
            ctx.fillStyle = '#ff3333';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`[BOSS W${e.bossType}]`, e.x, e.y - (bossR + 15));
          }

          // 7. Status (Slow) Visual (ì›í˜• ì„  ì œê±° í›„ ì´ëª¨ì§€ ìƒ‰ì¡° ë³€í™”ë¡œ ëŒ€ì²´)
          if (e.slowUntil > G.time) {
            ctx.save();
            ctx.globalCompositeOperation = 'source-atop';
            ctx.fillStyle = 'rgba(0, 191, 255, 0.3)'; // ìŠ¬ë¡œìš° ì‹œ í‘¸ë¥¸ ìƒ‰ì¡°
            ctx.translate(e.x, e.y);
            ctx.font = `${fontSize}px serif`; // [ìˆ˜ì • í¬ì¸íŠ¸ 2] í°íŠ¸ ì‚¬ì´ì¦ˆ ë³€ìˆ˜ í†µì¼
            // [ìˆ˜ì • í¬ì¸íŠ¸ 3] ìŠ¬ë¡œìš°ì— ê±¸ë ¸ì„ ë•Œ ë³´ìŠ¤ ë””ìì¸ì´ ğŸ‘¾ë¡œ ë³€í•˜ëŠ” ë²„ê·¸ ë°©ì§€ (emoji ë³€ìˆ˜ ì§ì ‘ ì‚¬ìš©)
            ctx.fillText(emoji, 0, 0);
            ctx.restore();
          }
        });

        // Removed Old Projectile Loop from here

        ctx.fillStyle = '#fff'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
        G.floatTexts.forEach(f => { ctx.globalAlpha = f.life; ctx.fillText(f.text, f.x, f.y); });
        ctx.globalAlpha = 1;

        // íŠœí† ë¦¬ì–¼ í…ìŠ¤íŠ¸ ë Œë”ë§
        if (!G.isTutorialDone && G.wave === 0) {
          ctx.fillStyle = '#ffda00'; ctx.font = 'bold 24px sans-serif'; ctx.textAlign = 'center';

          if (G.towers.length === 0) {
            ctx.fillText("ğŸ‘‡ í•˜ë‹¨ì˜ [ë¨¸ì‹ ê±´] íƒ€ì›Œë¥¼ ê±´ì„¤í•˜ì„¸ìš”!", LOGICAL_W / 2, LOGICAL_H / 2);
          } else {
            const hasUpgraded = G.towers.some(t => t.level > 1);
            if (!hasUpgraded) {
              ctx.fillText("ğŸ‘‡ [ê°•í™”]ë¥¼ ëˆ„ë¥´ê³  íƒ€ì›Œë¥¼ ì„ íƒí•´ ë ˆë²¨ì—…í•˜ì„¸ìš”!", LOGICAL_W / 2, LOGICAL_H / 2);
              ctx.font = 'bold 18px sans-serif';
              ctx.fillText("(ë¹„ìš©: 1P í•„ìš” / í˜„ì¬ 1P ë³´ìœ )", LOGICAL_W / 2, LOGICAL_H / 2 + 30);
            } else {
              ctx.fillText("í•˜ë‹¨ì˜ [â–¶ ì›¨ì´ë¸Œ]ë¥¼ ëˆŒëŸ¬ í›ˆë ¨ì„ ì‹œì‘í•˜ì„¸ìš”!", LOGICAL_W / 2, LOGICAL_H / 2);
            }
          }
        }

        if ((G.mode === 'place' || G.mode === 'placeHero') && G.previewTower) {
          const { gx, gy, type, isHero, pendingHero } = G.previewTower; const def = TOWER_TYPES[type];
          const cx = gx * gridSize + gridSize / 2 + offsetX; const cy = gy * gridSize + gridSize / 2 + offsetY;

          let color = def.color;
          if (isHero && pendingHero) {
            if (pendingHero.grade === 'A') color = '#50C878';
            else if (pendingHero.grade === 'S') color = '#FFD700';
            else if (pendingHero.grade === 'SS') color = '#FF0033';
          }

          ctx.beginPath(); ctx.arc(cx, cy, def.range, 0, 6.28);
          ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.setLineDash([6, 6]); ctx.stroke(); ctx.setLineDash([]);
          ctx.fillStyle = color; ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(cx, cy, 12, 0, 6.28); ctx.fill();
          ctx.fillStyle = color; ctx.globalAlpha = 0.2; ctx.fillRect(gx * gridSize + offsetX, gy * gridSize + offsetY, gridSize, gridSize);
          ctx.globalAlpha = 1; ctx.fillStyle = '#fff'; ctx.font = '12px sans-serif'; ctx.fillText("í•œë²ˆ ë” í„°ì¹˜!", cx, cy - 20);
        }

        // Auto Overclock Visual Overlay
        if (G.overclockActive) {
          ctx.save();
          // Draw a very subtle yellow/white screen tint overlay
          ctx.fillStyle = 'rgba(255, 250, 200, 0.08)';
          ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

          // Draw Timer
          const remaining = Math.max(0, G.overclockUntil - G.time);
          ctx.font = 'bold 20px sans-serif';
          ctx.fillStyle = '#ffda00';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.shadowColor = '#000';
          ctx.shadowBlur = 4;
          ctx.fillText(`âš¡ ${remaining.toFixed(1)}s`, LOGICAL_W / 2, offsetY + 15);
          ctx.restore();
        }

        // Finisher Visual Overlay
        if (G.finisherActive) {
          ctx.save();
          // Draw a subtle orange screen tint overlay
          ctx.fillStyle = 'rgba(255, 150, 0, 0.06)';
          ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

          // Draw Timer
          const remaining = Math.max(0, G.finisherUntil - G.time);
          ctx.font = 'bold 20px sans-serif';
          ctx.fillStyle = '#ff5500';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.shadowColor = '#000';
          ctx.shadowBlur = 4;

          // Prevent overlap with Overclock timer if both are active
          const textY = G.overclockActive ? offsetY + 45 : offsetY + 15;
          ctx.fillText(`ğŸ”¥ ${remaining.toFixed(1)}s`, LOGICAL_W / 2, textY);
          ctx.restore();
        }
      }


      function updateUI() {
        const ui = G.ui;
        const fill = ui.progressFill;

        // Visual Progress Bar Logic
        if (!G.inWave) {
          fill.style.width = '0%';
        } else if (G.wave % 10 === 0) {
          // Boss Wave: Total HP Ratio (Red)
          const bosses = G.enemies.filter(e => e.isBoss && e.alive);
          if (bosses.length > 0) {
            const totalHP = bosses.reduce((sum, b) => sum + b.hp, 0);
            const totalMaxHP = bosses.reduce((sum, b) => sum + b.hpMax, 0);
            fill.style.width = (totalHP / totalMaxHP * 100) + '%';
            fill.style.backgroundColor = '#ff4d4d';
          } else {
            fill.style.width = '0%'; // Clear if no boss alive (e.g. split phase or dead)
          }
        } else {
          // Normal Wave: Progress Ratio (Blue)
          const progress = G.totalSpawnCount > 0 ? (G.currentFinishedCount / G.totalSpawnCount) * 100 : 0;
          fill.style.width = Math.min(100, progress) + '%';
          fill.style.backgroundColor = '#7aa6ff';
        }

        // ìƒë‹¨ ë°” ì—…ë°ì´íŠ¸: Gold(í™©ê¸ˆìƒ‰), Points(ë³´ë¼ìƒ‰), HP(ë¹¨ê°„ìƒ‰), Wave(í•˜ëŠ˜ìƒ‰)
        ui.topStat.innerHTML = `
          <span>G: <b style="color:#ffd700">${Math.floor(G.gold)}</b></span>
          <span>P: <b style="color:#a07aff">${G.upgradePoints}</b></span>
          <span>HP: <b style="color:#ff4d4d">${G.lives}</b></span>
          <span>W: <b style="color:#7aa6ff">${G.wave}</b></span>
        `;

        const btns = [ui.t1, ui.t2, ui.t3, ui.sell, ui.upgrade, ui.buyHero];
        btns.forEach(b => b.classList.remove('btn-on'));

        if (G.mode === 'place') {
          if (G.selectedTowerType === 1) ui.t1.classList.add('btn-on');
          if (G.selectedTowerType === 2) ui.t2.classList.add('btn-on');
          if (G.selectedTowerType === 3) ui.t3.classList.add('btn-on');
        } else if (G.mode === 'placeHero') {
          ui.buyHero.classList.add('btn-on');
        } else if (G.mode === 'sell') {
          ui.sell.classList.add('btn-on');
        } else if (G.mode === 'upgrade') {
          ui.upgrade.classList.add('btn-on');
        }

        // Update Gacha Cost Text
        const costStr = getGachaCost() + 'G';
        const costSpan = ui.buyUp.querySelector('.cost');
        if (costSpan && costSpan.innerText !== costStr) costSpan.innerText = costStr;

        const buyUpBtnCost = document.querySelector('#buyUp span.cost');
        if (buyUpBtnCost) {
          buyUpBtnCost.innerText = getGachaCost() + 'G';
        }


        ui.startWave.disabled = G.inWave;
        ui.startWave.style.opacity = G.inWave ? 0.5 : 1;

        // Finisher Button State
        if (G.inWave && !G.finisherUsedThisWave) {
          G.ui.btnFinisher.style.opacity = 1;
          G.ui.btnFinisher.style.pointerEvents = 'auto';
        } else {
          G.ui.btnFinisher.style.opacity = 0.5;
          G.ui.btnFinisher.style.pointerEvents = 'none';
        }

        if (!G.isTutorialDone && G.wave === 0) {
          // ë‹¤ë¥¸ ê³ ê¸‰ ê¸°ëŠ¥ë“¤ì€ íŠœí† ë¦¬ì–¼ ì¤‘ ì ê¸ˆ
          G.ui.t2.disabled = true; G.ui.t3.disabled = true;
          G.ui.sell.disabled = true;
          G.ui.buyUp.disabled = true; G.ui.buyAll.disabled = true; G.ui.buyHero.disabled = true;

          if (G.towers.length === 0) {
            // [1ë‹¨ê³„] íƒ€ì›Œê°€ ì—†ì„ ë•Œ: ê°•í™” ë²„íŠ¼ê³¼ ì‹œì‘ ë²„íŠ¼ ëª¨ë‘ ì ê¸ˆ
            G.ui.upgrade.disabled = true;
            G.ui.startWave.disabled = true; G.ui.startWave.style.opacity = 0.3;
          } else {
            // [2ë‹¨ê³„] íƒ€ì›Œê°€ ì§€ì–´ì¡Œì„ ë•Œ: ê°•í™” ë²„íŠ¼ ì ê¸ˆ í•´ì œ!
            G.ui.upgrade.disabled = false;

            // íƒ€ì›Œ ì¤‘ ë ˆë²¨ì´ 2 ì´ìƒì¸(ê°•í™”ëœ) íƒ€ì›Œê°€ ìˆëŠ”ì§€ ê²€ì‚¬
            const hasUpgraded = G.towers.some(t => t.level > 1);

            if (!hasUpgraded) {
              // ê°•í™”ë¥¼ ì•„ì§ ì•ˆ í–ˆë‹¤ë©´ ì‹œì‘ ë²„íŠ¼ì€ ê³„ì† ì ê¸ˆ
              G.ui.startWave.disabled = true; G.ui.startWave.style.opacity = 0.3;
            } else {
              // [3ë‹¨ê³„] ê°•í™”ê¹Œì§€ ë§ˆì³¤ì„ ë•Œ: ë“œë””ì–´ ì›¨ì´ë¸Œ ì‹œì‘ ë²„íŠ¼ ì ê¸ˆ í•´ì œ!
              G.ui.startWave.disabled = false; G.ui.startWave.style.opacity = 1;
            }
          }
        } else {
          // íŠœí† ë¦¬ì–¼ ì™„ë£Œ í›„ ëª¨ë“  ë²„íŠ¼ ì ê¸ˆ í•´ì œ
          G.ui.t2.disabled = false; G.ui.t3.disabled = false;
          G.ui.sell.disabled = false; G.ui.upgrade.disabled = false;
          G.ui.buyUp.disabled = false; G.ui.buyAll.disabled = false; G.ui.buyHero.disabled = false;
        }
      }

      function setMode(m, t = 1) { G.mode = m; G.selectedTowerType = t; G.previewTower = null; updateUI(); }

      function toggleSpeed() {
        G.gameSpeed = G.gameSpeed === 3 ? 1 : G.gameSpeed + 1;
        G.ui.btnSpeed.innerText = `â© ${G.gameSpeed}x`;
        log(`ë°°ì†ì´ ${G.gameSpeed}xë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      }

      G.ui.t1.onclick = () => setMode('place', 1);
      G.ui.t2.onclick = () => setMode('place', 2);
      G.ui.t3.onclick = () => setMode('place', 3);
      G.ui.sell.onclick = () => setMode(G.mode === 'sell' ? 'place' : 'sell');
      G.ui.upgrade.onclick = () => setMode(G.mode === 'upgrade' ? 'place' : 'upgrade');
      G.ui.startWave.onclick = () => startWave();
      G.ui.buyUp.onclick = () => { buyUpgradePoint(); G.gachaCount++; }; // Gacha Button Handler
      G.ui.buyAll.onclick = () => {
        const prevP = G.upgradePoints;
        buyUpgradeAllIn();
        G.gachaCount += (G.upgradePoints - prevP);
      }; // ì‹ ê·œ ì¶”ê°€: All-In ë²„íŠ¼ ì´ë²¤íŠ¸ ì—°ê²°
      G.ui.buyHero.onclick = () => buyHeroPoint(); // ì˜ì›… ë½‘ê¸° ì´ë²¤íŠ¸ ì—°ê²°
      G.ui.btnSpeed.onclick = () => toggleSpeed(); // ë°°ì† ì œì–´ ë²„íŠ¼ ì´ë²¤íŠ¸ ì—°ê²°

      // Finisher Logic
      function closeFinisherModal() {
        G.ui.finisherModal.style.opacity = 0;
        setTimeout(() => { G.ui.finisherModal.style.display = 'none'; }, 300);
      }

      G.ui.btnFinisher.onclick = () => {
        if (!G.inWave || G.finisherUsedThisWave) return;

        const isBossWave = (G.wave > 0 && G.wave % 10 === 0);

        // Show/Hide Gold Card
        if (isBossWave) {
          G.ui.cardFinisherGold.style.display = 'none';
        } else {
          G.ui.cardFinisherGold.style.display = 'flex';
          const baseCost = FINISHER_GOLD_BASE + G.wave * FINISHER_GOLD_PER_WAVE;
          const pctCost = Math.floor(G.gold * FINISHER_GOLD_WALLET_PCT);
          const goldCost = Math.max(baseCost, pctCost);
          G.currentFinisherGoldCost = goldCost; // Store for purchase

          const costText = G.ui.textFinisherGoldCost;
          if (G.gold < goldCost) {
            costText.innerText = `ë¹„ìš©: ${goldCost}G (ë¹„ìš©ë¶€ì¡±)`;
            costText.style.color = '#ff4d4d';
            G.ui.cardFinisherGold.style.opacity = 0.5;
            G.ui.cardFinisherGold.disabled = true;
          } else {
            costText.innerText = `ë¹„ìš©: ${goldCost}G`;
            costText.style.color = '#ffd700';
            G.ui.cardFinisherGold.style.opacity = 1;
            G.ui.cardFinisherGold.disabled = false;
          }
        }

        // HP Card Check
        if (G.lives <= FINISHER_HP_COST) {
          G.ui.cardFinisherHP.style.opacity = 0.5;
          G.ui.cardFinisherHP.disabled = true;
        } else {
          G.ui.cardFinisherHP.style.opacity = 1;
          G.ui.cardFinisherHP.disabled = false;
        }

        G.ui.finisherModal.style.display = 'flex';
        // force reflow
        void G.ui.finisherModal.offsetWidth;
        G.ui.finisherModal.style.opacity = 1;
      };

      G.ui.btnCancelFinisher.onclick = () => closeFinisherModal();

      G.ui.cardFinisherHP.onclick = () => {
        if (G.lives <= FINISHER_HP_COST || !G.inWave || G.finisherUsedThisWave) return;

        G.lives -= FINISHER_HP_COST;
        const isBossWave = (G.wave > 0 && G.wave % 10 === 0);

        G.finisherActive = true;
        G.finisherUsedThisWave = true;
        G.finisherType = 'HP';
        G.finisherUntil = G.time + FINISHER_HP_DUR;
        G.statsFinisherCount++; // Ending stat tracker

        if (isBossWave) {
          G.finisherFRMult = 1 + (FINISHER_HP_FR - 1) * FINISHER_BOSS_DAMP;
          G.finisherRangeMult = 1 + (FINISHER_HP_RANGE - 1) * FINISHER_BOSS_DAMP;
        } else {
          G.finisherFRMult = FINISHER_HP_FR;
          G.finisherRangeMult = FINISHER_HP_RANGE;
        }
        G.finisherKillGoldMult = FINISHER_HP_KILL_GOLD_MULT;

        log("ğŸ”¥ í•„ì‚´ê¸° [HP ì˜¤ë²„ë“œë¼ì´ë¸Œ] ê°€ë™!");
        addFloatText("ğŸ”¥ í•„ì‚´ê¸°!", LOGICAL_W / 2, LOGICAL_H / 2 - 80);
        closeFinisherModal();
        updateUI();
      };

      G.ui.cardFinisherGold.onclick = () => {
        const isBossWave = (G.wave > 0 && G.wave % 10 === 0);
        if (isBossWave || !G.inWave || G.finisherUsedThisWave || G.gold < G.currentFinisherGoldCost) return;

        G.gold -= G.currentFinisherGoldCost;

        G.finisherActive = true;
        G.finisherUsedThisWave = true;
        G.finisherType = 'GOLD';
        G.finisherUntil = G.time + FINISHER_GOLD_DUR;
        G.statsFinisherCount++; // Ending stat tracker
        G.finisherFRMult = FINISHER_GOLD_FR;
        G.finisherRangeMult = FINISHER_GOLD_RANGE;
        G.finisherKillGoldMult = FINISHER_GOLD_KILL_GOLD_MULT;

        log("ğŸ”¥ í•„ì‚´ê¸° [ê³¨ë“œ í…œí¬ ë¶€ìŠ¤íŠ¸] ê°€ë™!");
        addFloatText("ğŸ”¥ í•„ì‚´ê¸°!", LOGICAL_W / 2, LOGICAL_H / 2 - 80);
        closeFinisherModal();
        updateUI();
      };

      if (localStorage.getItem('defenseSave')) {
        document.getElementById('btnResume').style.display = 'block';
      }
      document.getElementById('btnResume').onclick = () => {
        document.getElementById('mainMenu').style.display = 'none';
        G.gameState = 'PLAYING';
        resetGame();
        loadGameState();
        updateUI();
      };
      document.getElementById('btnNewGame').onclick = () => {
        localStorage.removeItem('defenseSave');
        document.getElementById('mainMenu').style.display = 'none';
        G.gameState = 'PLAYING';
        resetGame();
        G.isTutorialDone = false;
        G.gold = 50;
        updateUI();
      };


      // [ADMIN] ë””ë²„ê·¸ ëª¨ë“œ: Shift + W ì…ë ¥ ì‹œ ì›¨ì´ë¸Œ ê°•ì œ ì í”„
      // ==========================================
      window.addEventListener('keydown', (e) => {
        if (e.shiftKey && (e.code === 'KeyW' || e.key === 'W' || e.key === 'w')) {
          e.preventDefault(); e.stopPropagation();
          setTimeout(() => {
            const target = parseInt(prompt("ğŸ› ï¸ [ê´€ë¦¬ì ëª¨ë“œ] ì´ë™í•  ì›¨ì´ë¸Œ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 10):", G.wave + 1));
            if (!isNaN(target) && target > 0) {
              if (G.gameState !== 'PLAYING') {
                document.getElementById('mainMenu').style.display = 'none';
                G.gameState = 'PLAYING';
              }
              G.enemies = []; G.projectiles = []; G.inWave = false;
              G.wave = target - 1; G.gold += 5000; G.upgradePoints += 50; G.isTutorialDone = true;
              log(`ğŸ› ï¸ [ADMIN] ì‹œìŠ¤í…œ ê°•ì œ í¬ì›Œë”© ì™„ë£Œ.`);
              updateUI(); startWave();
            }
          }, 10);
        }
      }, true);
      // ==========================================

      window.addEventListener('beforeunload', () => saveGameState());

      updateUI(); setMode('place', 1); log('ê°•í™” ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ ì™„ë£Œ.');
      requestAnimationFrame(tick);
    })();
  </script>

  <!-- FIREBASE RANKING MODULE -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
    import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDa3Lf-79xCd6pQO8aeO2FxoxHYPjA-Yag",
      authDomain: "tower-defense-27f4e.firebaseapp.com",
      projectId: "tower-defense-27f4e",
      storageBucket: "tower-defense-27f4e.firebasestorage.app",
      messagingSenderId: "662211622164",
      appId: "1:662211622164:web:bf5841c005093873b0be01",
      measurementId: "G-30M0BB8PSB"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    window.defenseRankingAPI = {
      saveScore: async (name, wave, gold, rankBadge) => {
        try {
          const finalName = name || 'ë¬´ëª… ì‚¬ë ¹ê´€';
          const device = typeof getDeviceInfo === 'function' ? getDeviceInfo() : {};
          const playTimeSec = G.playStartTime ? (Date.now() - G.playStartTime) / 1000 : 0;

          await addDoc(collection(db, "rankings"), {
            // 1. Basic Ranking Data
            name: finalName,
            wave: Number(wave),
            gold: Math.floor(gold),
            rankBadge: rankBadge,
            timestamp: serverTimestamp(),

            // 2. Gameplay Analytics
            stage: Number(wave), // Alias for wave
            result: (rankBadge === 'S' || rankBadge === 'A' || rankBadge === 'B') && wave >= 100 ? "WIN" : "FAIL",
            play_time: Number(playTimeSec.toFixed(3)),
            retry_count: G.retryCount || 1,
            build_count: G.buildCount || 0,
            sell_count: G.sellCount || 0,
            gacha_count: G.gachaCount || 0,
            death_pos: G.deathPos || { x: 0, y: 0 },
            reason: G.deathReason || "Unknown",

            // 3. Device & Environment Telemetry
            browser: device.browser || "Unknown",
            engine: device.engine || "Unknown",
            os: device.os || "Unknown",
            platform: device.platform || "Unknown",
            screen: device.screen || "Unknown",
            control: device.control || "Unknown",
            ua_full: device.ua_full || "Unknown"
          });
          console.log("Score & Telemetry Saved Successfully");
        } catch (e) {
          console.error("Error saving score: ", e);
        }
      },
      loadRankings: async () => {
        const listDiv = document.getElementById('rankingList');
        // Do not overwrite "Uploading..." text if we just triggered it from an active save.
        if (!listDiv.innerHTML.includes('ê¸°ë¡ì„ ì „ì†¡í•˜ëŠ” ì¤‘...')) {
          listDiv.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">ë­í‚¹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>';
        }

        try {
          const q = query(collection(db, "rankings"), orderBy("wave", "desc"), limit(30));
          const querySnapshot = await getDocs(q);

          listDiv.innerHTML = '';
          if (querySnapshot.empty) {
            listDiv.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            return;
          }

          let docs = [];
          querySnapshot.forEach(doc => docs.push(doc.data()));
          // Client-side secondary sort by gold, then take top 10
          docs.sort((a, b) => {
            if (b.wave !== a.wave) return b.wave - a.wave;
            return b.gold - a.gold;
          });
          const top10 = docs.slice(0, 10);

          let html = '';
          let place = 1;
          top10.forEach((data) => {
            let rankColor = '#fff';
            if (place === 1) rankColor = '#ffd700'; // Gold
            else if (place === 2) rankColor = '#c0c0c0'; // Silver
            else if (place === 3) rankColor = '#cd7f32'; // Bronze

            html += `
              <div style="background:rgba(255,255,255,0.05); padding:10px 15px; border-radius:8px; display:flex; justify-content:space-between; align-items:center;">
                <div style="display:flex; align-items:center; gap:12px;">
                  <b style="font-size:20px; color:${rankColor}; width:24px;">${place}</b>
                  <span style="font-size:16px; color:#fff; font-weight:bold;">${data.name}</span>
                </div>
                <div style="text-align:right;">
                  <div style="color:#7aa6ff; font-weight:bold;">W${data.wave} <span style="font-size:12px; color:${data.rankBadge === 'S' ? '#ffcc00' : (data.rankBadge === 'F' ? '#ff4d4d' : '#aaa')};">[${data.rankBadge}]</span></div>
                  <div style="color:#ffd700; font-size:12px;">${Math.floor(data.gold)}G</div>
                </div>
              </div>
            `;
            place++;
          });
          listDiv.innerHTML = html;
        } catch (e) {
          console.error("Error loading rankings: ", e);
          listDiv.innerHTML = '<div style="text-align:center; color:#ff4d4d; padding:20px;">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
        }
      }
    };

    // Binding the new ranking Modal events directly after load
    document.getElementById('btnShowRanking').addEventListener('click', () => {
      document.getElementById('rankingModal').style.display = 'flex';
      window.defenseRankingAPI.loadRankings();
    });

    document.getElementById('btnCloseRanking').addEventListener('click', () => {
      document.getElementById('rankingModal').style.display = 'none';
    });

  </script>
</body>

</html>
