<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Luge Olympic - Drawing Puzzle</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --olympic-blue: #0081C8;
      --olympic-yellow: #FCB131;
      --olympic-black: #1D1D1B;
      --olympic-green: #00A651;
      --olympic-red: #EE334E;
      --gold: #FFD700;
      --silver: #C0C0C0;
      --bronze: #CD7F32;
      --iron-red: #B22222;
      --iron-gold: #DAA520;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a1628 100%);
      font-family: 'Outfit', system-ui, sans-serif;
    }

    /* Game Container - 9:16 aspect ratio */
    #gameContainer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(100vw, 56.25vh);
      
      /* â–¼ ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ ë³€í™”ì— ì‹¤ì‹œê°„ ëŒ€ì‘í•˜ëŠ” ë™ì  ë†’ì´ ë°ì´í„° */
      height: min(177.78vw, 100dvh); 
      
      max-width: 450px;
      max-height: 800px;
      
      /* â–¼ ì‚¬ìš©ìë‹˜ì˜ ì›ë³¸ ì‹œê°í™” ë°ì´í„° ì™„ì „ ë³´ì¡´ */
      background:
        linear-gradient(180deg,
          rgba(15, 23, 42, 0.4) 0%,
          rgba(30, 50, 80, 0.3) 25%,
          rgba(60, 90, 130, 0.2) 50%,
          rgba(150, 180, 210, 0.15) 75%,
          rgba(220, 235, 250, 0.2) 100%),
        linear-gradient(135deg,
          #0a1628 0%,
          #1a3a5c 20%,
          #2a5a8c 40%,
          #5a8ab0 60%,
          #8ab8d8 80%,
          #c8e0f0 100%);
      background-size: cover;

      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 0 60px rgba(0, 129, 200, 0.3), 0 0 120px rgba(252, 177, 49, 0.1);

      /* â–¼ ë¸Œë¼ìš°ì € ê³ ìœ ì˜ ì œìŠ¤ì²˜ ê°œì… ì°¨ë‹¨ (í„°ì¹˜ ë°ì´í„° ë…ì ê¶Œ í™•ë³´) */
      touch-action: none; 
      overscroll-behavior: none; 
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    /* ========== HOME SCREEN ========== */
    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 100;
      overflow: hidden;
    }

    .screen.hidden {
      display: none;
    }

    #homeScreen {
      background: rgba(10, 22, 40, 0.6);
      justify-content: center;
      padding: 20px;
      backdrop-filter: blur(4px);
      /* (ì„ íƒ) ê¸€ì”¨ ì˜ ë³´ì´ê²Œ ë°°ê²½ ì‚´ì§ íë¦¬ê¸° */
    }

    /* Olympic Rings */
    .olympic-rings {
      position: absolute;
      top: 8%;
      display: flex;
      gap: 6px;
      opacity: 0.12;
      transform: scale(1.2);
    }

    .ring {
      width: 32px;
      height: 32px;
      border: 4px solid;
      border-radius: 50%;
    }

    .ring.blue {
      border-color: var(--olympic-blue);
    }

    .ring.yellow {
      border-color: var(--olympic-yellow);
      margin-top: 16px;
    }

    .ring.black {
      border-color: #fff;
    }

    .ring.green {
      border-color: var(--olympic-green);
      margin-top: 16px;
    }

    .ring.red {
      border-color: var(--olympic-red);
    }

    .home-title {
      font-size: 36px;
      font-weight: 900;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 20px var(--olympic-blue), 0 0 40px var(--olympic-yellow);
      margin-bottom: 5px;
      z-index: 10;
    }

    .home-subtitle {
      font-size: 12px;
      color: var(--gold);
      letter-spacing: 6px;
      text-transform: uppercase;
      margin-bottom: 25px;
      z-index: 10;
    }

    .medal-icon {
      font-size: 50px;
      margin-bottom: 15px;
      animation: float 3s ease-in-out infinite;
      z-index: 10;
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-8px);
      }
    }

    /* Level Select Grid */
    .level-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin: 0 auto 20px auto;
      z-index: 10;
      width: 90%;
      max-width: 300px;
      justify-content: center;
    }

    .level-btn {
      aspect-ratio: 1;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(0, 129, 200, 0.3), rgba(0, 50, 100, 0.5));
      color: #fff;
      font-family: 'Outfit', sans-serif;
      font-size: 18px;
      font-weight: 800;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      position: relative;
    }

    .level-btn:hover:not(.locked) {
      transform: scale(1.05);
      border-color: var(--gold);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    .level-btn.locked {
      background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
      color: #555;
      cursor: not-allowed;
      border-color: #333;
    }

    .level-btn.locked::after {
      content: 'ğŸ”’';
      position: absolute;
      font-size: 12px;
      bottom: 4px;
    }

    .level-btn.cleared {
      border-color: var(--gold);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(180, 150, 0, 0.3));
    }

    .level-btn .stars-indicator {
      font-size: 8px;
      margin-top: 2px;
    }

    /* Mode Selector */
    .mode-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      z-index: 10;
    }

    .mode-btn {
      padding: 12px 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      background: rgba(20, 40, 70, 0.8);
      color: #aaa;
      font-family: 'Outfit', sans-serif;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mode-btn.active {
      border-color: var(--gold);
      color: #fff;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(180, 150, 0, 0.3));
    }

    .play-btn {
      width: 80%;
      max-width: 250px;
      padding: 16px 35px;
      font-family: 'Outfit', sans-serif;
      font-size: 20px;
      font-weight: 900;
      color: var(--olympic-black);
      background: linear-gradient(135deg, var(--gold), #FFA500);
      border: none;
      border-radius: 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      box-shadow: 0 5px 0 #B8860B, 0 8px 25px rgba(255, 215, 0, 0.4);
      transition: all 0.2s;
      z-index: 10;
    }

    .play-btn:hover {
      transform: translateY(-2px);
    }

    .play-btn:active {
      transform: translateY(3px);
      box-shadow: 0 2px 0 #B8860B;
    }

    .play-btn:disabled {
      background: #444;
      color: #888;
      box-shadow: none;
      cursor: not-allowed;
    }

    /* ========== GAME HUD ========== */
    .game-ui {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px;
      
      /* â–¼ íˆ´ë°” ë†’ì´ ë³€ë™ì„±ê³¼ ì™„ë²½íˆ ë™ê¸°í™”ëœ ë™ì  íŒ¨ë”© ì‚°ì¶œ (Cascading) */
      padding-bottom: calc(72px + env(safe-area-inset-bottom));
      
      z-index: 10;
    }

    .game-ui.hidden {
      display: none;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      width: 100%;
    }

    .hud-left {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      /* [ì¶”ê°€] ë°•ìŠ¤ì™€ ê²Œì´ì§€ ìˆ˜ì§ ì¤‘ì•™ ì •ë ¬ */
    }

    .hud-right {
      display: flex;
      gap: 6px;
      pointer-events: auto;
    }

    .hud-box {
      background: rgba(10, 20, 40, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(8px);
      padding: 5px 10px;
      border-radius: 8px;
      color: #fff;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      text-align: center;
    }

    .hud-title {
      font-size: 8px;
      color: var(--olympic-blue);
      font-weight: 700;
      letter-spacing: 1px;
    }

    .hud-value {
      font-size: 12px;
      font-weight: 800;
    }

    .hud-value.stars {
      color: var(--gold);
    }

    .hud-value.time {
      color: #00ffcc;
      font-family: monospace;
      font-size: 11px;
    }

    .hud-value.ink {
      color: #88ccff;
    }

    .hud-value.ink.low {
      color: #ff6666;
    }

    .hud-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 8px;
      background: rgba(10, 20, 40, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .hud-btn:hover {
      border-color: var(--gold);
    }

    .controls {
      display: flex;
      gap: 6px;
      pointer-events: auto;
      width: 100%;
    }

    .ctrl-btn {
      flex: 1;
      border: 0;
      height: 40px;
      border-radius: 10px;
      font-family: 'Outfit', sans-serif;
      font-weight: 700;
      font-size: 12px;
      cursor: pointer;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 3px 0 rgba(0, 0, 0, 0.3);
      transition: all 0.15s;
    }

    .ctrl-btn:active {
      transform: translateY(2px);
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.3);
    }

    .btn-play {
      background: linear-gradient(135deg, var(--olympic-yellow), #FFA500);
      color: #000;
    }

    .btn-eraser {
      background: linear-gradient(135deg, #4a5568, #2d3748);
    }

    .btn-eraser.active {
      background: linear-gradient(135deg, var(--olympic-red), #cc2244);
    }

    .btn-clear {
      background: linear-gradient(135deg, #742a2a, #5a2020);
    }

    /* ========== MODALS ========== */
    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.88);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 50;
      padding: 20px;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-title {
      font-size: 26px;
      font-weight: 900;
      color: #fff;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .modal-sub {
      font-size: 13px;
      color: #aaa;
      margin-bottom: 20px;
      font-family: monospace;
    }

    .modal-btn {
      width: 180px;
      padding: 12px;
      margin: 5px 0;
      border: none;
      border-radius: 10px;
      font-family: 'Outfit', sans-serif;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.2s;
    }

    .modal-btn.primary {
      background: linear-gradient(135deg, var(--gold), #FFA500);
      color: #000;
    }

    .modal-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Leaderboard */
    .leaderboard {
      background: rgba(20, 30, 50, 0.9);
      border-radius: 10px;
      padding: 12px;
      margin: 15px 0;
      width: 200px;
    }

    .lb-title {
      font-size: 11px;
      color: var(--gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 8px;
      text-align: center;
    }

    .lb-entry {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      color: #fff;
      font-size: 11px;
      font-family: monospace;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .lb-entry:last-child {
      border-bottom: none;
    }

    .lb-rank {
      color: var(--gold);
      font-weight: 700;
    }

    .tutorial {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0.5);
      pointer-events: none;
      font-size: 13px;
      text-align: center;
      line-height: 1.5;
    }

    .tutorial.hidden {
      display: none;
    }

    /* ========== GLASSMORPHISM TOOLBAR ========== */
    .toolbar {
      position: absolute;
      /* â–¼ í•˜ë‹¨ ê³ ì • ë°°ì¹˜ */
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      gap: 6px;
      pointer-events: auto;
      width: 100%;
      
      /* 1. ë² ì´ìŠ¤ íŒ¨ë”© ë°ì´í„°ë¥¼ ë¨¼ì € ì„¸íŒ… (ìƒí•˜ 8px, ì¢Œìš° 10px) */
      padding: 8px 10px; 
      /* 2. í•˜ë‹¨ íŒ¨ë”©ë§Œ Safe Area ë°ì´í„°ë¥¼ ë”í•´ì„œ 'ì˜¤ë²„ë¼ì´ë“œ(ë®ì–´ì“°ê¸°)' */
      padding-bottom: calc(8px + env(safe-area-inset-bottom));

      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 14px 14px 0 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-bottom: none;
      z-index: 15;
    }

    .tool-btn {
      flex: 1;
      height: 44px;
      border: 2px solid transparent;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      font-family: 'Outfit', sans-serif;
      font-weight: 700;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .tool-btn:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .tool-btn.active {
      border-color: var(--gold);
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.4);
    }

    .tool-btn.play-btn {
      background: linear-gradient(135deg, var(--olympic-yellow), #FFA500);
      color: #000;
      flex: 0 0 auto;
      width: auto;
      padding: 0 16px;
    }

    /* Tool container for Draw/Eraser - fills remaining space */
    .tool-container {
      position: relative;
      flex: 0.8;
      /* â–¼ ì¶•ì†Œ: Undo ë²„íŠ¼ ê³µê°„ í™•ë³´ */
      display: flex;
    }

    .tool-container .tool-btn {
      width: 100%;
      height: 100%;
    }

    /* Undo ë²„íŠ¼: 1:1 ì •ì‚¬ê°í˜• */
    .tool-btn-square {
      flex: none !important;
      width: 44px;
      height: 44px;
      aspect-ratio: 1;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Popup container */
    .tool-popup {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(10px);
      opacity: 0;
      pointer-events: none;
      transition: all 0.25s ease-out;
      margin-bottom: 8px;
    }

    .tool-popup.visible {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
      pointer-events: auto;
    }

    .popup-content {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 10px;
      display: flex;
      gap: 8px;
      white-space: nowrap;
    }

    /* Ink type buttons */
    .ink-btn {
      width: 50px;
      height: 50px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 10px;
      color: #aaa;
      font-family: 'Outfit', sans-serif;
    }

    .ink-btn .ink-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-bottom: 4px;
    }

    .ink-btn[data-type="normal"] .ink-dot {
      background: #ffffff;
      box-shadow: 0 0 8px #00ffcc;
    }

    .ink-btn[data-type="booster"] .ink-dot {
      background: #ff4444;
      box-shadow: 0 0 8px #ff6600;
    }

    .ink-btn[data-type="jump"] .ink-dot {
      background: #39ff14;
      box-shadow: 0 0 8px #ccff00;
    }

    .ink-btn.active {
      border-color: var(--gold);
      background: rgba(255, 215, 0, 0.15);
      color: #fff;
    }

    .ink-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Eraser slider popup */
    .eraser-slider-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      min-width: 120px;
    }

    .eraser-slider-label {
      font-size: 10px;
      color: #aaa;
      font-family: 'Outfit', sans-serif;
    }

    .eraser-slider {
      width: 100px;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      outline: none;
    }

    .eraser-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--gold);
      cursor: pointer;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
    }

    /* Ink gauge display */
    .ink-gauge {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: #888;
      font-family: 'Outfit', sans-serif;
      white-space: nowrap;
    }

    /* Toast notification */
    .toast {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      color: #fff;
      padding: 12px 24px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 700;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 200;
    }

    .toast.visible {
      opacity: 1;
    }

    /* Ink Gauge Progress Bars */
    .hud-center {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .ink-bar-container {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .ink-bar-label {
      font-size: 12px;
    }

    .ink-bar {
      width: 60px;
      height: 8px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 4px;
      overflow: hidden;
    }

    .ink-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease-out;
    }

    .ink-bar.booster .ink-bar-fill {
      background: linear-gradient(90deg, #ff4444, #ff6600);
      box-shadow: 0 0 6px #ff6600;
    }

    .ink-bar.jump .ink-bar-fill {
      background: linear-gradient(90deg, #39ff14, #ccff00);
      box-shadow: 0 0 6px #ccff00;
    }

    /* ========== LOADING OVERLAY ========== */
    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a1628 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 500;
      transition: opacity 0.5s ease-out;
    }

    #loadingOverlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    #loadingOverlay.hidden {
      display: none;
    }

    .loading-icon {
      font-size: 60px;
      animation: lugeSpin 1.5s ease-in-out infinite;
    }

    @keyframes lugeSpin {

      0%,
      100% {
        transform: translateY(0) rotate(-15deg);
      }

      25% {
        transform: translateY(-10px) rotate(0deg);
      }

      50% {
        transform: translateY(0) rotate(15deg);
      }

      75% {
        transform: translateY(-5px) rotate(0deg);
      }
    }

    .loading-text {
      color: var(--gold);
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 3px;
      margin-top: 20px;
      text-transform: uppercase;
    }

    .loading-dots::after {
      content: '';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {

      0%,
      20% {
        content: '';
      }

      40% {
        content: '.';
      }

      60% {
        content: '..';
      }

      80%,
      100% {
        content: '...';
      }
    }

    /* ========== RANKING SCREEN ========== */
    #rankingScreen {
      background: rgba(10, 22, 40, 0.95);
      justify-content: flex-start;
      padding: 30px 20px;
    }

    .ranking-header {
      text-align: center;
      margin-bottom: 20px;
    }

    .ranking-stage-title {
      font-size: 32px;
      font-weight: 900;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 20px var(--olympic-blue);
    }

    .ranking-list {
      width: 100%;
      max-width: 300px;
      background: rgba(20, 35, 60, 0.8);
      border-radius: 16px;
      padding: 15px;
      margin-bottom: 25px;
      max-height: 400px;
      overflow-y: auto;
    }

    .ranking-list-title {
      font-size: 12px;
      color: var(--gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 12px;
    }

    .ranking-entry {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      margin-bottom: 8px;
      transition: all 0.2s;
    }

    .ranking-entry:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .ranking-medal {
      font-size: 24px;
      width: 36px;
      text-align: center;
    }

    .ranking-rank {
      font-size: 16px;
      font-weight: 800;
      color: #666;
      width: 36px;
      text-align: center;
    }

    .ranking-name {
      flex: 1;
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      margin-left: 10px;
    }

    .ranking-time {
      font-size: 13px;
      font-family: monospace;
      color: #00ffcc;
    }

    .ranking-empty {
      text-align: center;
      color: #666;
      font-size: 12px;
      padding: 20px;
    }

    .ranking-loading {
      text-align: center;
      color: #aaa;
      font-size: 12px;
      padding: 20px;
    }

    .ranking-buttons {
      display: flex;
      flex-direction: row;
      /* [í•µì‹¬] ì„¸ë¡œ(column) -> ê°€ë¡œ(row)ë¡œ ë³€ê²½ */
      gap: 10px;
      /* ë²„íŠ¼ ì‚¬ì´ ê°„ê²© */
      width: 100%;
      max-width: 300px;
      /* ìœ„ìª½ ë­í‚¹ ë°•ìŠ¤ í¬ê¸°(300px)ì— ë§ì¶¤ */
      margin-top: 10px;
    }

    /* [ì¶”ê°€] ë²„íŠ¼ 2ê°œì˜ í¬ê¸°ì™€ ë†’ì´ë¥¼ ê°•ì œë¡œ í†µì¼ì‹œí‚¤ëŠ” ì½”ë“œ */
    .ranking-buttons button {
      flex: 1;
      /* ê³µê°„ì„ 50:50ìœ¼ë¡œ ë˜‘ê°™ì´ ë‚˜ëˆ  ê°€ì§ */
      width: auto !important;
      /* ê¸°ì¡´ì— ì„¤ì •ëœ ë„ˆë¹„ ë¬´ì‹œ */
      max-width: none !important;
      margin: 0 !important;
      height: 52px;
      /* ë²„íŠ¼ ë†’ì´ í†µì¼ */
      font-size: 15px;
      /* ê¸€ì í¬ê¸° í†µì¼ */
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }



    /* ========== OLYMPIC BROADCAST RESULT MODAL ========== */
    /* result-broadcastëŠ” ì•„ë˜ì— ìƒˆ ë²„ì „ ìˆìŒ */

    .result-finish-title {
      font-size: 42px;
      font-weight: 900;
      color: var(--gold);
      text-transform: uppercase;
      letter-spacing: 4px;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.6),
        0 4px 0 #B8860B;
      margin-bottom: 20px;
    }

    .result-rank-bar {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .result-rank-label {
      font-size: 10px;
      color: var(--gold);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .result-rank-name {
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      flex: 1;
      text-align: center;
    }

    .result-rank-time {
      font-size: 16px;
      font-family: 'Courier New', monospace;
      font-weight: 700;
      color: #00ffcc;
    }

    /* result-my-recordëŠ” ì•„ë˜ì— ìƒˆ ë²„ì „ ìˆìŒ */

    .result-my-label {
      font-size: 10px;
      color: #88ccff;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .result-my-time {
      font-size: 22px;
      font-family: 'Courier New', monospace;
      font-weight: 900;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
    }

    .result-gap {
      font-size: 14px;
      font-family: 'Courier New', monospace;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 6px;
      min-width: 80px;
      text-align: center;
    }

    .result-gap.slower {
      background: rgba(255, 70, 70, 0.3);
      color: #ff6666;
      border: 1px solid #ff4444;
    }

    .result-gap.faster {
      background: rgba(70, 150, 255, 0.3);
      color: #66aaff;
      border: 1px solid #4488ff;
    }

    .result-gap.first {
      background: rgba(255, 215, 0, 0.3);
      color: var(--gold);
      border: 1px solid var(--gold);
    }

    /* TOP 3 Entries */
    .result-top3 {
      width: 100%;
      margin-bottom: 15px;
    }

    .top3-entry {
      display: flex;
      align-items: center;
      padding: 10px 14px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      margin-bottom: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .top3-entry:first-child {
      border: 1px solid rgba(255, 215, 0, 0.4);
      background: rgba(255, 215, 0, 0.1);
    }

    .top3-medal {
      font-size: 20px;
      width: 32px;
      text-align: center;
    }

    .top3-name {
      flex: 1;
      font-size: 13px;
      font-weight: 700;
      color: #fff;
      margin-left: 8px;
    }

    .top3-time {
      font-size: 14px;
      font-family: 'Courier New', monospace;
      font-weight: 700;
      color: #00ffcc;
    }

    /* My Record Content Layout */
    .result-my-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }

    .result-my-record {
      background: linear-gradient(90deg,
          rgba(0, 129, 200, 0.4) 0%,
          rgba(0, 50, 100, 0.6) 50%,
          rgba(0, 129, 200, 0.4) 100%);
      border: 2px solid var(--olympic-blue);
      border-radius: 10px;
      padding: 14px 16px;
      margin: 10px 0;

      /* [í•µì‹¬ ìˆ˜ì •] ë°•ìŠ¤ í¬ê¸° ê°•ì œ ê³ ì • ë° ë‚´ë¶€ ê°€ë¡œ ì •ë ¬ */
      width: 100%;
      /* ê°€ë¡œ ê½‰ ì±„ìš°ê¸° */
      box-sizing: border-box;
      /* í…Œë‘ë¦¬ ë‘ê»˜ í¬í•¨í•´ì„œ í¬ê¸° ê³„ì‚° */
      display: flex;
      flex-direction: row;
      /* ì„¸ë¡œ(column) -> ê°€ë¡œ(row)ë¡œ ë³€ê²½ */
      justify-content: space-between;
      /* ì–‘ë ì •ë ¬ (MY - ì‹œê°„ - Gap) */
      align-items: center;
      /* ìˆ˜ì§ ì¤‘ì•™ ì •ë ¬ */
    }

    .result-fail-reason {
      font-size: 11px;
      color: #ff8888;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 8px;
    }

    .result-fail-reason:empty {
      display: none;
    }

    /* Button Container */
    .result-buttons {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      width: 100%;
      margin-top: 15px;
    }

    .result-buttons .modal-btn {
      width: 80%;
      max-width: 200px;
    }

    .result-broadcast {
      width: 100%;
      max-width: 320px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* ========== HALL OF FAME (ëª…ì˜ˆì˜ ì „ë‹¹) ========== */
    #hallOfFameScreen {
      background:
        radial-gradient(ellipse at 50% 20%, rgba(255, 215, 0, 0.08) 0%, transparent 60%),
        linear-gradient(180deg, #070d1a 0%, #0c1a33 40%, #0a1628 100%);
      justify-content: flex-start;
      padding: 24px 16px;
      overflow-y: auto;
    }

    .hof-title {
      font-size: 14px;
      font-weight: 900;
      color: var(--gold);
      letter-spacing: 3px;
      text-transform: uppercase;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      margin-bottom: 4px;
    }

    .hof-season {
      font-size: 11px;
      color: #667799;
      letter-spacing: 2px;
      margin-bottom: 20px;
    }

    /* ì‹œìƒëŒ€ (Podium) */
    .podium {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
      width: 100%;
      max-width: 320px;
    }

    .podium-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      border-radius: 10px 10px 0 0;
      padding: 10px 6px 8px;
      position: relative;
    }

    .podium-slot.gold {
      flex: 1.2;
      background: linear-gradient(180deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 215, 0, 0.05) 100%);
      border: 1px solid rgba(255, 215, 0, 0.3);
      min-height: 140px;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.15), inset 0 1px 0 rgba(255, 215, 0, 0.2);
    }

    .podium-slot.silver {
      flex: 1;
      background: linear-gradient(180deg, rgba(192, 192, 192, 0.12) 0%, rgba(192, 192, 192, 0.04) 100%);
      border: 1px solid rgba(192, 192, 192, 0.2);
      min-height: 110px;
    }

    .podium-slot.bronze {
      flex: 1;
      background: linear-gradient(180deg, rgba(205, 127, 50, 0.12) 0%, rgba(205, 127, 50, 0.04) 100%);
      border: 1px solid rgba(205, 127, 50, 0.2);
      min-height: 90px;
    }

    .podium-medal {
      font-size: 28px;
      margin-bottom: 4px;
    }

    .podium-name {
      font-size: 13px;
      font-weight: 800;
      color: #fff;
      margin-bottom: 2px;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 80px;
      white-space: nowrap;
    }

    .podium-slot.gold .podium-name {
      color: var(--gold);
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
    }

    .podium-time {
      font-size: 10px;
      font-family: 'Courier New', monospace;
      color: #00ffcc;
    }

    .podium-rank-bar {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      margin-top: 6px;
    }

    .podium-slot.gold .podium-rank-bar {
      background: linear-gradient(90deg, var(--gold), #FFA500);
    }

    .podium-slot.silver .podium-rank-bar {
      background: linear-gradient(90deg, var(--silver), #aaa);
    }

    .podium-slot.bronze .podium-rank-bar {
      background: linear-gradient(90deg, var(--bronze), #a06020);
    }

    /* 4~10ìœ„ ë¦¬ìŠ¤íŠ¸ */
    .hof-list {
      width: 100%;
      max-width: 320px;
      background: rgba(15, 25, 45, 0.8);
      border-radius: 12px;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .hof-entry {
      display: flex;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .hof-entry:last-child {
      border-bottom: none;
    }

    .hof-rank {
      width: 28px;
      font-size: 14px;
      font-weight: 800;
      color: #556;
    }

    .hof-name {
      flex: 1;
      font-size: 13px;
      font-weight: 700;
      color: #ccd;
    }

    .hof-time {
      font-size: 12px;
      font-family: 'Courier New', monospace;
      color: #00ddaa;
    }

    .hof-empty {
      text-align: center;
      color: #556;
      font-size: 12px;
      padding: 20px;
    }

    .hof-back-btn {
      margin-top: 20px;
      padding: 12px 30px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      color: #fff;
      font-family: 'Outfit', sans-serif;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .hof-back-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: var(--gold);
    }

    /* Home í™”ë©´ Hall of Fame ë²„íŠ¼ */
    .hof-home-btn {
      width: 90%;
      max-width: 300px;
      padding: 14px;
      margin-top: 15px;
      border: 2px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(180, 130, 0, 0.15));
      color: var(--gold);
      font-family: 'Outfit', sans-serif;
      font-size: 14px;
      font-weight: 800;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s;
      z-index: 10;
    }

    .hof-home-btn:hover {
      border-color: var(--gold);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }

    .hof-home-btn.hidden {
      display: none;
    }
  </style>
</head>

<body>

  <div id="gameContainer">
    <!-- LOADING OVERLAY -->
    <div id="loadingOverlay">
      <div class="loading-icon">ğŸ›·</div>
      <div class="loading-text">LOADING<span class="loading-dots"></span></div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- HOME SCREEN -->

    <div class="screen" id="introScreen" style="z-index: 200; background: rgba(10, 22, 40, 0.85);">
      <div class="medal-icon" style="font-size: 80px; margin-bottom: 20px;">ğŸ¥‡</div>
      <div class="home-title" style="font-size: 42px;">LUGE<br><span
          style="font-size: 24px; color:var(--gold);">OLYMPIC</span></div>

      <div style="margin-top: 40px; text-align: center;">
        <p
          style="color: #88aacc; font-size: 12px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px;">
          Athlete Registration</p>
        <input type="text" id="userNickname" placeholder="ë‹‰ë„¤ì„ (3~4ì)"
          style="width: 220px; padding: 15px; border-radius: 12px; border: 2px solid var(--olympic-blue); 
                      background: rgba(255,255,255,0.1); color: #fff; text-align: center; font-size: 20px; font-family: 'Outfit'; outline: none;">
        <p id="nickError"
          style="color: var(--olympic-red); font-size: 12px; margin-top: 10px; visibility: hidden; height: 15px;">
          í•œê¸€/ì˜ë¬¸ 3~4ìë¡œ ì…ë ¥í•˜ì„¸ìš”.
        </p>
      </div>

      <button id="btnRegister"
        style="margin-top: 30px; padding: 16px 50px; font-size: 18px; font-weight: 900; 
              background: linear-gradient(135deg, var(--olympic-blue), #005090); color: white; border: none; border-radius: 30px; 
              cursor: pointer; box-shadow: 0 0 20px rgba(0, 129, 200, 0.4); text-transform: uppercase; letter-spacing: 2px; transition: transform 0.2s;">
        ENTRY
      </button>
    </div>

    <div class="screen hidden" id="homeScreen">
      <div class="olympic-rings">
        <div class="ring blue"></div>
        <div class="ring yellow"></div>
        <div class="ring black"></div>
        <div class="ring green"></div>
        <div class="ring red"></div>
      </div>

      <div style="position: absolute; top: 20px; right: 20px; color: var(--gold); font-size: 12px; font-weight: 700;">
        PLAYER: <span id="displayNick">Unknown</span>
      </div>

      <div class="home-title" style="margin-top: 60px;">SELECT STAGE</div>
      <div class="level-grid" id="levelGrid" style="margin-top: 20px;"></div>

      <!-- â–¼ ëª…ì˜ˆì˜ ì „ë‹¹ ë²„íŠ¼ (Stage 10 í´ë¦¬ì–´ ì‹œì—ë§Œ í‘œì‹œ) -->
      <button class="hof-home-btn hidden" id="btnHallOfFame">ğŸ† Hall of Fame</button>
    </div>

    <!-- RANKING SCREEN -->
    <div class="screen hidden" id="rankingScreen">
      <div class="ranking-header">
        <div class="medal-icon" style="font-size: 50px;">ğŸ†</div>
        <div class="ranking-stage-title" id="rankingStageTitle">STAGE 1</div>
      </div>

      <div class="ranking-list">
        <div class="ranking-list-title">ğŸ… World Records</div>
        <div id="rankingEntries">
          <div class="ranking-loading">Loading...</div>
        </div>
      </div>

      <div class="ranking-buttons">
        <button class="play-btn" id="btnRankingStart">GAME START</button>
        <button class="modal-btn secondary" id="btnRankingBack">â† BACK</button>
      </div>
    </div>

    <!-- GAME UI -->
    <div class="game-ui hidden" id="gameUI">
      <div class="top-bar">
        <div class="hud-left">
          <div class="hud-box">
            <div class="hud-title">STAGE</div>
            <div class="hud-value" id="uiStage">1</div>
          </div>

          <div class="hud-box">
            <div class="hud-title">TIME</div>
            <div class="hud-value time" id="uiTime">0.00000</div>
          </div>

          <div class="hud-center" style="margin-left: 10px;">
            <div class="ink-bar-container">
              <div class="ink-bar-label">ğŸ”¥</div>
              <div class="ink-bar booster">
                <div class="ink-bar-fill" id="boosterBar"></div>
              </div>
            </div>
            <div class="ink-bar-container">
              <div class="ink-bar-label">ğŸ¦˜</div>
              <div class="ink-bar jump">
                <div class="ink-bar-fill" id="jumpBar"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="hud-right" style="flex-direction: column; align-items: flex-end;">
          <button class="hud-btn" id="btnSave" title="Save Setup">ğŸ’¾</button>
          <button class="hud-btn" id="btnLoad" title="Load Setup">ğŸ“‚</button>
          <button class="hud-btn" id="btnHome" title="Home">ğŸ </button>
          <button class="hud-btn" id="btnReplay" title="Replay">ğŸ¥</button>
        </div>
      </div>
      <div id="replayPanel" class="toolbar" style="display: none; justify-content: center; align-items: center; gap: 8px; z-index: 20; background: rgba(20, 30, 50, 0.85); backdrop-filter: blur(8px); border-radius: 25px; padding: 10px 15px; border: 1px solid rgba(0, 255, 204, 0.15); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); width: 100%; max-width: 400px; margin: 0 auto;">
        
        <button id="btnReplayPlayPause" style="width: 44px; height: 44px; flex: none; border-radius: 50%; background: linear-gradient(135deg, #00ffcc, #0088ff); border: none; font-size: 18px; color: #121212; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 15px rgba(0, 255, 204, 0.6); cursor: pointer; transition: transform 0.1s ease-in-out;">â–¶</button>
        
        <div id="replaySpeedControls" style="display: flex; gap: 4px; background: rgba(0,0,0,0.5); padding: 4px; border-radius: 12px; box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);">
          <button class="speed-btn" data-speed="0.2" style="--ring-color: #0081C8; color: white; border: 2px solid #0081C8; background: transparent; border-radius: 8px; width: 30px; height: 30px; font-weight: bold; font-family: 'Courier New', monospace; font-size: 13px; cursor: pointer; transition: 0.2s;">.2</button>
          <button class="speed-btn" data-speed="0.4" style="--ring-color: #FCB131; color: white; border: 2px solid #FCB131; background: transparent; border-radius: 8px; width: 30px; height: 30px; font-weight: bold; font-family: 'Courier New', monospace; font-size: 13px; cursor: pointer; transition: 0.2s;">.4</button>
          <button class="speed-btn" data-speed="0.6" style="--ring-color: #ffffff; color: white; border: 2px solid #ffffff; background: transparent; border-radius: 8px; width: 30px; height: 30px; font-weight: bold; font-family: 'Courier New', monospace; font-size: 13px; cursor: pointer; transition: 0.2s;">.6</button>
          <button class="speed-btn" data-speed="0.8" style="--ring-color: #00A651; color: white; border: 2px solid #00A651; background: transparent; border-radius: 8px; width: 30px; height: 30px; font-weight: bold; font-family: 'Courier New', monospace; font-size: 13px; cursor: pointer; transition: 0.2s;">.8</button>
          <button class="speed-btn" data-speed="1.0" style="--ring-color: #EE334E; color: #EE334E; border: 2px solid #EE334E; background: rgba(255,255,255,0.1); box-shadow: 0 0 10px #EE334E, inset 0 0 5px #EE334E; border-radius: 8px; width: 30px; height: 30px; font-weight: bold; font-family: 'Courier New', monospace; font-size: 13px; cursor: pointer; transition: 0.2s;">1x</button>
        </div>
        
        <button id="btnReplayExit" style="height: 40px; padding: 0 12px; background: linear-gradient(135deg, #ff5555, #aa0000); border: none; border-radius: 12px; color: white; font-size: 12px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(255, 50, 50, 0.3); transition: all 0.2s;">â¹ EXIT</button>
      </div>

      <div id="mainToolbar" class="toolbar">
        <button id="btnStart" class="tool-btn play-btn">Start</button>

        <div class="tool-container">
          <button id="btnDraw" class="tool-btn active">ğŸ–Œ Draw</button>
          <div class="tool-popup" id="drawPopup">
            <div class="popup-content">
              <button class="ink-btn active" data-type="normal">
                <div class="ink-dot"></div>
                Normal
              </button>
              <button class="ink-btn" data-type="booster">
                <div class="ink-dot"></div>
                Boost
              </button>
              <button class="ink-btn" data-type="jump">
                <div class="ink-dot"></div>
                Jump
              </button>
            </div>
          </div>
        </div>

        <div class="tool-container">
          <button id="btnEraser" class="tool-btn">ğŸ§¹ Eraser</button>
          <div class="tool-popup" id="eraserPopup">
            <div class="popup-content">
              <div class="eraser-slider-container">
                <span class="eraser-slider-label">Size: <span id="eraserSizeLabel">15</span>px</span>
                <input type="range" class="eraser-slider" id="eraserSlider" min="3" max="40" value="15">
              </div>
            </div>
          </div>
        </div>

        <!-- â–¼ Undo ë²„íŠ¼ (1:1 ì •ì‚¬ê°í˜•) -->
        <button id="btnUndo" class="tool-btn tool-btn-square" title="Undo">â†©ï¸</button>
      </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- HALL OF FAME SCREEN (ëª…ì˜ˆì˜ ì „ë‹¹) -->
    <div class="screen hidden" id="hallOfFameScreen">
      <div class="hof-title">ğŸ† HALL OF FAME</div>
      <div class="hof-season">SEASON 1 â€” COMBINED TIME</div>

      <!-- ì‹œìƒëŒ€: 2ìœ„(left) - 1ìœ„(center) - 3ìœ„(right) -->
      <div class="podium" id="hofPodium">
        <div class="podium-slot silver" id="podium2">
          <div class="podium-medal">ğŸ¥ˆ</div>
          <div class="podium-name" id="podiumName2">---</div>
          <div class="podium-time" id="podiumTime2">--:--.---</div>
          <div class="podium-rank-bar"></div>
        </div>
        <div class="podium-slot gold" id="podium1">
          <div class="podium-medal">ğŸ¥‡</div>
          <div class="podium-name" id="podiumName1">---</div>
          <div class="podium-time" id="podiumTime1">--:--.---</div>
          <div class="podium-rank-bar"></div>
        </div>
        <div class="podium-slot bronze" id="podium3">
          <div class="podium-medal">ğŸ¥‰</div>
          <div class="podium-name" id="podiumName3">---</div>
          <div class="podium-time" id="podiumTime3">--:--.---</div>
          <div class="podium-rank-bar"></div>
        </div>
      </div>

      <!-- 4~10ìœ„ ë¦¬ìŠ¤íŠ¸ -->
      <div class="hof-list" id="hofList">
        <div class="hof-empty">Loading...</div>
      </div>

      <button class="hof-back-btn" id="btnHofBack">â† BACK</button>
    </div>

    <div class="tutorial hidden" id="tutorial">
      Draw lines to guide<br>the rider to all â­!
    </div>

    <!-- RESULT MODAL (ì˜¬ë¦¼í”½ ì¤‘ê³„ ìŠ¤íƒ€ì¼) -->
    <div class="modal-overlay" id="resultModal">
      <div class="result-broadcast">
        <div class="result-finish-title" id="resultTitle">FINISH!</div>

        <!-- TOP 3 ê¸°ë¡ í‘œì‹œ -->
        <div class="result-top3" id="resultTop3">
          <div class="top3-entry" id="top3Entry1">
            <span class="top3-medal">ğŸ¥‡</span>
            <span class="top3-name" id="top3Name1">---</span>
            <span class="top3-time" id="top3Time1">--:--.---</span>
          </div>
          <div class="top3-entry" id="top3Entry2">
            <span class="top3-medal">ğŸ¥ˆ</span>
            <span class="top3-name" id="top3Name2">---</span>
            <span class="top3-time" id="top3Time2">--:--.---</span>
          </div>
          <div class="top3-entry" id="top3Entry3">
            <span class="top3-medal">ğŸ¥‰</span>
            <span class="top3-name" id="top3Name3">---</span>
            <span class="top3-time" id="top3Time3">--:--.---</span>
          </div>
        </div>

        <!-- ë‚´ ê¸°ë¡ ë°” -->
        <div class="result-my-record">
          <div class="result-my-content">
            <span class="result-my-label">MY</span>
            <span class="result-my-time" id="resultMyTime">00:00.000</span>
            <span class="result-gap" id="resultGap">--.---</span>
          </div>
          <div class="result-fail-reason" id="resultFailReason"></div>
        </div>

        <div class="result-buttons">
          <button class="modal-btn primary" id="btnNext">Next Stage</button>
          <button class="modal-btn secondary" id="btnRetry">Retry</button>
          <button class="modal-btn secondary" id="btnResultHome">Home</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // â–¼ [ì¤‘ìš”] ì´ ì¤„ì„ importë³´ë‹¤ ë¬´ì¡°ê±´ ìœ„ì— ì ìœ¼ì„¸ìš”!
    // self.FIREBASE_APPCHECK_DEBUG_TOKEN = true;

    import { getAuth, signInAnonymously }
      from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, collection, doc, getDoc, setDoc, query, where, orderBy, limit, getDocs, serverTimestamp }
      from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    import { initializeAppCheck, ReCaptchaV3Provider }
      from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app-check.js";

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";



    const firebaseConfig = {
      apiKey: "AIzaSyBhnvoCQh8B38HRzBe0551aBS6Ve6cTRtE",
      authDomain: "luge-olympic.firebaseapp.com",
      projectId: "luge-olympic",
      storageBucket: "luge-olympic.firebasestorage.app",
      messagingSenderId: "893309182264",
      appId: "1:893309182264:web:8dc51f15811e352a5921cd",
      measurementId: "G-GKCHKLN4S8"
    };

    const app = initializeApp(firebaseConfig);
    initializeAppCheck(app, {
      provider: new ReCaptchaV3Provider("6LdIY2UsAAAAAJXJIXdneJh-A3gUtlqdcNPlU_s4"),
      isTokenAutoRefreshEnabled: true,
    });


    const db = getFirestore(app);

    const auth = getAuth(app);
    await signInAnonymously(auth);




    (() => {
      // ============================================
      // CONSTANTS
      // ============================================
      const VIRTUAL_W = 360;
      const VIRTUAL_H = 640;
      const MAX_STAGE = 10;

      const PHYS = {
        gravity: 800,
        friction: 0.001,
        bounce: 0.12,
        airDrag: 0.0003,
        rotationSpeed: 3.0
      };

      // ============================================
      // [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] í•µì‹¬ íŒŒë¼ë¯¸í„°
      // ============================================
      // â”€â”€ Fixed Time Step â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: dtë¥¼ ê³ ì •í•¨ìœ¼ë¡œì¨ í”„ë ˆì„ìœ¨ ë…ë¦½ì  ì‹œë®¬ë ˆì´ì…˜ ë³´ì¥.
      // 60Hz ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •. ì €ì‚¬ì–‘ ê¸°ê¸°ì—ì„œ í”„ë ˆì„ ë“œëì´ ë°œìƒí•´ë„
      // accumulator íŒ¨í„´ì´ ë™ì¼ íšŸìˆ˜ì˜ ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ë¥¼ ë³´ì¥í•œë‹¤.
      const FIXED_DT = 1 / 60;            // ê³ ì • ë¬¼ë¦¬ íƒ€ì„ìŠ¤í… (â‰ˆ16.67ms)
      const MAX_PHYSICS_STEPS = 5;         // í•œ í”„ë ˆì„ë‹¹ ìµœëŒ€ ë¬¼ë¦¬ ì—°ì‚° íšŸìˆ˜
      const MAX_ACCUMULATOR = FIXED_DT * MAX_PHYSICS_STEPS; // Safety valve (â‰ˆ83.3ms)

      // â”€â”€ LUT (Look-Up Table) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: ì‹¤ì‹œê°„ ë² ì§€ì–´/ìŠ¤í”Œë¼ì¸ ì—°ì‚° ì œê±°.
      // pointerup ì‹œì ì— ëª¨ë“  ì„ ì„ 2px ê°„ê²©ì˜ ê³ ë°€ë„ ì¢Œí‘œë¡œ Pre-bake.
      // ë¬¼ë¦¬ íŒì •ì€ LUT ì (ê±°ë¦¬ ê¸°ë°˜)ìœ¼ë¡œë§Œ ìˆ˜í–‰ â†’ ì—°ì‚° ê²°ì •ë¡  í™•ë³´.
      const LUT_DENSITY = 2;              // LUT í¬ì¸íŠ¸ ê°„ê²© (px)
      const LUT_COLLISION_RADIUS = 6;     // ì¶©ëŒ íŒì • ë°˜ê²½ (px)

      // â”€â”€ Spatial Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: ì „ì²´ LUT ìˆœíšŒ O(n)ì„ Grid ê¸°ë°˜ O(1) ì¡°íšŒë¡œ ìµœì í™”.
      // í”Œë ˆì´ì–´ ì£¼ë³€ 3x3 ì…€(120x120px ì˜ì—­)ë§Œ ê²€ì‚¬.
      const GRID_CELL_SIZE = 40;          // ê·¸ë¦¬ë“œ ì…€ í¬ê¸° (px)

      // â”€â”€ Anti-Tunneling Sub-stepping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: ê³ ì†(400px/sâ†‘) ì‹œ dtë¥¼ ìë™ ë¶„í• í•˜ì—¬
      // ì„  ê´€í†µ(tunneling) í˜„ìƒì„ ë°©ì§€. MAX_SUBSTEPSë¡œ ì—°ì‚° ìƒí•œ ì œì–´.
      const SUB_STEP_THRESHOLD = 400;     // ì„œë¸ŒìŠ¤í… í™œì„±í™” ì†ë„ ì„ê³„ì¹˜ (px/s)
      const MAX_SUBSTEPS = 20;             // [ë³€ê²½] ê³ ì† ì¶©ëŒ ì •ë°€ë„ í–¥ìƒ (10 -> 20)

      // â”€â”€ Dynamic Collision Radius â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: ê³ ì† ì´ë™ ì‹œ ì¶©ëŒ ë°˜ê²½ì„ ì†ë„ ë¹„ë¡€ë¡œ í™•ì¥.
      // baseRadius + (speed * DYNAMIC_RADIUS_K)
      const DYNAMIC_RADIUS_K = 0.015;     // ë™ì  ë°˜ê²½ í™•ì¥ ê³„ìˆ˜

      // â”€â”€ CCD & Soft-Clamping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: ë¶€ìŠ¤í„° ì„  ìœ„ì—ì„œ ê³¼ë„í•œ ë°˜ë°œë ¥ ì–µì œ.
      const BOOSTER_SNAP_FACTOR = 0.35;   // ë¶€ìŠ¤í„° ì„  ìœ„ì¹˜ ë³´ì • ê°•ë„ (0~1)

      // â”€â”€ Deterministic PRNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ë°ì´í„° ì „ëµ: Math.random() ì™„ì „ ì œê±°.
      // ìŠ¤í…Œì´ì§€ ë²ˆí˜¸ Ã— 1000 + 7ì„ seedë¡œ ì‚¬ìš©í•˜ì—¬
      // íŒŒí‹°í´ ë“± ì‹œê° íš¨ê³¼ê¹Œì§€ 100% ì¬í˜„ ê°€ëŠ¥.
      const PRNG_SEED_MULTIPLIER = 1000;
      const PRNG_SEED_OFFSET = 7;

      // Global ink limits for special types
      const INK_LIMITS = {
        booster: 150,
        jump: 100
      };

      const STALL_THRESHOLD = 25;
      const STALL_TIME = 3000;

      // â”€â”€ Undo System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const UNDO_MAX = 20;                // ìµœëŒ€ ìŠ¤ëƒ…ìƒ· ì €ì¥ ìˆ˜

      // Hardcoded star positions for each stage (each star must be at same or lower Y than previous)
      // Stages 1-3: Easy - gentle curves
      // Stages 4-6: Medium - wider spread, some horizontal movement
      // Stages 7-10: Hard - tight paths, requires precise drawing
      const STAGE_STARS = {
        1: [{ x: 200, y: 350 }],
        2: [{ x: 120, y: 280 }, { x: 260, y: 450 }],
        3: [{ x: 80, y: 200 }, { x: 220, y: 350 }, { x: 300, y: 500 }],
        4: [{ x: 280, y: 180 }, { x: 100, y: 280 }, { x: 260, y: 400 }, { x: 140, y: 520 }],
        5: [{ x: 60, y: 160 }, { x: 180, y: 240 }, { x: 300, y: 320 }, { x: 120, y: 420 }, { x: 280, y: 530 }],
        6: [{ x: 300, y: 150 }, { x: 100, y: 220 }, { x: 280, y: 300 }, { x: 80, y: 380 }, { x: 250, y: 460 }, { x: 180, y: 540 }],
        7: [{ x: 50, y: 140 }, { x: 150, y: 180 }, { x: 300, y: 250 }, { x: 100, y: 320 }, { x: 280, y: 390 }, { x: 60, y: 460 }, { x: 240, y: 540 }],
        8: [{ x: 280, y: 130 }, { x: 80, y: 180 }, { x: 260, y: 240 }, { x: 100, y: 310 }, { x: 300, y: 370 }, { x: 60, y: 430 }, { x: 220, y: 490 }, { x: 160, y: 550 }],
        9: [{ x: 60, y: 125 }, { x: 200, y: 170 }, { x: 320, y: 220 }, { x: 80, y: 280 }, { x: 260, y: 340 }, { x: 120, y: 400 }, { x: 300, y: 450 }, { x: 60, y: 500 }, { x: 220, y: 555 }],
        10: [{ x: 300, y: 115 }, { x: 60, y: 160 }, { x: 280, y: 210 }, { x: 100, y: 260 }, { x: 320, y: 310 }, { x: 50, y: 360 }, { x: 260, y: 410 }, { x: 120, y: 460 }, { x: 300, y: 510 }, { x: 180, y: 560 }]
      };

      // Ink type colors
      const INK_COLORS = {
        normal: { line: '#ffffff', glow: '#00ffcc' },
        booster: { line: '#ff4444', glow: '#ff6600' },
        jump: { line: '#39ff14', glow: '#ccff00' }
      };

      // ============================================
      // DOM ELEMENTS
      // ============================================
      const container = document.getElementById('gameContainer');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { alpha: true });

      const homeScreen = document.getElementById('homeScreen');
      const gameUI = document.getElementById('gameUI');
      const tutorial = document.getElementById('tutorial');
      const resultModal = document.getElementById('resultModal');
      const levelGrid = document.getElementById('levelGrid');

      // ============================================
      // GAME STATE
      // ============================================
      let scale = 1;
      let offsetX = 0, offsetY = 0;

      // [ì—¬ê¸°ì— ì„ ì–¸]
      let currentUserNickname = "";

      const state = {
        screen: 'home',
        mode: 'build',
        stage: 1,
        starsCollected: 0,
        starsTotal: 1,
        timer: 0,
        timerRunning: false,
        stallTimer: 0,
        currentInkType: 'normal',
        boosterInkUsed: 0,
        jumpInkUsed: 0,
        eraserSize: 15,
        showEraserPreview: false,

        // â–¼â–¼â–¼ [ì‹ ê·œ ì¶”ê°€] ë¦¬í”Œë ˆì´ ì‹œìŠ¤í…œ ë³€ìˆ˜ â–¼â–¼â–¼
        timeScale: 1.0,      // ì‹œê°„ ë°°ìœ¨ (0.1 ~ 2.0)
        isPaused: false,     // ë¦¬í”Œë ˆì´ ì¼ì‹œì •ì§€ ìƒíƒœ

        // â–¼â–¼â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] ìƒíƒœ ë³€ìˆ˜ â–¼â–¼â–¼
        seed: 0,             // PRNG ì‹œë“œ (= stage * 1000 + 7)
        rng: null,           // mulberry32 ì¸ìŠ¤í„´ìŠ¤. Math.random() ëŒ€ì²´.
        lutData: [],         // Pre-baked LUT ë°ì´í„° ë°°ì—´
        spatialGrid: {},     // Spatial Grid (í•´ì‹œë§µ)

        // â–¼â–¼â–¼ [ë°ì´í„° ë¶„ì„ìš©] ë³€ìˆ˜ â–¼â–¼â–¼
        retryCount: 0,       // í˜„ì¬ ìŠ¤í…Œì´ì§€ ì¬ì‹œë„ íšŸìˆ˜
        strokeCount: 0,      // ì„  ê·¸ë¦¬ê¸° íšŸìˆ˜
        eraserCount: 0,      // ì§€ìš°ê°œ ì‚¬ìš© íšŸìˆ˜
        startTime: 0,        // ê²Œì„ ì‹œì‘ ì‹œê°„ (í”Œë ˆì´ íƒ€ì„ ê³„ì‚°ìš©)
        deathX: 0,           // ì£½ì€ ìœ„ì¹˜ X
        deathY: 0            // ì£½ì€ ìœ„ì¹˜ Y
      };



      // ============================================
      // [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] PRNG (Mulberry32)
      // ============================================
      // ë°ì´í„° ì „ëµ: Math.random()ì˜ ë¹„ê²°ì •ë¡ ì  íŠ¹ì„±ì„ ì œê±°.
      // ë™ì¼ seed â†’ ë™ì¼ ë‚œìˆ˜ì—´ì„ ë³´ì¥í•˜ëŠ” Mulberry32 ì•Œê³ ë¦¬ì¦˜.
      // ì¶œë ¥ ë²”ìœ„: [0, 1) â€” Math.random()ê³¼ ë™ì¼í•œ ì¸í„°í˜ì´ìŠ¤.
      // ì°¸ê³ : https://gist.github.com/tommyettinger/46a874533244883189143505d203312c
      function mulberry32(seed) {
        let s = seed | 0;
        return function () {
          s = s + 0x6D2B79F5 | 0;
          let t = Math.imul(s ^ s >>> 15, 1 | s);
          t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
      }

      // ============================================
      // [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] LUT (Look-Up Table) Builder
      // ============================================
      // ë°ì´í„° ì „ëµ: ìœ ì €ê°€ ê·¸ë¦° ì›ë³¸ stroke ë°ì´í„°ë¥¼
      // LUT_DENSITY(2px) ê°„ê²©ì˜ ê³ ë°€ë„ ì¢Œí‘œ ë°°ì—´ë¡œ Pre-bake.
      // ì´í›„ ë¬¼ë¦¬ íŒì •ì€ ì´ LUT ë°ì´í„°ë§Œ ì‚¬ìš©í•˜ì—¬
      // ì‹¤ì‹œê°„ ê³¡ì„  ì—°ì‚°ì„ ì™„ì „ ì œê±° â†’ ê²°ì •ë¡  í™•ë³´ + ì—°ì‚° ë¹„ìš© ì ˆê°.
      //
      // ë°˜í™˜ êµ¬ì¡°: [{ points: [{x,y}, ...], type: 'normal'|'booster'|'jump' }, ...]
      function buildLUT(strokesArr) {
        const lut = [];
        for (const stroke of strokesArr) {
          if (stroke.pts.length < 2) continue;
          const lutPoints = [];
          for (let i = 0; i < stroke.pts.length - 1; i++) {
            const a = stroke.pts[i], b = stroke.pts[i + 1];
            const segLen = Math.hypot(b.x - a.x, b.y - a.y);
            // ì„¸ê·¸ë¨¼íŠ¸ë¥¼ LUT_DENSITY ê°„ê²©ìœ¼ë¡œ ë¶„í• í•˜ì—¬ í¬ì¸íŠ¸ ìƒì„±
            const steps = Math.max(1, Math.ceil(segLen / LUT_DENSITY));
            for (let s = 0; s <= steps; s++) {
              const t = s / steps;
              lutPoints.push({
                x: a.x + (b.x - a.x) * t,
                y: a.y + (b.y - a.y) * t
              });
            }
          }
          // ì¤‘ë³µ í¬ì¸íŠ¸ ì œê±° (ì¸ì ‘ í¬ì¸íŠ¸ ê±°ë¦¬ < 0.5px)
          const deduped = [lutPoints[0]];
          for (let i = 1; i < lutPoints.length; i++) {
            const prev = deduped[deduped.length - 1];
            if (Math.hypot(lutPoints[i].x - prev.x, lutPoints[i].y - prev.y) >= 0.5) {
              deduped.push(lutPoints[i]);
            }
          }
          if (deduped.length >= 2) {
            lut.push({ points: deduped, type: stroke.type || 'normal' });
          }
        }
        return lut;
      }

      // ============================================
      // [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] Spatial Grid Builder
      // ============================================
      // ë°ì´í„° ì „ëµ: ì „ì²´ LUT ì ì„ GRID_CELL_SIZE(40px) ê¸°ì¤€
      // í•´ì‹œ ê·¸ë¦¬ë“œì— ë“±ë¡. ë¬¼ë¦¬ íŒì • ì‹œ í”Œë ˆì´ì–´ ì£¼ë³€ 3x3 ì…€ë§Œ
      // ì¡°íšŒí•˜ë©´ ë˜ë¯€ë¡œ O(n) â†’ O(k) (k: ì£¼ë³€ ì…€ ë‚´ ì  ìˆ˜)ë¡œ
      // ê²€ìƒ‰ ë¹„ìš© ëŒ€í­ ì ˆê°.
      //
      // Grid êµ¬ì¡°: { "cellX,cellY": [{ lutIdx, ptIdx, x, y }, ...], ... }
      function buildSpatialGrid(lutData) {
        const grid = {};
        for (let li = 0; li < lutData.length; li++) {
          const entry = lutData[li];
          for (let pi = 0; pi < entry.points.length; pi++) {
            const p = entry.points[pi];
            const key = getCellKey(p.x, p.y);
            if (!grid[key]) grid[key] = [];
            grid[key].push({ lutIdx: li, ptIdx: pi, x: p.x, y: p.y });
          }
        }
        return grid;
      }

      // Grid ì…€ í‚¤ ìƒì„±: ì¢Œí‘œ â†’ "cellX,cellY" ë¬¸ìì—´
      function getCellKey(x, y) {
        return `${Math.floor(x / GRID_CELL_SIZE)},${Math.floor(y / GRID_CELL_SIZE)}`;
      }

      // í”Œë ˆì´ì–´ ì£¼ë³€ 3x3 ì…€ ë‚´ LUT í¬ì¸íŠ¸ ì¡°íšŒ
      // ë°ì´í„° ì „ëµ: 9ê°œ ì…€ë§Œ ê²€ì‚¬í•˜ë¯€ë¡œ ìµœì•…ì˜ ê²½ìš°ì—ë„
      // í•œ í”„ë ˆì„ë‹¹ ì¡°íšŒ í¬ì¸íŠ¸ ìˆ˜ê°€ 120x120px ì˜ì—­ìœ¼ë¡œ ì œí•œë¨.
      function getNearbyLUTPoints(grid, px, py) {
        const results = [];
        const cx = Math.floor(px / GRID_CELL_SIZE);
        const cy = Math.floor(py / GRID_CELL_SIZE);
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${cx + dx},${cy + dy}`;
            if (grid[key]) {
              for (let i = 0; i < grid[key].length; i++) {
                results.push(grid[key][i]);
              }
            }
          }
        }
        return results;
      }

      // LUT + Spatial Grid ë™ì‹œ ì¬ìƒì„± í—¬í¼
      // pointerup, eraseAtPoint, Start ë²„íŠ¼ ë“±ì—ì„œ í˜¸ì¶œ.
      function rebuildCollisionData() {
        state.lutData = buildLUT(strokes);
        state.spatialGrid = buildSpatialGrid(state.lutData);
      }

      // -----------------[ì—¬ê¸°ë¶€í„° ì¶”ê°€]-----------------
      async function saveScoreToFirebase(stage, newTime) {
        if (!currentUserNickname) return;
        // if (!auth.currentUser) return; // UIDê°€ ì—†ì–´ë„ ë‹‰ë„¤ì„ìœ¼ë¡œ ì €ì¥í•˜ê²Œ ì´ ì¤„ì€ ì£¼ì„ ì²˜ë¦¬

        // [í•µì‹¬ ìˆ˜ì •] ë¬¸ì„œ IDë¥¼ 'UID' ëŒ€ì‹  'ë‹‰ë„¤ì„'ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
        // ì´ë ‡ê²Œ í•˜ë©´ 'ìš°ê°„ë‹¤'ëŠ” Stage 1ì—ì„œ ë¬´ì¡°ê±´ í•˜ë‚˜ì˜ ê¸°ë¡ë§Œ ê°–ê²Œ ë©ë‹ˆë‹¤.
        const docId = `record_${currentUserNickname}_stage${stage}`;
        const docRef = doc(db, "rankings", docId);

        try {
          const docSnap = await getDoc(docRef);

          const payload = {
            // uid: auth.currentUser ? auth.currentUser.uid : 'anon', // UIDëŠ” ì°¸ê³ ìš©ìœ¼ë¡œë§Œ ì €ì¥
            nickname: currentUserNickname,
            stage,
            time: Number(newTime.toFixed(5)),
            updatedAt: serverTimestamp(),
          };

          if (!docSnap.exists()) {
            // 1. ê¸°ë¡ì´ ì•„ì˜ˆ ì—†ìœ¼ë©´ -> ìƒˆë¡œ ì €ì¥
            await setDoc(docRef, payload);
          } else {
            // 2. ê¸°ë¡ì´ ì´ë¯¸ ìˆìœ¼ë©´ -> ì‹ ê¸°ë¡ì¼ ë•Œë§Œ ë®ì–´ì“°ê¸°
            const oldTime = docSnap.data().time;
            if (newTime < oldTime) {
              await setDoc(docRef, payload, { merge: true });
              console.log("New Record Updated!");
            } else {
              console.log("Old record was better, skipping.");
            }
          }
        } catch (e) {
          console.error("Firebase Save Error:", e);
        }
      }

      // â–¼â–¼â–¼ [ì‹ ê·œ] ë””ë°”ì´ìŠ¤/ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ëª¨ë“ˆ â–¼â–¼â–¼
      function getSystemInfo() {
        const ua = navigator.userAgent;
        let os = 'Unknown', osVer = '0', model = 'Unknown';
        let browser = 'Unknown', engine = 'Unknown';

        // 1. OS & Version íŒŒì‹±
        if (/Android/i.test(ua)) {
          os = 'Android';
          const match = ua.match(/Android\s([0-9\.]+)/);
          if (match) osVer = match[1];
          // ì•ˆë“œë¡œì´ë“œ ëª¨ë¸ëª… ì¶”ì¶œ ì‹œë„ (ex: SM-G991N)
          const modelMatch = ua.match(/;\s([^;]+)\sBuild/);
          if (modelMatch) model = modelMatch[1];
        } else if (/iPhone|iPad|iPod/i.test(ua)) {
          os = 'iOS';
          const match = ua.match(/OS\s([0-9_]+)/);
          if (match) osVer = match[1].replace(/_/g, '.');
          model = /iPhone/i.test(ua) ? 'iPhone' : 'iPad';
        } else if (/Windows/i.test(ua)) os = 'Windows';
        else if (/Mac/i.test(ua)) os = 'Mac';

        // 2. Browser íŒŒì‹± (ì¹´ì¹´ì˜¤í†¡, ë„¤ì´ë²„ ì¸ì•± ë“± í¬í•¨)
        if (/KAKAOTALK/i.test(ua)) browser = 'KakaoTalk';
        else if (/NAVER/i.test(ua)) browser = 'NaverApp';
        else if (/Chrome/i.test(ua)) browser = 'Chrome';
        else if (/Safari/i.test(ua)) browser = 'Safari';
        else if (/Firefox/i.test(ua)) browser = 'Firefox';

        // 3. Engine Info
        if (/AppleWebKit/i.test(ua)) engine = 'AppleWebKit';
        else if (/Gecko/i.test(ua)) engine = 'Gecko';

        // 4. Platform & Input
        const isMobile = /Mobi|Android/i.test(ua);
        const platform = isMobile ? 'MOBILE' : 'PC';
        const control = ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? 'TOUCH' : 'MOUSE';

        return {
          os, osVer, browser, model, engine,
          platform,
          resolution: `${window.screen.width}x${window.screen.height}`, // í•´ìƒë„
          control,
          raw_ua: ua // ì›ë³¸ UA (í˜¹ì‹œ ëª¨ë¥¼ ë¶„ì„ìš©)
        };
      }



      // â–¼â–¼â–¼ [ìˆ˜ì •ë¨] ì‹œìŠ¤í…œ ì •ë³´ê°€ í¬í•¨ëœ ë¡œê·¸ ì €ì¥ í•¨ìˆ˜ â–¼â–¼â–¼
      async function saveGameLog(result, failReason = null) {
        if (!currentUserNickname) return;

        try {
          // 1. ì‹œìŠ¤í…œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
          const sys = getSystemInfo();

          const logRef = doc(collection(db, "game_logs"));

          const logData = {
            // [Basic Info]
            nickname: currentUserNickname,
            uid: auth.currentUser ? auth.currentUser.uid : 'anon',
            stage: state.stage,
            result: result,
            reason: failReason,

            // [Detailed System Info] - ìš”ì²­í•˜ì‹  êµ¬ì¡° ê·¸ëŒ€ë¡œ ì ìš©
            os: sys.os,
            osVer: sys.osVer,
            browser: sys.browser,
            model: sys.model,
            engine: sys.engine,

            // [Environment Info]
            platform: sys.platform,
            screen: sys.resolution,
            control: sys.control,

            // [Raw Data Archiving]
            ua_full: sys.raw_ua,

            // [Behavior Data]
            retry_count: state.retryCount,
            stroke_count: state.strokeCount,
            eraser_count: state.eraserCount,

            // [Ink Usage]
            ink_booster: Number(state.boosterInkUsed.toFixed(2)),
            ink_jump: Number(state.jumpInkUsed.toFixed(2)),

            // [Time & Location]
            play_time: Number(state.timer.toFixed(3)),
            death_pos: failReason ? { x: Math.round(state.deathX), y: Math.round(state.deathY) } : null,

            created_at: serverTimestamp()
          };

          // ë¹„ë™ê¸° ì „ì†¡
          setDoc(logRef, logData).catch(e => console.error("Log Save Error:", e));

        } catch (e) {
          console.error("Log System Error:", e);
        }
      }


      async function getTopScoresFromFirebase(stage) {
        try {
          const q = query(collection(db, "rankings"), where("stage", "==", stage), orderBy("time", "asc"), limit(5));
          const snap = await getDocs(q);
          return snap.docs.map(d => d.data());
        } catch (e) { console.error("Leaderboard Error (Index required):", e); return []; }
      }

      // ==== ë¡œë”© í™”ë©´ ì œê±° í•¨ìˆ˜ ====
      function hideLoadingOverlay() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
          overlay.classList.add('fade-out');
          setTimeout(() => {
            overlay.classList.add('hidden');
          }, 500);
        }
      }

      // [ì¶”ê°€] ìë™ ë¡œê·¸ì¸: UID ê²€ì¦ í¬í•¨
      const savedNick = localStorage.getItem('luge_nickname');
      if (savedNick) {
        // â–¼ Firestoreì—ì„œ UID ì¼ì¹˜ í™•ì¸ í›„ ì§„í–‰
        (async () => {
          try {
            const userDocRef = doc(db, "users", savedNick);
            const userSnap = await getDoc(userDocRef);
            const myUid = auth.currentUser ? auth.currentUser.uid : null;

            if (userSnap.exists() && myUid && userSnap.data().uid === myUid) {
              // UID ì¼ì¹˜ â†’ ë™ì¼ì¸ â†’ ìë™ ë¡œê·¸ì¸
              currentUserNickname = savedNick;
              document.getElementById('displayNick').innerText = currentUserNickname;
              document.getElementById('introScreen').classList.add('hidden');
              document.getElementById('homeScreen').classList.remove('hidden');
              renderLevelGrid();
              updateHofButtonVisibility();
            } else {
              // UID ë¶ˆì¼ì¹˜ â†’ ìºì‹œ ì‚­ì œ â†’ ì¬ì…ë ¥
              localStorage.removeItem('luge_nickname');
            }
          } catch (e) {
            // ì˜¤í”„ë¼ì¸ ë“± ì˜¤ë¥˜ ì‹œ ìºì‹œ ë‹‰ë„¤ì„ìœ¼ë¡œ ì§„í–‰ (graceful fallback)
            currentUserNickname = savedNick;
            document.getElementById('displayNick').innerText = currentUserNickname;
            document.getElementById('introScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
            renderLevelGrid();
            updateHofButtonVisibility();
          }
        })();
      }

      // ë¡œë”© í™”ë©´ í˜ì´ë“œì•„ì›ƒ (0.5ì´ˆ í›„)
      setTimeout(hideLoadingOverlay, 500);

      // 1. [ì§„ì…] ë‹‰ë„¤ì„ ë“±ë¡ ë²„íŠ¼ (UID ë§¤í•‘ + ê¸°ê¸° ì ê¸ˆ)
      document.getElementById('btnRegister').onclick = async function () {
        // â–¼â–¼â–¼ [ì—¬ê¸°ì— 2ì¤„ ì¶”ê°€] ê°€ìƒ í‚¤ë³´ë“œ ì¶©ëŒ ë°©ì–´ ë½(Lock) â–¼â–¼â–¼
        document.getElementById('userNickname').blur(); // 1. OS í‚¤ë³´ë“œ ê°•ì œ í•˜ê°• (í¬ì»¤ìŠ¤ íšŒìˆ˜)
        isKeyboardOpen = false; // 2. ë””ë°”ìš´ìŠ¤ ë½ ì¦‰ê° í•´ì œ (ìŠ¤ì¼€ì¼ ë³µêµ¬ í—ˆìš©)

        const nickInput = document.getElementById('userNickname');
        const errorMsg = document.getElementById('nickError');
        const btn = this;

        const inputNick = nickInput.value.trim();
        const nickRegex = /^[a-zA-Z0-9ê°€-í£]{3,4}$/;

        // 1. í˜•ì‹ ìœ íš¨ì„± ê²€ì‚¬
        if (!nickRegex.test(inputNick)) {
          errorMsg.innerText = "í•œê¸€/ì˜ë¬¸ 3~4ìë¡œ ì…ë ¥í•˜ì„¸ìš”.";
          errorMsg.style.visibility = 'visible';
          errorMsg.style.color = 'var(--olympic-red)';
          nickInput.style.borderColor = 'var(--olympic-red)';
          return;
        }

        // 2. ì¤‘ë³µ ê²€ì‚¬ ì§„í–‰ ì¤‘ í‘œì‹œ
        btn.disabled = true;
        btn.innerText = "CHECKING...";
        errorMsg.style.visibility = 'hidden';

        try {
          const userDocRef = doc(db, "users", inputNick);
          const userSnap = await getDoc(userDocRef);
          const myUid = auth.currentUser ? auth.currentUser.uid : 'anon';

          if (userSnap.exists()) {
            const serverUid = userSnap.data().uid;

            if (serverUid === myUid) {
              currentUserNickname = inputNick;
              localStorage.setItem('luge_nickname', currentUserNickname);
              document.getElementById('displayNick').innerText = currentUserNickname;
              document.getElementById('introScreen').classList.add('hidden');
              document.getElementById('homeScreen').classList.remove('hidden');
              renderLevelGrid();
              updateHofButtonVisibility();
            } else {
              errorMsg.innerText = "ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤ ğŸ˜¢";
              errorMsg.style.visibility = 'visible';
              nickInput.style.borderColor = 'var(--olympic-red)';
              btn.disabled = false;
              btn.innerText = "ENTRY";
            }
            return;
          }

          await setDoc(userDocRef, {
            uid: myUid,
            nickname: inputNick,
            createdAt: serverTimestamp()
          });

          currentUserNickname = inputNick;
          localStorage.setItem('luge_nickname', currentUserNickname);

          document.getElementById('displayNick').innerText = currentUserNickname;
          document.getElementById('introScreen').classList.add('hidden');
          document.getElementById('homeScreen').classList.remove('hidden');
          renderLevelGrid();
          updateHofButtonVisibility();

        } catch (e) {
          console.error("ë‹‰ë„¤ì„ ê²€ì‚¬ ì˜¤ë¥˜:", e);
          errorMsg.innerText = "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
          errorMsg.style.visibility = 'visible';
          btn.disabled = false;
          btn.innerText = "ENTRY";
        }
      };

      // ==== ë­í‚¹ í™”ë©´ ê´€ë ¨ í•¨ìˆ˜ë“¤ ====
      function selectStage(n) {
        state.stage = n;
        document.querySelectorAll('.level-btn').forEach(btn => {
          btn.style.outline = btn.dataset.stage == n ? '3px solid var(--gold)' : 'none';
        });
        showRankingScreen(n);
      }

      async function showRankingScreen(stage) {
        document.getElementById('rankingStageTitle').innerText = `STAGE ${stage}`;
        document.getElementById('homeScreen').classList.add('hidden');
        document.getElementById('rankingScreen').classList.remove('hidden');

        // ë­í‚¹ ë°ì´í„° ë¡œë“œ
        await loadRankingData(stage);
      }

      async function loadRankingData(stage) {
        const container = document.getElementById('rankingEntries');
        container.innerHTML = '<div class="ranking-loading">Loading...</div>';

        try {
          const q = query(
            collection(db, "rankings"),
            where("stage", "==", stage),
            orderBy("time", "asc"),
            limit(10)
          );
          const snap = await getDocs(q);

          container.innerHTML = '';

          if (snap.empty) {
            container.innerHTML = '<div class="ranking-empty">No records yet. Be the first!</div>';
            return;
          }

          snap.docs.forEach((doc, i) => {
            const data = doc.data();
            const entry = document.createElement('div');
            entry.className = 'ranking-entry';

            if (i < 3) {
              const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
              entry.innerHTML = `
                <span class="ranking-medal">${medals[i]}</span>
                <span class="ranking-name">${data.nickname}</span>
                <span class="ranking-time">${formatTime(data.time)}</span>
              `;
            } else {
              entry.innerHTML = `
                <span class="ranking-rank">${i + 1}</span>
                <span class="ranking-name">${data.nickname}</span>
                <span class="ranking-time">${formatTime(data.time)}</span>
              `;
            }
            container.appendChild(entry);
          });
        } catch (e) {
          console.error("Ranking load error:", e);
          container.innerHTML = '<div class="ranking-empty">Failed to load rankings</div>';
        }
      }

      // ë­í‚¹ í™”ë©´ ë²„íŠ¼ ì´ë²¤íŠ¸
      document.getElementById('btnRankingStart').onclick = function () {
        document.getElementById('rankingScreen').classList.add('hidden');
        startGame();
      };

      document.getElementById('btnRankingBack').onclick = function () {
        document.getElementById('rankingScreen').classList.add('hidden');
        document.getElementById('homeScreen').classList.remove('hidden');
      };



      const level = {
        start: { x: 0, y: 0 },
        finish: { x: 0, y: 0, w: 0, h: 0 },
        stars: []
      };

      let strokes = [];
      let activeStroke = null;
      let eraserMode = false;
      let eraserPath = [];
      const particles = [];

      // â”€â”€ Undo System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let historyStack = []; // strokes ìŠ¤ëƒ…ìƒ· ë°°ì—´ (ìµœëŒ€ UNDO_MAX)

      function pushHistory() {
        historyStack.push(JSON.parse(JSON.stringify(strokes)));
        if (historyStack.length > UNDO_MAX) historyStack.shift();
      }

      function undo() {
        if (historyStack.length === 0 || state.mode === 'run') return;
        strokes = historyStack.pop();
        recalculateInkUsage();
        rebuildCollisionData();
        updateUI();
      }

      const player = {
        x: 0, y: 0, vx: 0, vy: 0, angle: 0, onGround: false
      };

      // SAVE SYSTEM - Unified (no mode separation)
      // ============================================
      function getSaveKey() {
        return 'luge_save';
      }

      function getSaveData() {
        const data = localStorage.getItem(getSaveKey());
        if (!data) {
          const initial = {};
          for (let i = 1; i <= MAX_STAGE; i++) {
            initial[i] = { unlocked: i === 1, cleared: false, bestTime: null };
          }
          return initial;
        }
        return JSON.parse(data);
      }

      function saveSaveData(data) {
        localStorage.setItem(getSaveKey(), JSON.stringify(data));
      }

      function getSavedLines(stage) {
        const data = localStorage.getItem(`luge_lines_${stage}`);
        return data ? JSON.parse(data) : null;
      }

      function saveLines(stage, strokesData) {
        localStorage.setItem(`luge_lines_${stage}`, JSON.stringify(strokesData));
      }

      function clearSavedLines(stage) {
        localStorage.removeItem(`luge_lines_${stage}`);
      }

      function getLeaderboardKey() {
        return `luge_lb_s${state.stage}`;
      }

      function getLeaderboard() {
        const data = localStorage.getItem(getLeaderboardKey());
        return data ? JSON.parse(data) : [];
      }

      function saveScore() {
        const scores = getLeaderboard();
        scores.push({ time: state.timer, date: Date.now() });
        scores.sort((a, b) => a.time - b.time);
        while (scores.length > 5) scores.pop();
        localStorage.setItem(getLeaderboardKey(), JSON.stringify(scores));
      }

      // ============================================
      // LEVEL SELECT
      // ============================================
      function renderLevelGrid() {
        levelGrid.innerHTML = '';
        const saveData = getSaveData();

        for (let i = 1; i <= MAX_STAGE; i++) {
          const data = saveData[i];
          const btn = document.createElement('button');
          btn.className = 'level-btn';
          btn.dataset.stage = i;

          if (!data.unlocked) {
            btn.classList.add('locked');
          } else if (data.cleared) {
            btn.classList.add('cleared');
          }

          btn.innerHTML = `${i}<span class="stars-indicator">${'â­'.repeat(Math.min(i, 3))}</span>`;

          if (data.unlocked) {
            btn.onclick = () => selectStage(i);
          }

          levelGrid.appendChild(btn);
        }
      }

      // Mode selector removed - unified arcade mode

      function initStage(n, loadSaved = true) {
        state.stage = n;
        state.mode = 'build';
        state.starsTotal = n;
        state.starsCollected = 0;
        state.timer = 0;
        state.timerRunning = false;
        state.stallTimer = 0;
        state.currentInkType = 'normal';

        // â–¼â–¼â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] PRNG ì‹œë“œ ì´ˆê¸°í™” â–¼â–¼â–¼
        // ë°ì´í„° ì „ëµ: ìŠ¤í…Œì´ì§€ë³„ ê³ ìœ  ì‹œë“œë¡œ PRNG ë¦¬ì…‹.
        // ë™ì¼ ìŠ¤í…Œì´ì§€ â†’ ë™ì¼ ë‚œìˆ˜ì—´ â†’ ë™ì¼ íŒŒí‹°í´ ì—°ì¶œ ë³´ì¥.
        state.seed = n * PRNG_SEED_MULTIPLIER + PRNG_SEED_OFFSET;
        state.rng = mulberry32(state.seed);

        // â–¼â–¼â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] LUT + Grid ì´ˆê¸°í™” â–¼â–¼â–¼
        state.lutData = [];
        state.spatialGrid = {};

        // â–¼ Undo íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
        historyStack = [];

        // â–¼â–¼â–¼ [ìˆ˜ì •] ë°ì´í„° ë¶„ì„ ë³€ìˆ˜ ì´ˆê¸°í™” ë¡œì§ â–¼â–¼â–¼
        state.strokeCount = 0;
        state.eraserCount = 0;
        state.deathX = 0;
        state.deathY = 0;
        state.startTime = Date.now();

        // ì£¼ì˜: retryCountëŠ” ì—¬ê¸°ì„œ 0ìœ¼ë¡œ ë§Œë“¤ë©´ ì•ˆ ë¨!
        // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ì—ì„œ ì œì–´í•˜ê±°ë‚˜, ìŠ¤í…Œì´ì§€ê°€ ë°”ë€” ë•Œë§Œ ì´ˆê¸°í™”í•´ì•¼ í•¨.
        // ì•„ë˜ 'ìŠ¤í…Œì´ì§€ ë³€ê²½ ê°ì§€' ë¡œì§ ì¶”ê°€:
        if (state.lastStage !== n) {
          state.retryCount = 0; // ìŠ¤í…Œì´ì§€ê°€ ë‹¬ë¼ì¡Œì„ ë•Œë§Œ ë¦¬ì…‹
          state.lastStage = n;
        }

        // Load saved lines or clear
        if (loadSaved) {
          const savedLines = getSavedLines(n);
          if (savedLines) {
            strokes = savedLines;
          } else {
            strokes = [];
          }
        } else {
          strokes = [];
        }

        // Recalculate ink used per type
        recalculateInkUsage();
        // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] ë¡œë“œëœ ì„  ë°ì´í„°ë¡œ LUT ì¬ìƒì„±
        rebuildCollisionData();

        particles.length = 0;

        // Safe zones
        const safeTop = 60;
        const safeBottom = 60;

        level.start.x = 35;
        level.start.y = safeTop + 25;

        // Smaller finish
        level.finish.w = 50;
        level.finish.h = 30;
        level.finish.x = VIRTUAL_W - 35 - level.finish.w;
        level.finish.y = VIRTUAL_H - safeBottom - level.finish.h;

        // Load hardcoded stars
        level.stars = STAGE_STARS[n].map(s => ({ ...s, r: 12, taken: false }));

        resetPlayer();
        updateUI();

        document.getElementById('btnStart').innerText = 'Start';

        // Reset toolbar UI state
        eraserMode = false;
        state.currentInkType = 'normal';
        const btnDraw = document.getElementById('btnDraw');
        const btnEraser = document.getElementById('btnEraser');
        if (btnDraw) btnDraw.classList.add('active');
        if (btnEraser) btnEraser.classList.remove('active');
        document.querySelectorAll('.ink-btn').forEach((btn, i) => {
          btn.classList.toggle('active', i === 0);
        });
        closeAllPopups();

        tutorial.classList.remove('hidden');
      }

      // Recalculate ink usage from strokes array (real-time, accurate)
      function recalculateInkUsage() {
        state.boosterInkUsed = 0;
        state.jumpInkUsed = 0;
        for (const stroke of strokes) {
          const len = stroke.len || 0;
          if (stroke.type === 'booster') {
            state.boosterInkUsed += len;
          } else if (stroke.type === 'jump') {
            state.jumpInkUsed += len;
          }
        }
      }

      function resetPlayer() {
        player.x = level.start.x;
        player.y = level.start.y;
        player.vx = 0;
        player.vy = 0;
        player.angle = 0.4;
        player.onGround = false;
        level.stars.forEach(s => s.taken = false);
        state.starsCollected = 0;
        state.timer = 0;
        state.timerRunning = false;
        state.stallTimer = 0;
      }

      // Soft reset - preserves strokes, returns to build mode
      function softReset() {
        resetPlayer();
        state.mode = 'build';
        state.timerRunning = false;
        document.getElementById('btnStart').innerText = 'Start';
        updateUI();
      }

      // ============================================
      // INPUT HANDLING
      // ============================================
      function getVirtualPos(e) {
        const rect = canvas.getBoundingClientRect();
        const cx = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const cy = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

        const canvasX = cx * (canvas.width / rect.width);
        const canvasY = cy * (canvas.height / rect.height);

        return {
          x: (canvasX - offsetX) / scale,
          y: (canvasY - offsetY) / scale
        };
      }

      // Partial eraser - find segments to cut
      function eraseAtPoint(px, py, radius) {
        const newStrokes = [];

        for (const stroke of strokes) {
          const segments = splitStrokeAtPoint(stroke, px, py, radius);
          newStrokes.push(...segments);
        }

        strokes = newStrokes;

        // Real-time recalculation of all ink usage
        recalculateInkUsage();
        // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] ì§€ìš°ê°œ ì‚¬ìš© í›„ LUT ì¬ìƒì„±
        rebuildCollisionData();
        updateUI();
      }

      function splitStrokeAtPoint(stroke, px, py, radius) {
        if (stroke.pts.length < 2) return [];

        const result = [];
        let currentSegment = { pts: [], len: 0, type: stroke.type || 'normal' };
        let lastPoint = null;

        for (let i = 0; i < stroke.pts.length; i++) {
          const pt = stroke.pts[i];
          const dist = Math.hypot(pt.x - px, pt.y - py);

          if (dist < radius) {
            if (currentSegment.pts.length >= 2) {
              result.push(currentSegment);
            }
            currentSegment = { pts: [], len: 0, type: stroke.type || 'normal' };
            lastPoint = pt;
          } else {
            if (lastPoint && currentSegment.pts.length > 0) {
              currentSegment.len += Math.hypot(pt.x - lastPoint.x, pt.y - lastPoint.y);
            }
            currentSegment.pts.push({ ...pt });
            lastPoint = pt;
          }
        }

        if (currentSegment.pts.length >= 2) {
          result.push(currentSegment);
        }

        return result;
      }

      canvas.addEventListener('pointerdown', e => {
        if (state.screen !== 'game' || state.mode !== 'build') return;

        const p = getVirtualPos(e);

        if (eraserMode) {
          pushHistory(); // â–¼ Undo ìŠ¤ëƒ…ìƒ· ì €ì¥
          eraserPath = [p];
          eraseAtPoint(p.x, p.y, state.eraserSize);

          // â–¼ [ì¶”ê°€] ì§€ìš°ê°œ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
          state.eraserCount++;

        } else {
          // Check ink limit for special types
          const inkType = state.currentInkType;
          if (inkType === 'booster' && state.boosterInkUsed >= INK_LIMITS.booster) return;
          if (inkType === 'jump' && state.jumpInkUsed >= INK_LIMITS.jump) return;

          pushHistory(); // â–¼ Undo ìŠ¤ëƒ…ìƒ· ì €ì¥
          activeStroke = { pts: [p], len: 0, type: inkType };
          strokes.push(activeStroke);
          tutorial.classList.add('hidden');

          // â–¼ [ì¶”ê°€] ë“œë¡œì‰ íšŸìˆ˜ ì¦ê°€
          state.strokeCount++;
        }
      });

      canvas.addEventListener('pointermove', e => {
        if (state.screen !== 'game' || state.mode !== 'build') return;

        const p = getVirtualPos(e);

        if (eraserMode && eraserPath.length > 0) {
          eraserPath.push(p);
          eraseAtPoint(p.x, p.y, state.eraserSize);
          return;
        }

        if (!activeStroke) return;

        const last = activeStroke.pts[activeStroke.pts.length - 1];
        const d = Math.hypot(p.x - last.x, p.y - last.y);

        if (d > 2) {
          const inkType = activeStroke.type;
          // Check ink limit for special types
          if (inkType === 'booster' && state.boosterInkUsed + d > INK_LIMITS.booster) return;
          if (inkType === 'jump' && state.jumpInkUsed + d > INK_LIMITS.jump) return;

          activeStroke.pts.push(p);
          activeStroke.len += d;

          // Track ink usage by type
          if (inkType === 'booster') state.boosterInkUsed += d;
          else if (inkType === 'jump') state.jumpInkUsed += d;

          updateUI();
        }
      });

      canvas.addEventListener('pointerup', () => {
        // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] ì„  ê·¸ë¦¬ê¸°/ì§€ìš°ê¸° ì™„ë£Œ ì‹œ LUT + Grid ì¬ìƒì„±
        // ë°ì´í„° ì „ëµ: pointerup ì‹œì ì—ë§Œ Pre-bakeë¥¼ ì‹¤í–‰í•˜ë¯€ë¡œ
        // pointermove ì¤‘ì—ëŠ” LUT ì—°ì‚° ë¶€í•˜ê°€ 0.
        if (activeStroke || eraserPath.length > 0) {
          rebuildCollisionData();
        }
        activeStroke = null;
        eraserPath = [];
      });
      canvas.addEventListener('pointerleave', () => {
        if (activeStroke || eraserPath.length > 0) {
          rebuildCollisionData();
        }
        activeStroke = null;
        eraserPath = [];
      });
      canvas.addEventListener('contextmenu', e => e.preventDefault());

      // ============================================
      // PHYSICS [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜ ì¬ì„¤ê³„]
      // ============================================
      // ë°ì´í„° ì „ëµ: dtëŠ” í•­ìƒ FIXED_DT(1/60)ë¡œ ë“¤ì–´ì˜¨ë‹¤ (game loopì—ì„œ ë³´ì¥).
      // ì¶©ëŒ íŒì •ì€ Spatial Grid + LUT ê¸°ë°˜ìœ¼ë¡œ ìˆ˜í–‰.
      // ê³ ì†(400px/sâ†‘) ì‹œ Adaptive Sub-steppingìœ¼ë¡œ í„°ë„ë§ ë°©ì§€.
      function updatePhysics(dt) {
        // â”€â”€ [1] Adaptive Sub-stepping (High-Velocity Detection) â”€â”€â”€
        // ë°ì´í„° ì „ëµ: í”„ë ˆì„ ë‚´ ì´ë™ ê±°ë¦¬(speed * dt)ê°€ ì¶©ëŒ ë°˜ê²½ì„
        // ì´ˆê³¼í•˜ë©´ ì„œë¸ŒìŠ¤í…ì„ ìœ ë™ì ìœ¼ë¡œ ì¦ê°€ (MAX_SUBSTEPS=10).
        const speed = Math.hypot(player.vx, player.vy);
        const dynamicRadius = LUT_COLLISION_RADIUS + speed * DYNAMIC_RADIUS_K;
        const frameDisplacement = speed * dt;
        let subSteps = 1;

        if (frameDisplacement > dynamicRadius) {
          // ì´ë™ ê±°ë¦¬ / ì¶©ëŒ ë°˜ê²½ â†’ í•„ìš” ì„œë¸ŒìŠ¤í… ìˆ˜ ê²°ì •
          subSteps = Math.min(MAX_SUBSTEPS, Math.ceil(frameDisplacement / dynamicRadius));
        } else if (speed > SUB_STEP_THRESHOLD) {
          subSteps = Math.min(MAX_SUBSTEPS, Math.ceil(speed / SUB_STEP_THRESHOLD));
        }
        const subDt = dt / subSteps;

        // â”€â”€ [3] Proximity-based Optimization (Spatial Grid Culling) â”€â”€
        // ë°ì´í„° ì „ëµ: ììœ  ë‚™í•˜ ìƒíƒœ(Grid ê·¼ì²˜ LUT ì—†ìŒ)ì—ì„œëŠ”
        // ì •ë°€ ì¶©ëŒ ì—°ì‚°ì„ ê±´ë„ˆë›°ì–´ CPU ë¶€í•˜ ì ˆê°.
        const hasNearbyLines = getNearbyLUTPoints(
          state.spatialGrid, player.x, player.y
        ).length > 0;

        for (let sub = 0; sub < subSteps; sub++) {
          // [ìˆ˜ì •ë¨] ì¢…ë£Œ ì¡°ê±´ì— replay ëª¨ë“œ í—ˆìš© (ê²°ì •ë¡ ì  ì¬í˜„ ë³´ì¥)
          if (state.mode !== 'run' && state.mode !== 'replay') return;

          // 1. ì¤‘ë ¥ ì ìš©
          player.vy += PHYS.gravity * subDt;

          // â”€â”€ [2] CCD: ì˜ˆìƒ ìœ„ì¹˜ ê³„ì‚° (ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì „) â”€â”€
          const prevX = player.x;
          const prevY = player.y;

          // 2. ìœ„ì¹˜ ì—…ë°ì´íŠ¸
          player.x += player.vx * subDt;
          player.y += player.vy * subDt;

          // 3. ê³µê¸° ì €í•­ (ë¬´í•œ ê°€ì† ë°©ì§€)
          player.vx *= (1 - PHYS.airDrag);
          player.vy *= (1 - PHYS.airDrag);

          // 4. íšŒì „ ë³´ê°„ (ì†ë„ ë°©í–¥ ì¶”ì¢…, ì €ì† ì‹œ ë–¨ë¦¼ ë°©ì§€)
          const curSpeed = Math.hypot(player.vx, player.vy);
          if (curSpeed > 35) {
            const targetAngle = Math.atan2(player.vy, player.vx);
            let diff = targetAngle - player.angle;
            while (diff <= -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            player.angle += diff * PHYS.rotationSpeed * subDt;
          }
          player.onGround = false;

          // 5. LUT ê¸°ë°˜ ì¶©ëŒ íŒì • (Spatial Grid ì¡°íšŒ)
          //    [3] Culling: ê·¼ì²˜ LUT ì—†ìœ¼ë©´ ì¶©ëŒ ê²€ì‚¬ ìƒëµ
          if (hasNearbyLines || sub === 0) {
            resolveWithLUT(
              player, state.lutData, state.spatialGrid,
              dynamicRadius, prevX, prevY
            );
          }

          // ==========================================
          // [ë°ì´í„° ë¬´ê²°ì„± ë°©ì–´] Terminal Velocity & NaN Guard
          // ==========================================
          
          // 1. ìš°ì£¼ì  ì ˆëŒ€ ì†ë„ ì œí•œ (í™”ë©´ ë°–ìœ¼ë¡œ 1í”„ë ˆì„ë§Œì— ì‚¬ë¼ì§€ëŠ” ê²ƒ ë°©ì§€)
          const ABSOLUTE_MAX_SPEED = 1800; // px/s (í•„ìš”ì— ë”°ë¼ ì¡°ì ˆ)
          const currentSpeed = Math.hypot(player.vx, player.vy);
          if (currentSpeed > ABSOLUTE_MAX_SPEED) {
             player.vx = (player.vx / currentSpeed) * ABSOLUTE_MAX_SPEED;
             player.vy = (player.vy / currentSpeed) * ABSOLUTE_MAX_SPEED;
          }

          // 2. NaN (Not a Number) ì˜¤ì—¼ ë°©ì§€ ë° ì¦‰ê°ì ì¸ ì‹œìŠ¤í…œ ë³µêµ¬
          if (isNaN(player.x) || isNaN(player.y) || isNaN(player.vx) || isNaN(player.vy)) {
             console.error("[Data Anomaly] Physics Vector Explosion detected. Coords turned NaN.");
             fail('Physics Anomaly: Too much pressure!'); 
             return;
          }


          // 6. ë³„ ìˆ˜ì§‘
          for (const s of level.stars) {
            if (!s.taken && Math.hypot(player.x - s.x, player.y - s.y) < 22) {
              s.taken = true;
              state.starsCollected++;
              spawnParticles(s.x, s.y, '#ffd700', 12);
              updateUI();
            }
          }

          // 7. ê³¨ì¸ íŒì •
          const f = level.finish;
          if (player.x > f.x && player.x < f.x + f.w && player.y > f.y && player.y < f.y + f.h) {
            if (state.starsCollected >= state.starsTotal) {
              win();
            } else {
              fail('Collect all â­ first!');
            }
            return;
          }

          // 8. ê²½ê³„ ë²—ì–´ë‚¨ íŒì •
          if (player.y > VIRTUAL_H + 50 || player.x < -50 || player.x > VIRTUAL_W + 50) {
            fail('Out of bounds!');
            return;
          }
        } // end sub-step loop

        // 9. Stall ê°ì§€ (ì„œë¸ŒìŠ¤í… ì™¸ë¶€ì—ì„œ 1íšŒ íŒì •)
        const finalSpeed = Math.hypot(player.vx, player.vy);
        if (finalSpeed < STALL_THRESHOLD && player.onGround) {
          state.stallTimer += dt * 1000;
          if (state.stallTimer >= STALL_TIME) {
            fail('Stalled! Keep moving!');
          }
        } else {
          state.stallTimer = 0;
        }
      }

      // ============================================
      // [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] LUT ê¸°ë°˜ ì¶©ëŒ íŒì • + CCD
      // ============================================
      // [ì‹ ê·œ ì¶”ê°€] ë¬¼ë¦¬ ë°˜ì‚¬ ë¡œì§ ëª¨ë“ˆí™” (ë°ì´í„° ì¼ê´€ì„± í™•ë³´)
      function applyReflection(p, nx, ny, tx, ty, lineType) {
        const vDotN = p.vx * nx + p.vy * ny;
        const vDotT = p.vx * tx + p.vy * ty;

        let boostApplied = false;

        // Type-specific physics
        if (lineType === 'booster') {
          const boostAmt = 245;
          const sign = vDotT >= 0 ? 1 : -1; // ì§„í–‰ ë°©í–¥ íŒë³„
          
          p.vx += tx * sign * boostAmt * (1/60); // FIXED_DT ì§ì ‘ ì‚¬ìš©
          p.vy += ty * sign * boostAmt * (1/60);

          const spd = Math.hypot(p.vx, p.vy);
          const MAX_SPEED = 560;
          if (spd > MAX_SPEED) {
            p.vx = (p.vx / spd) * MAX_SPEED;
            p.vy = (p.vy / spd) * MAX_SPEED;
          }

          // ë¶€ìŠ¤í„° ìœ„ì—ì„œëŠ” íŠ•ê¹€ ì–µì œ (Soft Landing)
          if (vDotN < 0) {
            p.vx -= nx * vDotN * 0.8;
            p.vy -= ny * vDotN * 0.8;
          }
          boostApplied = true;
          spawnParticles(p.x, p.y, '#ff6600', 3);

        } else if (lineType === 'jump') {
          const jumpMultiplier = 1.8;
          const newVn = -vDotN * jumpMultiplier;
          const newVt = vDotT * 0.98;
          p.vx = tx * newVt + nx * newVn;
          p.vy = ty * newVt + ny * newVn;
          p.onGround = false;
          boostApplied = true;
          spawnParticles(p.x, p.y, '#39ff14', 4);
        }

        // ì¼ë°˜ ë°˜ì‚¬ (Normal Reflection)
        if (!boostApplied) {
          const newVt = vDotT * (1 - PHYS.friction);
          const newVn = -vDotN * PHYS.bounce;
          p.vx = tx * newVt + nx * newVn;
          p.vy = ty * newVt + ny * newVn;
          p.onGround = true;

          if (Math.abs(vDotT) > 60 && lineType === 'normal') {
            spawnParticles(p.x, p.y + 5, '#88ccff', 2);
          }
        }
      }
      // ë°ì´í„° ì „ëµ: Spatial Grid ì¡°íšŒ â†’ CCD í„°ë„ë§ ê°ì§€ â†’
      // Surface Snap â†’ resolveLine(Dynamic Radius).
      function resolveWithLUT(p, lutData, spatialGrid, dynRadius, prevX, prevY) {
        const nearby = getNearbyLUTPoints(spatialGrid, p.x, p.y);
        if (nearby.length === 0) return;

        const processed = new Set();
        // [Data Strategy] ê³ ì† ì´ë™ ì‹œ í„°ë„ë§ ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „ ê³„ìˆ˜
        const SAFETY_MARGIN = 1.05;

        for (const pt of nearby) {
          const entry = lutData[pt.lutIdx];
          if (!entry) continue;
          const points = entry.points;
          const lineType = entry.type || 'normal';

          // ì„¸ê·¸ë¨¼íŠ¸ êµ¬ì„±
          const segments = [];
          if (pt.ptIdx < points.length - 1) segments.push({ A: points[pt.ptIdx], B: points[pt.ptIdx + 1], key: `${pt.lutIdx}_${pt.ptIdx}` });
          if (pt.ptIdx > 0) segments.push({ A: points[pt.ptIdx - 1], B: points[pt.ptIdx], key: `${pt.lutIdx}_${pt.ptIdx - 1}` });

          for (const seg of segments) {
            if (processed.has(seg.key)) continue;
            processed.add(seg.key);

            const A = seg.A;
            const B = seg.B;

            // â”€â”€ [CCD Logic] í„°ë„ë§ ê°ì§€ ë° 'ê°•ì œ' ë°˜ì‚¬ â”€â”€
            let tunnelingDetected = false;

            if (prevX !== undefined) {
              if (segmentIntersect(prevX, prevY, p.x, p.y, A.x, A.y, B.x, B.y)) {
                tunnelingDetected = true;

                // 1. ìœ„ì¹˜ ë³´ì • (í‘œë©´ìœ¼ë¡œ ìŠ¤ëƒ…)
                snapToSurface(p, A, B, dynRadius * SAFETY_MARGIN);

                // 2. [í•µì‹¬ ìˆ˜ì •] ì†ë„ ë²¡í„° ê°•ì œ ë°˜ì‚¬
                const dx = B.x - A.x;
                const dy = B.y - A.y;
                const len = Math.hypot(dx, dy);
                const nx = -dy / len; // ë²•ì„  X
                const ny = dx / len;  // ë²•ì„  Y

                // í˜„ì¬ ì†ë„ê°€ ë²½ì„ í–¥í•  ë•Œë§Œ ë°˜ì‚¬
                const vDotN = p.vx * nx + p.vy * ny;
                if (vDotN < 0) {
                  const tx = -ny, ty = nx;
                  applyReflection(p, nx, ny, tx, ty, lineType);
                }
              }
            }

            // í„°ë„ë§ì´ ì—†ì—ˆë‹¤ë©´ ì¼ë°˜ ì¶©ëŒ ì²˜ë¦¬ ìˆ˜í–‰
            if (!tunnelingDetected) {
              resolveLine(p, A, B, lineType, dynRadius);
            }
          }
        }
      }

      // â”€â”€ CCD ë³´ì¡°: ì„ ë¶„-ì„ ë¶„ êµì°¨ ê²€ì‚¬ (ê²°ì •ë¡ ì ) â”€â”€â”€â”€â”€â”€
      // ë°˜í™˜: true ì´ë©´ ì´ë™ ê²½ë¡œ(p0â†’p1)ê°€ ì„ ë¶„(aâ†’b)ì„ ê´€í†µ
      function segmentIntersect(p0x, p0y, p1x, p1y, ax, ay, bx, by) {
        const d1x = p1x - p0x, d1y = p1y - p0y;
        const d2x = bx - ax, d2y = by - ay;
        const cross = d1x * d2y - d1y * d2x;
        if (cross === 0) return false; // í‰í–‰
        const s = ((ax - p0x) * d2y - (ay - p0y) * d2x) / cross;
        const t = ((ax - p0x) * d1y - (ay - p0y) * d1x) / cross;
        return s >= 0 && s <= 1 && t >= 0 && t <= 1;
      }

      // â”€â”€ CCD ë³´ì¡°: ì„  í‘œë©´ìœ¼ë¡œ ê°•ì œ ìŠ¤ëƒ… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function snapToSurface(p, p1, p2, radius) {
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        const lenSq = dx * dx + dy * dy;
        if (lenSq === 0) return;

        let t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / lenSq;
        t = Math.max(0, Math.min(1, t));

        const cx = p1.x + t * dx, cy = p1.y + t * dy;
        const dist = Math.hypot(p.x - cx, p.y - cy);
        if (dist < 0.001) return;

        // ë²•ì„  ë°©í–¥ìœ¼ë¡œ radiusë§Œí¼ ë–¨ì–´ì§„ ìœ„ì¹˜ë¡œ ìŠ¤ëƒ…
        const nx = (p.x - cx) / dist;
        const ny = (p.y - cy) / dist;
        p.x = cx + nx * radius;
        p.y = cy + ny * radius;
      }

      // ============================================
      // LINE SEGMENT COLLISION RESOLVER
      // ============================================
      // ë°ì´í„° ì „ëµ: Dynamic Radius + Soft-clamping for Booster.
      // [4] ë¶€ë™ ì†Œìˆ˜ì  ì˜¤ì°¨ ìµœì†Œí™”: ë™ì¼ ì…ë ¥ â†’ ë™ì¼ ê²°ê³¼ ë³´ì¥.
      function resolveLine(p, p1, p2, lineType, dynRadius) {
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        const lenSq = dx * dx + dy * dy;
        if (lenSq === 0) return;

        let t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / lenSq;
        t = Math.max(0, Math.min(1, t));

        const cx = p1.x + t * dx, cy = p1.y + t * dy;
        const dist = Math.hypot(p.x - cx, p.y - cy);

        // [1] Dynamic Radius
        const radius = dynRadius !== undefined ? dynRadius : LUT_COLLISION_RADIUS;

        if (dist < radius && dist > 0.001) {
          const nx = (p.x - cx) / dist;
          const ny = (p.y - cy) / dist;

          // [2] Soft-clamping & Penetration Resolution
          const penetration = radius - dist;
          const correctionFactor = (lineType === 'booster') ? BOOSTER_SNAP_FACTOR : 1.0;

          p.x += nx * penetration * correctionFactor;
          p.y += ny * penetration * correctionFactor;

          // ì†ë„ ë°˜ì‚¬ (Velocity Reflection) - ëª¨ë“ˆí™”ëœ í•¨ìˆ˜ í˜¸ì¶œ
          const vDotN = p.vx * nx + p.vy * ny;
          if (vDotN < 0) {
            const tx = -ny, ty = nx;
            applyReflection(p, nx, ny, tx, ty, lineType);
          }
        }
      }

      // ============================================
      // CATMULL-ROM SPLINE
      // ============================================
      function catmullRom(p0, p1, p2, p3, t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return 0.5 * (
          2 * p1 +
          (-p0 + p2) * t +
          (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
          (-p0 + 3 * p1 - 3 * p2 + p3) * t3
        );
      }

      function drawCatmullRomPath(pts) {
        if (pts.length < 2) return;
        if (pts.length < 4) {
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) {
            ctx.lineTo(pts[i].x, pts[i].y);
          }
          return;
        }

        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = pts[Math.max(0, i - 1)];
          const p1 = pts[i];
          const p2 = pts[Math.min(pts.length - 1, i + 1)];
          const p3 = pts[Math.min(pts.length - 1, i + 2)];

          for (let t = 0; t <= 1; t += 0.1) {
            const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
            const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);
            ctx.lineTo(x, y);
          }
        }
      }

      // ============================================
      // RENDERING
      // ============================================
      function render() {
        ctx.save();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);


        // Start platform
        ctx.fillStyle = '#2a4060';
        ctx.fillRect(level.start.x - 15, level.start.y - 5, 35, 7);
        ctx.fillStyle = '#88aacc';
        ctx.font = 'bold 8px Outfit, sans-serif';
        ctx.fillText('START', level.start.x - 12, level.start.y - 8);

        // Finish - Small checkered flag
        drawCheckeredFlag();

        // Strokes with type-specific colors and spline smoothing
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        for (const st of strokes) {
          if (st.pts.length < 2) continue;
          const colors = INK_COLORS[st.type || 'normal'];

          // Draw glow
          ctx.beginPath();
          drawCatmullRomPath(st.pts);
          ctx.lineWidth = 8;
          ctx.strokeStyle = colors.glow + '33'; // 20% opacity
          ctx.stroke();

          // Draw main line
          ctx.beginPath();
          drawCatmullRomPath(st.pts);
          ctx.lineWidth = 3;
          ctx.strokeStyle = colors.line;
          ctx.shadowColor = colors.glow;
          ctx.shadowBlur = 6;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Stars
        for (const s of level.stars) {
          if (s.taken) continue;
          drawStar(s.x, s.y, s.r);
        }

        // Player
        drawPlayer();

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.15;
          p.life -= 0.04;
          if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
          }
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.c;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Stall warning
        if (state.mode === 'run' && state.stallTimer > 1500) {
          ctx.fillStyle = '#ff4444';
          ctx.font = 'bold 12px Outfit, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('âš ï¸ KEEP MOVING!', VIRTUAL_W / 2, VIRTUAL_H / 2);
          ctx.textAlign = 'left';
        }

        // Eraser preview circle (center when adjusting slider)
        if (state.showEraserPreview && state.mode === 'build') {
          ctx.strokeStyle = 'rgba(255, 80, 80, 0.8)';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.arc(VIRTUAL_W / 2, VIRTUAL_H / 2, state.eraserSize, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        ctx.restore();
      }

      function drawCheckeredFlag() {
        const f = level.finish;
        const checkSize = 5;

        // Small flag pole
        ctx.fillStyle = '#555';
        ctx.fillRect(f.x + f.w / 2 - 2, f.y - 25, 4, 30);

        // Small flag
        ctx.fillStyle = '#fff';
        ctx.fillRect(f.x + f.w / 2 + 2, f.y - 25, 20, 14);

        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 4; col++) {
            if ((row + col) % 2 === 0) {
              ctx.fillStyle = '#000';
              ctx.fillRect(f.x + f.w / 2 + 2 + col * checkSize, f.y - 25 + row * checkSize, checkSize, checkSize);
            }
          }
        }

        // Finish zone
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(f.x, f.y, f.w, f.h);
        ctx.setLineDash([]);
      }

      function drawStar(x, y, r) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Date.now() / 800);

        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.8);
        glow.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, r * 1.8, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
          const px = Math.cos(angle) * r;
          const py = Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = '#ffd700';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.restore();
      }

      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);

        // Scale down to 60%
        ctx.scale(0.6, 0.6);

        // Sled (curved luge)
        ctx.fillStyle = '#c0c0c0';
        ctx.beginPath();
        ctx.moveTo(-18, 4);
        ctx.quadraticCurveTo(-22, 0, -18, -2);
        ctx.lineTo(20, -2);
        ctx.quadraticCurveTo(24, 0, 20, 4);
        ctx.closePath();
        ctx.fill();

        // Runners
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-16, 5);
        ctx.lineTo(18, 5);
        ctx.stroke();

        // Body lying on back (luge position)
        const bodyColor = '#333';
        const suitColor = '#1a1a2e';

        // Torso (horizontal)
        ctx.fillStyle = suitColor;
        ctx.beginPath();
        ctx.ellipse(-2, -6, 12, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Legs (bent up at knees)
        ctx.fillStyle = suitColor;
        ctx.beginPath();
        ctx.moveTo(-14, -6);
        ctx.lineTo(-20, -10);
        ctx.lineTo(-18, -16);
        ctx.lineTo(-14, -12);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(-10, -6);
        ctx.lineTo(-14, -10);
        ctx.lineTo(-12, -16);
        ctx.lineTo(-8, -12);
        ctx.closePath();
        ctx.fill();

        // Iron Man Helmet
        const helmX = 10;
        const helmY = -8;

        // Helmet base (red)
        ctx.fillStyle = '#8B0000';
        ctx.beginPath();
        ctx.ellipse(helmX, helmY, 7, 6, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Face plate (gold)
        ctx.fillStyle = '#DAA520';
        ctx.beginPath();
        ctx.moveTo(helmX + 2, helmY - 4);
        ctx.lineTo(helmX + 7, helmY - 1);
        ctx.lineTo(helmX + 7, helmY + 2);
        ctx.lineTo(helmX + 2, helmY + 5);
        ctx.lineTo(helmX - 2, helmY + 3);
        ctx.lineTo(helmX - 2, helmY - 2);
        ctx.closePath();
        ctx.fill();

        // Visor eyes (glowing)
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.ellipse(helmX + 3, helmY - 1, 2, 1, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(helmX + 1, helmY + 1, 2, 1, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Arms (at sides holding handles)
        ctx.fillStyle = suitColor;
        ctx.strokeStyle = suitColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(2, -4);
        ctx.lineTo(6, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-6, -4);
        ctx.lineTo(-10, 0);
        ctx.stroke();

        ctx.restore();
      }

      function spawnParticles(x, y, color, count = 8) {
        // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] Math.random() â†’ state.rng() êµì²´
        // ë°ì´í„° ì „ëµ: ë™ì¼ seedì—ì„œ ìƒì„±ëœ rngë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ
        // íŒŒí‹°í´ì˜ ê°ë„, ì†ë„, í¬ê¸° ëª¨ë‘ ê²°ì •ë¡ ì .
        const rng = state.rng || Math.random; // Safety fallback
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count + rng() * 0.4;
          const speed = 1.5 + rng() * 2.5;
          particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1.5,
            c: color,
            r: 2 + rng() * 1.5,
            life: 1
          });
        }
      }

      // ============================================
      // GAME FLOW
      // ============================================
      function win() {
        // [ë¦¬í”Œë ˆì´ ë°©ì–´] ë¦¬í”Œë ˆì´ ì¤‘ ê³¨ì¸í•˜ë©´ ì‹œë®¬ë ˆì´ì…˜ë§Œ ì •ì§€ì‹œí‚¤ê³  ë¦¬í„´
        if (state.mode === 'replay') {
            state.isPaused = true;
            return;
          }

        state.mode = 'win';
        state.timerRunning = false;

        // Clear saved lines on win
        // clearSavedLines(state.stage);
        // [ìˆ˜ì • í›„] ì„±ê³µ ì‹œ, 'ì €ì¥ ë²„íŠ¼(ğŸ’¾)'ì„ ëˆ„ë¥¸ ê²ƒê³¼ ë˜‘ê°™ì´ ìë™ ì €ì¥í•©ë‹ˆë‹¤.
        saveCustomSetup();

        // [ì¶”ê°€] Firebase ì €ì¥ ì‹¤í–‰
        saveScoreToFirebase(state.stage, state.timer);

        // â–¼â–¼â–¼ [ì‹ ê·œ ì¶”ê°€] ì„±ê³µ ë¡œê·¸ ì €ì¥ â–¼â–¼â–¼
        saveGameLog('WIN', null);

        // â–¼â–¼â–¼ [ì‹ ê·œ ì¶”ê°€] ì„±ê³µ í›„ Retryë¥¼ ëˆŒëŸ¬ë„ ì„ ì´ ë‚¨ì•„ìˆê²Œ í•¨ â–¼â–¼â–¼
        saveLines(state.stage, strokes);


        // Update save data
        const saveData = getSaveData();
        saveData[state.stage].cleared = true;
        const currentBest = saveData[state.stage].bestTime;
        if (currentBest === null ||
          (state.gameMode === 'speed' && state.timer < currentBest) ||
          (state.gameMode === 'sloth' && state.timer > currentBest)) {
          saveData[state.stage].bestTime = state.timer;
        }

        // Unlock next stage
        if (state.stage < MAX_STAGE) {
          saveData[state.stage + 1].unlocked = true;
        }
        saveSaveData(saveData);

        // Celebration [ê²°ì •ë¡ ì  PRNG]
        const rng = state.rng || Math.random;
        for (let i = 0; i < 25; i++) {
          const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
          spawnParticles(
            player.x + (rng() - 0.5) * 40,
            player.y + (rng() - 0.5) * 40,
            colors[Math.floor(rng() * colors.length)],
            2
          );
        }

        saveScore();
        showResult(true);

        // â–¼ Stage 10 í´ë¦¬ì–´ ì‹œ ëª…ì˜ˆì˜ ì „ë‹¹ ìë™ í‘œì‹œ
        if (state.stage === MAX_STAGE) {
          // ì¶”ê°€ ì¶•í•˜ í­ì£½ íŒŒí‹°í´
          const rng2 = state.rng || Math.random;
          for (let i = 0; i < 40; i++) {
            const colors2 = ['#ffd700', '#ff4444', '#00ffcc', '#ff69b4', '#8b5cf6'];
            spawnParticles(
              VIRTUAL_W * 0.5 + (rng2() - 0.5) * VIRTUAL_W * 0.8,
              VIRTUAL_H * 0.3 + (rng2() - 0.5) * 100,
              colors2[Math.floor(rng2() * colors2.length)],
              3
            );
          }
          // 1.5ì´ˆ í›„ ëª…ì˜ˆì˜ ì „ë‹¹ ì˜¤í”ˆ
          setTimeout(() => {
            resultModal.classList.remove('active');
            showHallOfFame();
          }, 1500);
        }
      }

      async function fail(reason) {
        // [ë¦¬í”Œë ˆì´ ë°©ì–´] ë¦¬í”Œë ˆì´ ì¤‘ ì‚¬ë§í•˜ë©´ ì‹œë®¬ë ˆì´ì…˜ë§Œ ì •ì§€ì‹œí‚¤ê³  ë¦¬í„´
        if (state.mode === 'replay') {
            state.isPaused = true;
            return;
          }

        state.mode = 'fail';
        state.timerRunning = false;

        // â–¼â–¼â–¼ [ì‹ ê·œ ì¶”ê°€] ì‹¤íŒ¨ ìœ„ì¹˜ ê¸°ë¡ ë° ë¡œê·¸ ì €ì¥ â–¼â–¼â–¼
        state.deathX = player.x;
        state.deathY = player.y;
        saveGameLog('FAIL', reason);

        // ì‹¤íŒ¨í–ˆìœ¼ë¯€ë¡œ ì¬ì‹œë„ ì¹´ìš´íŠ¸ ì¦ê°€
        state.retryCount++;


        // Save lines on fail for retry
        saveLines(state.stage, strokes);

        document.getElementById('resultTitle').innerText = 'FAIL!';
        document.getElementById('resultMyTime').innerText = formatTime(state.timer);
        // document.getElementById('resultFailReason').innerText = reason;

        // Top 3 ê¸°ë¡ ì¡°íšŒ (ì‹¤íŒ¨ ì‹œì—ë„ í‘œì‹œ)
        const top3 = await getTop3Records(state.stage);
        displayTop3(top3);

        // Gap ê³„ì‚° (1ìœ„ì™€ì˜ ì°¨ì´)
        const gapEl = document.getElementById('resultGap');
        if (top3.length > 0) {
          const gap = state.timer - top3[0].time;
          if (gap > 0) {
            gapEl.innerText = `+ ${gap.toFixed(3)}`;
            gapEl.className = 'result-gap slower';
          } else {
            gapEl.innerText = `- ${Math.abs(gap).toFixed(3)}`;
            gapEl.className = 'result-gap faster';
          }
        } else {
          gapEl.innerText = '---';
          gapEl.className = 'result-gap';
        }

        document.getElementById('btnNext').style.display = 'none';
        resultModal.classList.add('active');
      }

      async function showResult(success) {
        const myTime = state.timer;
        const myTimeStr = formatTime(myTime);

        document.getElementById('resultTitle').innerText = success ? 'FINISH!' : 'FAIL!';
        document.getElementById('resultMyTime').innerText = myTimeStr;
        document.getElementById('resultFailReason').innerText = ''; // ì„±ê³µ ì‹œ ì‹¤íŒ¨ ì‚¬ìœ  ì œê±°

        // Top 3 ê¸°ë¡ ì¡°íšŒ
        const top3 = await getTop3Records(state.stage);
        displayTop3(top3);

        // Gap ê³„ì‚°
        const gapEl = document.getElementById('resultGap');
        if (top3.length > 0) {
          const gap = myTime - top3[0].time;
          if (gap > 0) {
            gapEl.innerText = `+ ${gap.toFixed(3)}`;
            gapEl.className = 'result-gap slower';
          } else if (gap < 0) {
            gapEl.innerText = `- ${Math.abs(gap).toFixed(3)}`;
            gapEl.className = 'result-gap faster';
          } else {
            gapEl.innerText = 'ğŸ¥‡ 1ST!';
            gapEl.className = 'result-gap first';
          }
        } else {
          // ì²« ê¸°ë¡ì¼ ê²½ìš°
          gapEl.innerText = 'ğŸ¥‡ 1ST!';
          gapEl.className = 'result-gap first';
        }

        document.getElementById('btnNext').style.display = state.stage < MAX_STAGE ? 'block' : 'none';
        resultModal.classList.add('active');
      }

      // Top 3 UI ì—…ë°ì´íŠ¸
      function displayTop3(records) {
        for (let i = 1; i <= 3; i++) {
          const nameEl = document.getElementById(`top3Name${i}`);
          const timeEl = document.getElementById(`top3Time${i}`);
          if (records[i - 1]) {
            nameEl.innerText = records[i - 1].nickname;
            timeEl.innerText = formatTime(records[i - 1].time);
          } else {
            nameEl.innerText = '---';
            timeEl.innerText = '--:--.---';
          }
        }
      }

      // Top 3 ê¸°ë¡ ì¡°íšŒ í•¨ìˆ˜
      async function getTop3Records(stage) {
        try {
          const q = query(
            collection(db, "rankings"),
            where("stage", "==", stage),
            orderBy("time", "asc"),
            limit(3)
          );
          const snap = await getDocs(q);
          return snap.docs.map(doc => doc.data());
        } catch (e) {
          console.error("Top 3 query error:", e);
          return [];
        }
      }

      // ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜ (mm:ss.fff)
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${String(mins).padStart(2, '0')}:${secs.toFixed(3).padStart(6, '0')}`;
      }

      // 1ìœ„ ê¸°ë¡ ì¡°íšŒ í•¨ìˆ˜
      async function getFirstPlaceRecord(stage) {
        try {
          const q = query(
            collection(db, "rankings"),
            where("stage", "==", stage),
            orderBy("time", "asc"),
            limit(1)
          );
          const snap = await getDocs(q);
          if (snap.empty) return null;
          return snap.docs[0].data();
        } catch (e) {
          console.error("First place query error:", e);
          return null;
        }
      }

      async function displayLeaderboard() {
        const container = document.getElementById('lbEntries');
        container.innerHTML = '<div style="color:#aaa;text-align:center;">Loading Cloud Data...</div>';

        // Firebase ë°ì´í„° í˜¸ì¶œ
        const scores = await getTopScoresFromFirebase(state.stage);

        container.innerHTML = '';
        if (scores.length === 0) {
          container.innerHTML = '<div style="color:#666;text-align:center;padding:8px;font-size:10px;">No Records Yet</div>';
          return;
        }

        scores.forEach((s, i) => {
          const entry = document.createElement('div');
          entry.className = 'lb-entry';
          const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}.`;
          entry.innerHTML = `<span class="lb-rank">${medal}</span> 
                             <span style="flex:1; margin-left:10px;">${s.nickname}</span>
                             <span>${s.time.toFixed(3)}s</span>`;
          container.appendChild(entry);
        });
      }

      // ============================================
      // UI
      // ============================================
      function updateUI() {
        document.getElementById('uiStage').innerText = state.stage;
        // document.getElementById('uiStars').innerText = `${state.starsCollected}/${state.starsTotal}`;
        document.getElementById('uiTime').innerText = state.timer.toFixed(5);

        // Update ink gauge bars
        const boostPct = Math.max(0, 100 - (state.boosterInkUsed / INK_LIMITS.booster) * 100);
        const jumpPct = Math.max(0, 100 - (state.jumpInkUsed / INK_LIMITS.jump) * 100);

        const boosterBar = document.getElementById('boosterBar');
        const jumpBar = document.getElementById('jumpBar');
        if (boosterBar) boosterBar.style.width = `${boostPct}%`;
        if (jumpBar) jumpBar.style.width = `${jumpPct}%`;
      }

      // Toast notification
      function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.innerText = msg;
        toast.classList.add('visible');
        setTimeout(() => toast.classList.remove('visible'), 1500);
      }

      // Save/Load custom setup
      function saveCustomSetup() {
        const data = { strokes, boosterUsed: state.boosterInkUsed, jumpUsed: state.jumpInkUsed };
        localStorage.setItem(`luge_custom_slot_${state.stage}`, JSON.stringify(data));
        showToast('ğŸ’¾ Setup Saved!');
      }

      function loadCustomSetup() {
        const data = localStorage.getItem(`luge_custom_slot_${state.stage}`);
        if (data) {
          const parsed = JSON.parse(data);
          strokes = parsed.strokes || [];
          recalculateInkUsage();
          // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] ë¡œë“œëœ ì„  ë°ì´í„°ë¡œ LUT ì¬ìƒì„±
          rebuildCollisionData();
          updateUI();
          showToast('ğŸ“‚ Setup Loaded!');
        } else {
          showToast('No saved setup');
        }
      }

      function goToHome() {
        if (state.screen === 'game' && strokes.length > 0) {
          saveLines(state.stage, strokes);
        }
        state.screen = 'home';
        state.mode = 'build';
        homeScreen.classList.remove('hidden');
        gameUI.classList.add('hidden');
        resultModal.classList.remove('active');
        tutorial.classList.add('hidden');
        closeAllPopups();
        renderLevelGrid();
        updateHofButtonVisibility();
      }

      function startGame() {
        const saveData = getSaveData();
        if (!saveData[state.stage].unlocked) return;
        state.screen = 'game';
        homeScreen.classList.add('hidden');
        gameUI.classList.remove('hidden');
        initStage(state.stage, true);
      }

      // ============================================
      // TOOLBAR EVENT HANDLERS
      // ============================================
      const drawPopup = document.getElementById('drawPopup');
      const eraserPopup = document.getElementById('eraserPopup');
      const btnDraw = document.getElementById('btnDraw');
      const btnEraserTool = document.getElementById('btnEraser');

      function closeAllPopups() {
        drawPopup.classList.remove('visible');
        eraserPopup.classList.remove('visible');
      }

      function setDrawMode() {
        eraserMode = false;
        btnDraw.classList.add('active');
        btnEraserTool.classList.remove('active');
        eraserPopup.classList.remove('visible');
      }

      function setEraserMode() {
        eraserMode = true;
        btnEraserTool.classList.add('active');
        btnDraw.classList.remove('active');
        drawPopup.classList.remove('visible');
      }

      // btnPlay ì œê±°ë¨ - ì´ì œ ëœí‚¹ í™”ë©´ì„ í†µí•´ ì‹œì‘

      document.getElementById('btnStart').onclick = function () {
        if (state.mode === 'build') {
          // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] Start ì‹œ ìµœì¢… LUT ì¬ìƒì„±
          // ë°ì´í„° ì „ëµ: ë§ˆì§€ë§‰ìœ¼ë¡œ ì™„ì„±ëœ stroke ë°°ì—´ë¡œ LUTë¥¼ ìƒì„±.
          // ì´ ì‹œì  ì´í›„ ë¬¼ë¦¬ ì—°ì‚°ì€ ì˜¤ì§ ì´ LUT ë°ì´í„°ë§Œ ì‚¬ìš©.
          rebuildCollisionData();
          // â–¼ [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜] PRNGë„ ë¦¬ì…‹í•˜ì—¬ ë™ì¼ ì‹œë“œ ë³´ì¥
          state.rng = mulberry32(state.seed);
          state.mode = 'run';
          state.timerRunning = true;
          this.innerText = 'Retry';
          tutorial.classList.add('hidden');
          closeAllPopups();
        } else if (state.mode === 'run') {
          // softReset: preserve strokes, reset player and return to build mode
          softReset();
        }
      };

      btnDraw.onclick = function () {
        setDrawMode();
        drawPopup.classList.toggle('visible');
      };

      btnEraserTool.onclick = function () {
        setEraserMode();
        eraserPopup.classList.toggle('visible');
      };

      // Ink type selection - auto-close popup
      document.querySelectorAll('.ink-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.ink-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.currentInkType = btn.dataset.type;
          drawPopup.classList.remove('visible');
        };
      });

      // Eraser slider with preview
      const eraserSlider = document.getElementById('eraserSlider');
      eraserSlider.oninput = function () {
        state.eraserSize = parseInt(this.value);
        document.getElementById('eraserSizeLabel').innerText = this.value;
        state.showEraserPreview = true;
      };
      eraserSlider.onchange = function () {
        state.showEraserPreview = false;
        eraserPopup.classList.remove('visible');
      };

      document.getElementById('btnSave').onclick = saveCustomSetup;
      document.getElementById('btnLoad').onclick = loadCustomSetup;
      document.getElementById('btnHome').onclick = goToHome;

      document.getElementById('btnNext').onclick = function () {
        resultModal.classList.remove('active');
        if (state.stage < MAX_STAGE) {
          state.stage++;
          initStage(state.stage, true);
        }
      };

      document.getElementById('btnRetry').onclick = function () {
        // â–¼â–¼â–¼ [ì‹ ê·œ ì¶”ê°€] ë¦¬íŠ¸ë¼ì´ ë²„íŠ¼ ëˆ„ë¥¼ ë•Œ, í˜„ì¬ ê·¸ë ¤ì§„ ì„  ê°•ì œ ì €ì¥ â–¼â–¼â–¼
        if (strokes.length > 0) {
          saveLines(state.stage, strokes);
        }
        resultModal.classList.remove('active');
        // Keep strokes on retry
        initStage(state.stage, true);
      };

      document.getElementById('btnResultHome').onclick = goToHome;

      // 1. ë””ë°”ìš´ìŠ¤ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ (ë°ì´í„° ì—°ì‚° í­ì£¼ ë°©ì§€)
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      // 2. í´ë“œ/íƒœë¸”ë¦¿ í™”ë©´ë¹„ì— ì™„ë²½íˆ ëŒ€ì‘í•˜ëŠ” ë¦¬ì‚¬ì´ì¦ˆ ì½”ì–´ ë¡œì§
      function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        const rect = container.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        // ê°€ìš© ì˜ì—­ ë°ì´í„° ì¶”ì¶œ
        const availableW = rect.width;
        const availableH = rect.height;

        // 9:16 ê°€ìƒ ì¢Œí‘œê³„(VIRTUAL_W, VIRTUAL_H) ê¸°ì¤€ ìµœì  ìŠ¤ì¼€ì¼ íƒìƒ‰
        scale = Math.min(availableW / VIRTUAL_W, availableH / VIRTUAL_H);

        // ë¬¼ë¦¬ì  í”½ì…€ ì •ë°€ë„ í• ë‹¹ (íë ¤ì§ ë°©ì§€)
        canvas.width = availableW * dpr;
        canvas.height = availableH * dpr;

        // ë°ì´í„° ì‹œê°í™” ë¬´ê²°ì„±ì„ ìœ„í•œ ì¤‘ì•™ ì •ë ¬ ì˜¤í”„ì…‹ ê³„ì‚°
        offsetX = (canvas.width - VIRTUAL_W * scale * dpr) / 2;
        offsetY = (canvas.height - VIRTUAL_H * scale * dpr) / 2;
        
        // ë¦¬ì‚¬ì´ì¦ˆ ì§í›„ í™”ë©´ ì¦‰ì‹œ ê°±ì‹  (ë¸”ë™ìŠ¤í¬ë¦° ë°©ì§€)
        render(); 
      }

      // 3. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì— ë””ë°”ìš´ìŠ¤ ì ìš© (100ms ëŒ€ê¸° í›„ 1íšŒë§Œ ì‹¤í–‰)
      // [í‚¤ë³´ë“œ ì¶©ëŒ ë°©ì–´ ë¡œì§ & ë¦¬ì‚¬ì´ì¦ˆ í†µí•©]
      // ============================================
      const nickInput = document.getElementById('userNickname');
      let isKeyboardOpen = false;

      if (nickInput) {
        // 1. ì…ë ¥ì°½ í¬ì»¤ìŠ¤ ì‹œ ìƒíƒœ ì ê¸ˆ (ë¦¬ì‚¬ì´ì¦ˆ ë¬´ì‹œ)
        nickInput.addEventListener('focus', () => {
          isKeyboardOpen = true;
        });

        // 2. í¬ì»¤ìŠ¤ ì•„ì›ƒ ì‹œ ìƒíƒœ í•´ì œ ë° ì¦‰ê°ì ì¸ í™”ë©´ ë³µêµ¬ ì—°ì‚°
        nickInput.addEventListener('blur', () => {
          isKeyboardOpen = false;
          // í‚¤ë³´ë“œê°€ ë‚´ë ¤ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ ëŒ€ê¸° í›„ ìº”ë²„ìŠ¤ ì›ìƒ ë³µêµ¬
          setTimeout(() => {
            resizeCanvas(); 
          }, 300);
        });
      }

      // 3. ë””ë°”ìš´ìŠ¤ ì´ë²¤íŠ¸ì— ì˜ˆì™¸ ì¡°ê±´ ì£¼ì… (ë‹¨ì¼ ì„ ì–¸ ë¬´ê²°ì„± í™•ë³´)
      const debouncedResize = debounce(() => {
        // í‚¤ë³´ë“œê°€ ì—´ë ¤ìˆì§€ ì•Šì„ ë•Œë§Œ ë¦¬ì‚¬ì´ì¦ˆ í—ˆìš©
        if (!isKeyboardOpen) {
          resizeCanvas();
        }
      }, 100);
      
      // 4. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë‹¨ì¼ ë“±ë¡
      window.addEventListener('resize', debouncedResize);
      window.addEventListener('orientationchange', debouncedResize);


      // ============================================
      // UNDO BUTTON HANDLER
      // ============================================
      document.getElementById('btnUndo').onclick = undo;


      // ============================================
      // REPLAY SYSTEM EVENT HANDLERS (ìˆ˜ì •ë¨)
      // ============================================
      // [ë°ì´í„° ì‹œê°í™” í—¬í¼] ì„ íƒëœ ë°°ì† ë²„íŠ¼ë§Œ ë„¤ì˜¨ ë°œê´‘ íš¨ê³¼ ì ìš©
      function updateSpeedUI(targetSpeed) {
        state.timeScale = targetSpeed;
        const speedBtns = document.querySelectorAll('.speed-btn');
        speedBtns.forEach(btn => {
          const ringColor = btn.style.getPropertyValue('--ring-color').trim();
          if (parseFloat(btn.dataset.speed) === targetSpeed) {
            btn.style.boxShadow = `0 0 10px ${ringColor}, inset 0 0 5px ${ringColor}`;
            btn.style.backgroundColor = 'rgba(255,255,255,0.1)';
            btn.style.color = ringColor;
          } else {
            btn.style.boxShadow = 'none';
            btn.style.backgroundColor = 'transparent';
            btn.style.color = 'white';
          }
        });
      }

      document.getElementById('btnReplay').onclick = function () {
        if (state.mode === 'run') return; // ê²Œì„ ì§„í–‰ ì¤‘ ì§„ì… ë¶ˆê°€

        // ê·¸ë ¤ì§„ ì„ ì´ ì—†ìœ¼ë©´ ì°¨ë‹¨ (ë¬´ê²°ì„± í™•ë³´)
        if (strokes.length === 0) {
          showToast('ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì„ ì„ ê·¸ë¦¬ê³  í”Œë ˆì´í•˜ì„¸ìš”.');
          return;
        }
        
        document.getElementById('mainToolbar').style.display = 'none';
        document.getElementById('replayPanel').style.display = 'flex';
        
        state.mode = 'replay';
        state.isPaused = true; 
        document.getElementById('btnReplayPlayPause').innerText = 'â–¶';
        
        // ì§„ì… ì‹œ í•­ìƒ 1.0ë°°ì†(ë¹¨ê°„ìƒ‰ ë§)ìœ¼ë¡œ ë°ì´í„° ë¦¬ì…‹
        updateSpeedUI(1.0);
        
        resetPlayer(); 
        state.rng = mulberry32(state.seed); 
        state.timerRunning = true;
        closeAllPopups();
      };

      document.getElementById('btnReplayExit').onclick = function () {
        document.getElementById('mainToolbar').style.display = 'flex';
        document.getElementById('replayPanel').style.display = 'none';
        
        state.timeScale = 1.0;
        state.isPaused = false;
        softReset(); 
      };

      document.getElementById('btnReplayPlayPause').onclick = function () {
        state.isPaused = !state.isPaused;
        this.innerText = state.isPaused ? 'â–¶' : 'â¸';
      };

      // 5ê°œ ë¶„ë¦¬í˜• ë°°ì† ë²„íŠ¼ì— í´ë¦­ ì´ë²¤íŠ¸ ì¼ê´„ ë°”ì¸ë”©
      document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.onclick = function() {
          const targetSpeed = parseFloat(this.dataset.speed);
          updateSpeedUI(targetSpeed);
        };
      });


      // ============================================
      // HALL OF FAME (ëª…ì˜ˆì˜ ì „ë‹¹)
      // ============================================
      // ë°ì´í„° ì „ëµ: rankings ì»¬ë ‰ì…˜ì—ì„œ ëª¨ë“  ìœ ì €ì˜ ìŠ¤í…Œì´ì§€ 1~10 ê¸°ë¡ì„
      // ì§‘ê³„í•˜ì—¬ totalTime ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ìƒìœ„ 10ëª… í‘œì‹œ.
      // 10ê°œ ìŠ¤í…Œì´ì§€ ëª¨ë‘ í´ë¦¬ì–´í•œ ìœ ì €ë§Œ ëŒ€ìƒ.
      // ì†Œìˆ˜ì  5ìë¦¬ ì •ë°€ë„ë¡œ ë™ì  ë°©ì§€.

      function updateHofButtonVisibility() {
        const saveData = getSaveData();
        const btn = document.getElementById('btnHallOfFame');
        if (saveData[MAX_STAGE] && saveData[MAX_STAGE].cleared) {
          btn.classList.remove('hidden');
        } else {
          btn.classList.add('hidden');
        }
      }

      async function loadHallOfFame() {
        try {
          // ëª¨ë“  rankings ë¬¸ì„œë¥¼ ê°€ì ¸ì™€ì„œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì§‘ê³„
          const q = query(
            collection(db, "rankings"),
            orderBy("time", "asc")
          );
          const snap = await getDocs(q);

          // ë‹‰ë„¤ì„ë³„ ìŠ¤í…Œì´ì§€ë³„ ìµœê³  ê¸°ë¡ ìˆ˜ì§‘
          const userStages = {}; // { nickname: { 1: time, 2: time, ... } }
          snap.docs.forEach(d => {
            const data = d.data();
            const nick = data.nickname;
            const stage = data.stage;
            const time = data.time;

            if (!userStages[nick]) userStages[nick] = {};
            // ê°€ì¥ ë¹ ë¥¸ ê¸°ë¡ë§Œ ìœ ì§€
            if (!userStages[nick][stage] || time < userStages[nick][stage]) {
              userStages[nick][stage] = time;
            }
          });

          // 10ê°œ ìŠ¤í…Œì´ì§€ ëª¨ë‘ í´ë¦¬ì–´í•œ ìœ ì €ë§Œ totalTime ê³„ì‚°
          const hallData = [];
          for (const nick of Object.keys(userStages)) {
            let allCleared = true;
            let total = 0;
            for (let s = 1; s <= MAX_STAGE; s++) {
              if (userStages[nick][s] === undefined) {
                allCleared = false;
                break;
              }
              total += userStages[nick][s];
            }
            if (allCleared) {
              hallData.push({
                nickname: nick,
                totalTime: Number(total.toFixed(5))
              });
            }
          }

          // totalTime ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬, ìƒìœ„ 10ëª…
          hallData.sort((a, b) => a.totalTime - b.totalTime);
          return hallData.slice(0, 10);
        } catch (e) {
          console.error("Hall of Fame load error:", e);
          return [];
        }
      }

      function formatTotalTime(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = (seconds % 60).toFixed(3);
        return `${min}:${sec.padStart(6, '0')}`;
      }

      async function showHallOfFame() {
        // í™”ë©´ ì „í™˜
        document.getElementById('homeScreen').classList.add('hidden');
        document.getElementById('hallOfFameScreen').classList.remove('hidden');

        // ë¡œë”© í‘œì‹œ
        document.getElementById('hofList').innerHTML = '<div class="hof-empty">Loading...</div>';
        ['podiumName1', 'podiumName2', 'podiumName3'].forEach(id => {
          document.getElementById(id).innerText = '---';
        });
        ['podiumTime1', 'podiumTime2', 'podiumTime3'].forEach(id => {
          document.getElementById(id).innerText = '--:--.---';
        });

        const data = await loadHallOfFame();

        if (data.length === 0) {
          document.getElementById('hofList').innerHTML =
            '<div class="hof-empty">ì•„ì§ ì „ ìŠ¤í…Œì´ì§€ë¥¼ í´ë¦¬ì–´í•œ ìœ ì €ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
          return;
        }

        // ì‹œìƒëŒ€ (Top 3)
        const podiumIds = [
          { name: 'podiumName1', time: 'podiumTime1' },
          { name: 'podiumName2', time: 'podiumTime2' },
          { name: 'podiumName3', time: 'podiumTime3' }
        ];

        for (let i = 0; i < 3; i++) {
          if (data[i]) {
            document.getElementById(podiumIds[i].name).innerText = data[i].nickname;
            document.getElementById(podiumIds[i].time).innerText = formatTotalTime(data[i].totalTime);
          }
        }

        // 4~10ìœ„ ë¦¬ìŠ¤íŠ¸
        const listEl = document.getElementById('hofList');
        if (data.length <= 3) {
          listEl.innerHTML = '<div class="hof-empty">4ìœ„ ì´í•˜ ê¸°ë¡ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤</div>';
        } else {
          listEl.innerHTML = '';
          for (let i = 3; i < data.length; i++) {
            const entry = document.createElement('div');
            entry.className = 'hof-entry';
            entry.innerHTML = `
              <span class="hof-rank">${i + 1}</span>
              <span class="hof-name">${data[i].nickname}</span>
              <span class="hof-time">${formatTotalTime(data[i].totalTime)}</span>
            `;
            listEl.appendChild(entry);
          }
        }
      }

      // Hall of Fame ë²„íŠ¼ ì´ë²¤íŠ¸
      document.getElementById('btnHallOfFame').onclick = showHallOfFame;
      document.getElementById('btnHofBack').onclick = function () {
        document.getElementById('hallOfFameScreen').classList.add('hidden');
        document.getElementById('homeScreen').classList.remove('hidden');
      };

      // ============================================
      // GAME LOOP [ê²°ì •ë¡ ì  ì‹œë®¬ë ˆì´ì…˜ ì¬ì„¤ê³„]
      // ============================================
      // ë°ì´í„° ì „ëµ: requestAnimationFrameì˜ ê°€ë³€ dtë¥¼ íê¸°í•˜ê³ 
      // FIXED_DT(1/60) ê³ ì • íƒ€ì„ìŠ¤í… + accumulator íŒ¨í„´ì„ ë„ì….
      // ì €ì‚¬ì–‘ ê¸°ê¸° ë³´í˜¸: MAX_ACCUMULATORë¡œ ì—°ì‚°ëŸ‰ í­ì£¼ ë°©ì§€.
      //
      // ì´ì :
      // 1. ì–´ë–¤ í”„ë ˆì„ìœ¨ì—ì„œë“  ë™ì¼í•œ ë¬¼ë¦¬ ê²°ê³¼ (120Hz ëª¨ë‹ˆí„°, 30fps ëª¨ë°”ì¼ ë™ì¼)
      // 2. í”„ë ˆì„ ë“œë ì‹œì—ë„ ë¬¼ë¦¬ê°€ ëŒ€ì¶©í•˜ì§€ ì•Šê³  ì •ìˆ˜ë°°ë§Œ ìˆ˜í–‰
      // 3. MAX_PHYSICS_STEPS(5)ë¡œ í•œ í”„ë ˆì„ë‹¹ ìµœëŒ€ ì—°ì‚°ëŸ‰ ì œí•œ
      let lastTime = 0;
      let accumulator = 0;  // ì‹¤ì œ ê²½ê³¼ ì‹œê°„ ì ë¦½

      function loop(now) {
        // ë°ì´í„° ì „ëµ: frameDtê°€ 250ms ì´ìƒì´ë©´ ë¸Œë¼ìš°ì € íƒ­ ì „í™˜ ë“±ìœ¼ë¡œ
        // ê°„ì£¼. ì´ ê²½ìš° ëŒ€ëŸ‰ ë°€ë¦¼ ì—°ì‚°ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ 250msë¡œ cap.
        const frameDt = Math.min((now - lastTime) / 1000, 0.25);
        lastTime = now;

        if (state.screen === 'game') {
          if ((state.mode === 'run' || state.mode === 'replay') && !state.isPaused) {
            
            // ë¦¬í”Œë ˆì´ ëª¨ë“œì¼ ê²½ìš° í˜„ì‹¤ ì‹œê°„ì— timeScale(ì˜ˆ: 0.1ë°°)ì„ ê³±í•¨
            let currentDt = frameDt;
            if (state.mode === 'replay') {
               currentDt *= state.timeScale;
            }

            accumulator += currentDt;

            // Safety Valve: ì €ì‚¬ì–‘ ê¸°ê¸°ì—ì„œ accumulator í­ì£¼ ë°©ì§€
            // MAX_ACCUMULATOR(â‰ˆ83.3ms = 5 * FIXED_DT)ë¡œ ìƒí•œ ì„¤ì •.
            if (accumulator > MAX_ACCUMULATOR) {
              accumulator = MAX_ACCUMULATOR;
            }

            // â–¼ ê²°ì •ë¡ ì  ë¬¼ë¦¬ ë£¨í”„: í•­ìƒ FIXED_DT(1/60)ì”© ì •ìˆ˜ë°° ì‹¤í–‰
            let steps = 0;
            while (accumulator >= FIXED_DT && steps < MAX_PHYSICS_STEPS) {
              updatePhysics(FIXED_DT);
              accumulator -= FIXED_DT;
              steps++;
              // win/fail ë°œìƒ ì‹œ ì¦‰ì‹œ ì¤‘ë‹¨
              if (state.mode !== 'run' && state.mode !== 'replay') {
                accumulator = 0;
                break;
              }
            }

            if (state.timerRunning) {
              state.timer += currentDt; // íƒ€ì´ë¨¸ë„ ë°°ì†ì— ë§ì¶° ì²œì²œíˆ ì˜¬ë¼ê°
              updateUI();
            }
          }

          render();
        }

        requestAnimationFrame(loop);
      }

      // ============================================
      // INIT
      // ============================================
      resizeCanvas();
      renderLevelGrid();
      // selectStage(1) ì œê±°: ì—…ë°ì´íŠ¸ - ë¡œë¹„ì—ì„œ ìŠ¤í…Œì´ì§€ í´ë¦­ ì‹œ ëœí‚¹ í™”ë©´ í‘œì‹œ
      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>
